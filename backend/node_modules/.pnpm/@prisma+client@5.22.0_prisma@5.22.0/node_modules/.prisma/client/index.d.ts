
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Race
 * 
 */
export type Race = $Result.DefaultSelection<Prisma.$RacePayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Lignee
 * 
 */
export type Lignee = $Result.DefaultSelection<Prisma.$LigneePayload>
/**
 * Model Personnage
 * 
 */
export type Personnage = $Result.DefaultSelection<Prisma.$PersonnagePayload>
/**
 * Model PersonnageRole
 * 
 */
export type PersonnageRole = $Result.DefaultSelection<Prisma.$PersonnageRolePayload>
/**
 * Model Competence
 * 
 */
export type Competence = $Result.DefaultSelection<Prisma.$CompetencePayload>
/**
 * Model PersonnageCompetence
 * 
 */
export type PersonnageCompetence = $Result.DefaultSelection<Prisma.$PersonnageCompetencePayload>
/**
 * Model Domaine
 * 
 */
export type Domaine = $Result.DefaultSelection<Prisma.$DomainePayload>
/**
 * Model Titre
 * 
 */
export type Titre = $Result.DefaultSelection<Prisma.$TitrePayload>
/**
 * Model PersonnageTitre
 * 
 */
export type PersonnageTitre = $Result.DefaultSelection<Prisma.$PersonnageTitrePayload>
/**
 * Model Village
 * 
 */
export type Village = $Result.DefaultSelection<Prisma.$VillagePayload>
/**
 * Model Guilde
 * 
 */
export type Guilde = $Result.DefaultSelection<Prisma.$GuildePayload>
/**
 * Model GuildeMembre
 * 
 */
export type GuildeMembre = $Result.DefaultSelection<Prisma.$GuildeMembrePayload>
/**
 * Model Creature
 * 
 */
export type Creature = $Result.DefaultSelection<Prisma.$CreaturePayload>
/**
 * Model EcoleMagie
 * 
 */
export type EcoleMagie = $Result.DefaultSelection<Prisma.$EcoleMagiePayload>
/**
 * Model Sort
 * 
 */
export type Sort = $Result.DefaultSelection<Prisma.$SortPayload>
/**
 * Model Maladie
 * 
 */
export type Maladie = $Result.DefaultSelection<Prisma.$MaladiePayload>
/**
 * Model PersonnageMaladie
 * 
 */
export type PersonnageMaladie = $Result.DefaultSelection<Prisma.$PersonnageMaladiePayload>
/**
 * Model Armee
 * 
 */
export type Armee = $Result.DefaultSelection<Prisma.$ArmeePayload>
/**
 * Model Bataille
 * 
 */
export type Bataille = $Result.DefaultSelection<Prisma.$BataillePayload>
/**
 * Model ArmeeBataille
 * 
 */
export type ArmeeBataille = $Result.DefaultSelection<Prisma.$ArmeeBataillePayload>
/**
 * Model GuildeBataille
 * 
 */
export type GuildeBataille = $Result.DefaultSelection<Prisma.$GuildeBataillePayload>
/**
 * Model CreatureBataille
 * 
 */
export type CreatureBataille = $Result.DefaultSelection<Prisma.$CreatureBataillePayload>
/**
 * Model Equipement
 * 
 */
export type Equipement = $Result.DefaultSelection<Prisma.$EquipementPayload>
/**
 * Model PersonnageEquipement
 * 
 */
export type PersonnageEquipement = $Result.DefaultSelection<Prisma.$PersonnageEquipementPayload>
/**
 * Model Marchand
 * 
 */
export type Marchand = $Result.DefaultSelection<Prisma.$MarchandPayload>
/**
 * Model RouteCommerciale
 * 
 */
export type RouteCommerciale = $Result.DefaultSelection<Prisma.$RouteCommercialePayload>
/**
 * Model Lieu
 * 
 */
export type Lieu = $Result.DefaultSelection<Prisma.$LieuPayload>
/**
 * Model RouteSegment
 * 
 */
export type RouteSegment = $Result.DefaultSelection<Prisma.$RouteSegmentPayload>
/**
 * Model MarchandRoute
 * 
 */
export type MarchandRoute = $Result.DefaultSelection<Prisma.$MarchandRoutePayload>
/**
 * Model Barde
 * 
 */
export type Barde = $Result.DefaultSelection<Prisma.$BardePayload>
/**
 * Model Histoire
 * 
 */
export type Histoire = $Result.DefaultSelection<Prisma.$HistoirePayload>
/**
 * Model Inventaire
 * 
 */
export type Inventaire = $Result.DefaultSelection<Prisma.$InventairePayload>
/**
 * Model RelationDiplomatique
 * 
 */
export type RelationDiplomatique = $Result.DefaultSelection<Prisma.$RelationDiplomatiquePayload>
/**
 * Model Loi
 * 
 */
export type Loi = $Result.DefaultSelection<Prisma.$LoiPayload>
/**
 * Model LoiTerritoire
 * 
 */
export type LoiTerritoire = $Result.DefaultSelection<Prisma.$LoiTerritoirePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Races
 * const races = await prisma.race.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Races
   * const races = await prisma.race.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.race`: Exposes CRUD operations for the **Race** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Races
    * const races = await prisma.race.findMany()
    * ```
    */
  get race(): Prisma.RaceDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.lignee`: Exposes CRUD operations for the **Lignee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lignees
    * const lignees = await prisma.lignee.findMany()
    * ```
    */
  get lignee(): Prisma.LigneeDelegate<ExtArgs>;

  /**
   * `prisma.personnage`: Exposes CRUD operations for the **Personnage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personnages
    * const personnages = await prisma.personnage.findMany()
    * ```
    */
  get personnage(): Prisma.PersonnageDelegate<ExtArgs>;

  /**
   * `prisma.personnageRole`: Exposes CRUD operations for the **PersonnageRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonnageRoles
    * const personnageRoles = await prisma.personnageRole.findMany()
    * ```
    */
  get personnageRole(): Prisma.PersonnageRoleDelegate<ExtArgs>;

  /**
   * `prisma.competence`: Exposes CRUD operations for the **Competence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Competences
    * const competences = await prisma.competence.findMany()
    * ```
    */
  get competence(): Prisma.CompetenceDelegate<ExtArgs>;

  /**
   * `prisma.personnageCompetence`: Exposes CRUD operations for the **PersonnageCompetence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonnageCompetences
    * const personnageCompetences = await prisma.personnageCompetence.findMany()
    * ```
    */
  get personnageCompetence(): Prisma.PersonnageCompetenceDelegate<ExtArgs>;

  /**
   * `prisma.domaine`: Exposes CRUD operations for the **Domaine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Domaines
    * const domaines = await prisma.domaine.findMany()
    * ```
    */
  get domaine(): Prisma.DomaineDelegate<ExtArgs>;

  /**
   * `prisma.titre`: Exposes CRUD operations for the **Titre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titres
    * const titres = await prisma.titre.findMany()
    * ```
    */
  get titre(): Prisma.TitreDelegate<ExtArgs>;

  /**
   * `prisma.personnageTitre`: Exposes CRUD operations for the **PersonnageTitre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonnageTitres
    * const personnageTitres = await prisma.personnageTitre.findMany()
    * ```
    */
  get personnageTitre(): Prisma.PersonnageTitreDelegate<ExtArgs>;

  /**
   * `prisma.village`: Exposes CRUD operations for the **Village** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Villages
    * const villages = await prisma.village.findMany()
    * ```
    */
  get village(): Prisma.VillageDelegate<ExtArgs>;

  /**
   * `prisma.guilde`: Exposes CRUD operations for the **Guilde** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guildes
    * const guildes = await prisma.guilde.findMany()
    * ```
    */
  get guilde(): Prisma.GuildeDelegate<ExtArgs>;

  /**
   * `prisma.guildeMembre`: Exposes CRUD operations for the **GuildeMembre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildeMembres
    * const guildeMembres = await prisma.guildeMembre.findMany()
    * ```
    */
  get guildeMembre(): Prisma.GuildeMembreDelegate<ExtArgs>;

  /**
   * `prisma.creature`: Exposes CRUD operations for the **Creature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creatures
    * const creatures = await prisma.creature.findMany()
    * ```
    */
  get creature(): Prisma.CreatureDelegate<ExtArgs>;

  /**
   * `prisma.ecoleMagie`: Exposes CRUD operations for the **EcoleMagie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EcoleMagies
    * const ecoleMagies = await prisma.ecoleMagie.findMany()
    * ```
    */
  get ecoleMagie(): Prisma.EcoleMagieDelegate<ExtArgs>;

  /**
   * `prisma.sort`: Exposes CRUD operations for the **Sort** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sorts
    * const sorts = await prisma.sort.findMany()
    * ```
    */
  get sort(): Prisma.SortDelegate<ExtArgs>;

  /**
   * `prisma.maladie`: Exposes CRUD operations for the **Maladie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maladies
    * const maladies = await prisma.maladie.findMany()
    * ```
    */
  get maladie(): Prisma.MaladieDelegate<ExtArgs>;

  /**
   * `prisma.personnageMaladie`: Exposes CRUD operations for the **PersonnageMaladie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonnageMaladies
    * const personnageMaladies = await prisma.personnageMaladie.findMany()
    * ```
    */
  get personnageMaladie(): Prisma.PersonnageMaladieDelegate<ExtArgs>;

  /**
   * `prisma.armee`: Exposes CRUD operations for the **Armee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Armees
    * const armees = await prisma.armee.findMany()
    * ```
    */
  get armee(): Prisma.ArmeeDelegate<ExtArgs>;

  /**
   * `prisma.bataille`: Exposes CRUD operations for the **Bataille** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batailles
    * const batailles = await prisma.bataille.findMany()
    * ```
    */
  get bataille(): Prisma.BatailleDelegate<ExtArgs>;

  /**
   * `prisma.armeeBataille`: Exposes CRUD operations for the **ArmeeBataille** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArmeeBatailles
    * const armeeBatailles = await prisma.armeeBataille.findMany()
    * ```
    */
  get armeeBataille(): Prisma.ArmeeBatailleDelegate<ExtArgs>;

  /**
   * `prisma.guildeBataille`: Exposes CRUD operations for the **GuildeBataille** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildeBatailles
    * const guildeBatailles = await prisma.guildeBataille.findMany()
    * ```
    */
  get guildeBataille(): Prisma.GuildeBatailleDelegate<ExtArgs>;

  /**
   * `prisma.creatureBataille`: Exposes CRUD operations for the **CreatureBataille** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatureBatailles
    * const creatureBatailles = await prisma.creatureBataille.findMany()
    * ```
    */
  get creatureBataille(): Prisma.CreatureBatailleDelegate<ExtArgs>;

  /**
   * `prisma.equipement`: Exposes CRUD operations for the **Equipement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipements
    * const equipements = await prisma.equipement.findMany()
    * ```
    */
  get equipement(): Prisma.EquipementDelegate<ExtArgs>;

  /**
   * `prisma.personnageEquipement`: Exposes CRUD operations for the **PersonnageEquipement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonnageEquipements
    * const personnageEquipements = await prisma.personnageEquipement.findMany()
    * ```
    */
  get personnageEquipement(): Prisma.PersonnageEquipementDelegate<ExtArgs>;

  /**
   * `prisma.marchand`: Exposes CRUD operations for the **Marchand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marchands
    * const marchands = await prisma.marchand.findMany()
    * ```
    */
  get marchand(): Prisma.MarchandDelegate<ExtArgs>;

  /**
   * `prisma.routeCommerciale`: Exposes CRUD operations for the **RouteCommerciale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteCommerciales
    * const routeCommerciales = await prisma.routeCommerciale.findMany()
    * ```
    */
  get routeCommerciale(): Prisma.RouteCommercialeDelegate<ExtArgs>;

  /**
   * `prisma.lieu`: Exposes CRUD operations for the **Lieu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lieus
    * const lieus = await prisma.lieu.findMany()
    * ```
    */
  get lieu(): Prisma.LieuDelegate<ExtArgs>;

  /**
   * `prisma.routeSegment`: Exposes CRUD operations for the **RouteSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteSegments
    * const routeSegments = await prisma.routeSegment.findMany()
    * ```
    */
  get routeSegment(): Prisma.RouteSegmentDelegate<ExtArgs>;

  /**
   * `prisma.marchandRoute`: Exposes CRUD operations for the **MarchandRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarchandRoutes
    * const marchandRoutes = await prisma.marchandRoute.findMany()
    * ```
    */
  get marchandRoute(): Prisma.MarchandRouteDelegate<ExtArgs>;

  /**
   * `prisma.barde`: Exposes CRUD operations for the **Barde** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bardes
    * const bardes = await prisma.barde.findMany()
    * ```
    */
  get barde(): Prisma.BardeDelegate<ExtArgs>;

  /**
   * `prisma.histoire`: Exposes CRUD operations for the **Histoire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Histoires
    * const histoires = await prisma.histoire.findMany()
    * ```
    */
  get histoire(): Prisma.HistoireDelegate<ExtArgs>;

  /**
   * `prisma.inventaire`: Exposes CRUD operations for the **Inventaire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventaires
    * const inventaires = await prisma.inventaire.findMany()
    * ```
    */
  get inventaire(): Prisma.InventaireDelegate<ExtArgs>;

  /**
   * `prisma.relationDiplomatique`: Exposes CRUD operations for the **RelationDiplomatique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelationDiplomatiques
    * const relationDiplomatiques = await prisma.relationDiplomatique.findMany()
    * ```
    */
  get relationDiplomatique(): Prisma.RelationDiplomatiqueDelegate<ExtArgs>;

  /**
   * `prisma.loi`: Exposes CRUD operations for the **Loi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lois
    * const lois = await prisma.loi.findMany()
    * ```
    */
  get loi(): Prisma.LoiDelegate<ExtArgs>;

  /**
   * `prisma.loiTerritoire`: Exposes CRUD operations for the **LoiTerritoire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoiTerritoires
    * const loiTerritoires = await prisma.loiTerritoire.findMany()
    * ```
    */
  get loiTerritoire(): Prisma.LoiTerritoireDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Race: 'Race',
    Role: 'Role',
    Lignee: 'Lignee',
    Personnage: 'Personnage',
    PersonnageRole: 'PersonnageRole',
    Competence: 'Competence',
    PersonnageCompetence: 'PersonnageCompetence',
    Domaine: 'Domaine',
    Titre: 'Titre',
    PersonnageTitre: 'PersonnageTitre',
    Village: 'Village',
    Guilde: 'Guilde',
    GuildeMembre: 'GuildeMembre',
    Creature: 'Creature',
    EcoleMagie: 'EcoleMagie',
    Sort: 'Sort',
    Maladie: 'Maladie',
    PersonnageMaladie: 'PersonnageMaladie',
    Armee: 'Armee',
    Bataille: 'Bataille',
    ArmeeBataille: 'ArmeeBataille',
    GuildeBataille: 'GuildeBataille',
    CreatureBataille: 'CreatureBataille',
    Equipement: 'Equipement',
    PersonnageEquipement: 'PersonnageEquipement',
    Marchand: 'Marchand',
    RouteCommerciale: 'RouteCommerciale',
    Lieu: 'Lieu',
    RouteSegment: 'RouteSegment',
    MarchandRoute: 'MarchandRoute',
    Barde: 'Barde',
    Histoire: 'Histoire',
    Inventaire: 'Inventaire',
    RelationDiplomatique: 'RelationDiplomatique',
    Loi: 'Loi',
    LoiTerritoire: 'LoiTerritoire'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "race" | "role" | "lignee" | "personnage" | "personnageRole" | "competence" | "personnageCompetence" | "domaine" | "titre" | "personnageTitre" | "village" | "guilde" | "guildeMembre" | "creature" | "ecoleMagie" | "sort" | "maladie" | "personnageMaladie" | "armee" | "bataille" | "armeeBataille" | "guildeBataille" | "creatureBataille" | "equipement" | "personnageEquipement" | "marchand" | "routeCommerciale" | "lieu" | "routeSegment" | "marchandRoute" | "barde" | "histoire" | "inventaire" | "relationDiplomatique" | "loi" | "loiTerritoire"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Race: {
        payload: Prisma.$RacePayload<ExtArgs>
        fields: Prisma.RaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findFirst: {
            args: Prisma.RaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findMany: {
            args: Prisma.RaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          create: {
            args: Prisma.RaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          createMany: {
            args: Prisma.RaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          delete: {
            args: Prisma.RaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          update: {
            args: Prisma.RaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          deleteMany: {
            args: Prisma.RaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          aggregate: {
            args: Prisma.RaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRace>
          }
          groupBy: {
            args: Prisma.RaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceCountArgs<ExtArgs>
            result: $Utils.Optional<RaceCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Lignee: {
        payload: Prisma.$LigneePayload<ExtArgs>
        fields: Prisma.LigneeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneePayload>
          }
          findFirst: {
            args: Prisma.LigneeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneePayload>
          }
          findMany: {
            args: Prisma.LigneeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneePayload>[]
          }
          create: {
            args: Prisma.LigneeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneePayload>
          }
          createMany: {
            args: Prisma.LigneeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LigneeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneePayload>[]
          }
          delete: {
            args: Prisma.LigneeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneePayload>
          }
          update: {
            args: Prisma.LigneeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneePayload>
          }
          deleteMany: {
            args: Prisma.LigneeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LigneeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneePayload>
          }
          aggregate: {
            args: Prisma.LigneeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLignee>
          }
          groupBy: {
            args: Prisma.LigneeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneeCountArgs<ExtArgs>
            result: $Utils.Optional<LigneeCountAggregateOutputType> | number
          }
        }
      }
      Personnage: {
        payload: Prisma.$PersonnagePayload<ExtArgs>
        fields: Prisma.PersonnageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnagePayload>
          }
          findFirst: {
            args: Prisma.PersonnageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnagePayload>
          }
          findMany: {
            args: Prisma.PersonnageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnagePayload>[]
          }
          create: {
            args: Prisma.PersonnageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnagePayload>
          }
          createMany: {
            args: Prisma.PersonnageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonnageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnagePayload>[]
          }
          delete: {
            args: Prisma.PersonnageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnagePayload>
          }
          update: {
            args: Prisma.PersonnageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnagePayload>
          }
          deleteMany: {
            args: Prisma.PersonnageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonnageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnagePayload>
          }
          aggregate: {
            args: Prisma.PersonnageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnage>
          }
          groupBy: {
            args: Prisma.PersonnageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnageCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnageCountAggregateOutputType> | number
          }
        }
      }
      PersonnageRole: {
        payload: Prisma.$PersonnageRolePayload<ExtArgs>
        fields: Prisma.PersonnageRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnageRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnageRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageRolePayload>
          }
          findFirst: {
            args: Prisma.PersonnageRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnageRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageRolePayload>
          }
          findMany: {
            args: Prisma.PersonnageRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageRolePayload>[]
          }
          create: {
            args: Prisma.PersonnageRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageRolePayload>
          }
          createMany: {
            args: Prisma.PersonnageRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonnageRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageRolePayload>[]
          }
          delete: {
            args: Prisma.PersonnageRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageRolePayload>
          }
          update: {
            args: Prisma.PersonnageRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageRolePayload>
          }
          deleteMany: {
            args: Prisma.PersonnageRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnageRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonnageRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageRolePayload>
          }
          aggregate: {
            args: Prisma.PersonnageRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnageRole>
          }
          groupBy: {
            args: Prisma.PersonnageRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnageRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnageRoleCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnageRoleCountAggregateOutputType> | number
          }
        }
      }
      Competence: {
        payload: Prisma.$CompetencePayload<ExtArgs>
        fields: Prisma.CompetenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompetenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompetenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          findFirst: {
            args: Prisma.CompetenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompetenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          findMany: {
            args: Prisma.CompetenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>[]
          }
          create: {
            args: Prisma.CompetenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          createMany: {
            args: Prisma.CompetenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompetenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>[]
          }
          delete: {
            args: Prisma.CompetenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          update: {
            args: Prisma.CompetenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          deleteMany: {
            args: Prisma.CompetenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompetenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompetenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetencePayload>
          }
          aggregate: {
            args: Prisma.CompetenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompetence>
          }
          groupBy: {
            args: Prisma.CompetenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompetenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompetenceCountArgs<ExtArgs>
            result: $Utils.Optional<CompetenceCountAggregateOutputType> | number
          }
        }
      }
      PersonnageCompetence: {
        payload: Prisma.$PersonnageCompetencePayload<ExtArgs>
        fields: Prisma.PersonnageCompetenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnageCompetenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageCompetencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnageCompetenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageCompetencePayload>
          }
          findFirst: {
            args: Prisma.PersonnageCompetenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageCompetencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnageCompetenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageCompetencePayload>
          }
          findMany: {
            args: Prisma.PersonnageCompetenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageCompetencePayload>[]
          }
          create: {
            args: Prisma.PersonnageCompetenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageCompetencePayload>
          }
          createMany: {
            args: Prisma.PersonnageCompetenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonnageCompetenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageCompetencePayload>[]
          }
          delete: {
            args: Prisma.PersonnageCompetenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageCompetencePayload>
          }
          update: {
            args: Prisma.PersonnageCompetenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageCompetencePayload>
          }
          deleteMany: {
            args: Prisma.PersonnageCompetenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnageCompetenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonnageCompetenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageCompetencePayload>
          }
          aggregate: {
            args: Prisma.PersonnageCompetenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnageCompetence>
          }
          groupBy: {
            args: Prisma.PersonnageCompetenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnageCompetenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnageCompetenceCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnageCompetenceCountAggregateOutputType> | number
          }
        }
      }
      Domaine: {
        payload: Prisma.$DomainePayload<ExtArgs>
        fields: Prisma.DomaineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomaineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomaineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          findFirst: {
            args: Prisma.DomaineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomaineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          findMany: {
            args: Prisma.DomaineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>[]
          }
          create: {
            args: Prisma.DomaineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          createMany: {
            args: Prisma.DomaineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomaineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>[]
          }
          delete: {
            args: Prisma.DomaineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          update: {
            args: Prisma.DomaineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          deleteMany: {
            args: Prisma.DomaineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomaineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DomaineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainePayload>
          }
          aggregate: {
            args: Prisma.DomaineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomaine>
          }
          groupBy: {
            args: Prisma.DomaineGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomaineGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomaineCountArgs<ExtArgs>
            result: $Utils.Optional<DomaineCountAggregateOutputType> | number
          }
        }
      }
      Titre: {
        payload: Prisma.$TitrePayload<ExtArgs>
        fields: Prisma.TitreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TitreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TitreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitrePayload>
          }
          findFirst: {
            args: Prisma.TitreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TitreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitrePayload>
          }
          findMany: {
            args: Prisma.TitreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitrePayload>[]
          }
          create: {
            args: Prisma.TitreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitrePayload>
          }
          createMany: {
            args: Prisma.TitreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TitreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitrePayload>[]
          }
          delete: {
            args: Prisma.TitreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitrePayload>
          }
          update: {
            args: Prisma.TitreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitrePayload>
          }
          deleteMany: {
            args: Prisma.TitreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TitreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TitreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitrePayload>
          }
          aggregate: {
            args: Prisma.TitreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTitre>
          }
          groupBy: {
            args: Prisma.TitreGroupByArgs<ExtArgs>
            result: $Utils.Optional<TitreGroupByOutputType>[]
          }
          count: {
            args: Prisma.TitreCountArgs<ExtArgs>
            result: $Utils.Optional<TitreCountAggregateOutputType> | number
          }
        }
      }
      PersonnageTitre: {
        payload: Prisma.$PersonnageTitrePayload<ExtArgs>
        fields: Prisma.PersonnageTitreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnageTitreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageTitrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnageTitreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageTitrePayload>
          }
          findFirst: {
            args: Prisma.PersonnageTitreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageTitrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnageTitreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageTitrePayload>
          }
          findMany: {
            args: Prisma.PersonnageTitreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageTitrePayload>[]
          }
          create: {
            args: Prisma.PersonnageTitreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageTitrePayload>
          }
          createMany: {
            args: Prisma.PersonnageTitreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonnageTitreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageTitrePayload>[]
          }
          delete: {
            args: Prisma.PersonnageTitreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageTitrePayload>
          }
          update: {
            args: Prisma.PersonnageTitreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageTitrePayload>
          }
          deleteMany: {
            args: Prisma.PersonnageTitreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnageTitreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonnageTitreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageTitrePayload>
          }
          aggregate: {
            args: Prisma.PersonnageTitreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnageTitre>
          }
          groupBy: {
            args: Prisma.PersonnageTitreGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnageTitreGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnageTitreCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnageTitreCountAggregateOutputType> | number
          }
        }
      }
      Village: {
        payload: Prisma.$VillagePayload<ExtArgs>
        fields: Prisma.VillageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VillageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VillagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VillageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VillagePayload>
          }
          findFirst: {
            args: Prisma.VillageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VillagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VillageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VillagePayload>
          }
          findMany: {
            args: Prisma.VillageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VillagePayload>[]
          }
          create: {
            args: Prisma.VillageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VillagePayload>
          }
          createMany: {
            args: Prisma.VillageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VillageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VillagePayload>[]
          }
          delete: {
            args: Prisma.VillageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VillagePayload>
          }
          update: {
            args: Prisma.VillageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VillagePayload>
          }
          deleteMany: {
            args: Prisma.VillageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VillageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VillageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VillagePayload>
          }
          aggregate: {
            args: Prisma.VillageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVillage>
          }
          groupBy: {
            args: Prisma.VillageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VillageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VillageCountArgs<ExtArgs>
            result: $Utils.Optional<VillageCountAggregateOutputType> | number
          }
        }
      }
      Guilde: {
        payload: Prisma.$GuildePayload<ExtArgs>
        fields: Prisma.GuildeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildePayload>
          }
          findFirst: {
            args: Prisma.GuildeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildePayload>
          }
          findMany: {
            args: Prisma.GuildeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildePayload>[]
          }
          create: {
            args: Prisma.GuildeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildePayload>
          }
          createMany: {
            args: Prisma.GuildeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuildeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildePayload>[]
          }
          delete: {
            args: Prisma.GuildeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildePayload>
          }
          update: {
            args: Prisma.GuildeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildePayload>
          }
          deleteMany: {
            args: Prisma.GuildeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildePayload>
          }
          aggregate: {
            args: Prisma.GuildeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuilde>
          }
          groupBy: {
            args: Prisma.GuildeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildeCountArgs<ExtArgs>
            result: $Utils.Optional<GuildeCountAggregateOutputType> | number
          }
        }
      }
      GuildeMembre: {
        payload: Prisma.$GuildeMembrePayload<ExtArgs>
        fields: Prisma.GuildeMembreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildeMembreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeMembrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildeMembreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeMembrePayload>
          }
          findFirst: {
            args: Prisma.GuildeMembreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeMembrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildeMembreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeMembrePayload>
          }
          findMany: {
            args: Prisma.GuildeMembreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeMembrePayload>[]
          }
          create: {
            args: Prisma.GuildeMembreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeMembrePayload>
          }
          createMany: {
            args: Prisma.GuildeMembreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuildeMembreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeMembrePayload>[]
          }
          delete: {
            args: Prisma.GuildeMembreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeMembrePayload>
          }
          update: {
            args: Prisma.GuildeMembreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeMembrePayload>
          }
          deleteMany: {
            args: Prisma.GuildeMembreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildeMembreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildeMembreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeMembrePayload>
          }
          aggregate: {
            args: Prisma.GuildeMembreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildeMembre>
          }
          groupBy: {
            args: Prisma.GuildeMembreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildeMembreGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildeMembreCountArgs<ExtArgs>
            result: $Utils.Optional<GuildeMembreCountAggregateOutputType> | number
          }
        }
      }
      Creature: {
        payload: Prisma.$CreaturePayload<ExtArgs>
        fields: Prisma.CreatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          findFirst: {
            args: Prisma.CreatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          findMany: {
            args: Prisma.CreatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          create: {
            args: Prisma.CreatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          createMany: {
            args: Prisma.CreatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          delete: {
            args: Prisma.CreatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          update: {
            args: Prisma.CreatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          deleteMany: {
            args: Prisma.CreatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          aggregate: {
            args: Prisma.CreatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreature>
          }
          groupBy: {
            args: Prisma.CreatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureCountAggregateOutputType> | number
          }
        }
      }
      EcoleMagie: {
        payload: Prisma.$EcoleMagiePayload<ExtArgs>
        fields: Prisma.EcoleMagieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EcoleMagieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoleMagiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EcoleMagieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoleMagiePayload>
          }
          findFirst: {
            args: Prisma.EcoleMagieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoleMagiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EcoleMagieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoleMagiePayload>
          }
          findMany: {
            args: Prisma.EcoleMagieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoleMagiePayload>[]
          }
          create: {
            args: Prisma.EcoleMagieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoleMagiePayload>
          }
          createMany: {
            args: Prisma.EcoleMagieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EcoleMagieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoleMagiePayload>[]
          }
          delete: {
            args: Prisma.EcoleMagieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoleMagiePayload>
          }
          update: {
            args: Prisma.EcoleMagieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoleMagiePayload>
          }
          deleteMany: {
            args: Prisma.EcoleMagieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EcoleMagieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EcoleMagieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcoleMagiePayload>
          }
          aggregate: {
            args: Prisma.EcoleMagieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEcoleMagie>
          }
          groupBy: {
            args: Prisma.EcoleMagieGroupByArgs<ExtArgs>
            result: $Utils.Optional<EcoleMagieGroupByOutputType>[]
          }
          count: {
            args: Prisma.EcoleMagieCountArgs<ExtArgs>
            result: $Utils.Optional<EcoleMagieCountAggregateOutputType> | number
          }
        }
      }
      Sort: {
        payload: Prisma.$SortPayload<ExtArgs>
        fields: Prisma.SortFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SortFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SortFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortPayload>
          }
          findFirst: {
            args: Prisma.SortFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SortFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortPayload>
          }
          findMany: {
            args: Prisma.SortFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortPayload>[]
          }
          create: {
            args: Prisma.SortCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortPayload>
          }
          createMany: {
            args: Prisma.SortCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SortCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortPayload>[]
          }
          delete: {
            args: Prisma.SortDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortPayload>
          }
          update: {
            args: Prisma.SortUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortPayload>
          }
          deleteMany: {
            args: Prisma.SortDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SortUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SortUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SortPayload>
          }
          aggregate: {
            args: Prisma.SortAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSort>
          }
          groupBy: {
            args: Prisma.SortGroupByArgs<ExtArgs>
            result: $Utils.Optional<SortGroupByOutputType>[]
          }
          count: {
            args: Prisma.SortCountArgs<ExtArgs>
            result: $Utils.Optional<SortCountAggregateOutputType> | number
          }
        }
      }
      Maladie: {
        payload: Prisma.$MaladiePayload<ExtArgs>
        fields: Prisma.MaladieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaladieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaladiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaladieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaladiePayload>
          }
          findFirst: {
            args: Prisma.MaladieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaladiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaladieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaladiePayload>
          }
          findMany: {
            args: Prisma.MaladieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaladiePayload>[]
          }
          create: {
            args: Prisma.MaladieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaladiePayload>
          }
          createMany: {
            args: Prisma.MaladieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaladieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaladiePayload>[]
          }
          delete: {
            args: Prisma.MaladieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaladiePayload>
          }
          update: {
            args: Prisma.MaladieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaladiePayload>
          }
          deleteMany: {
            args: Prisma.MaladieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaladieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaladieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaladiePayload>
          }
          aggregate: {
            args: Prisma.MaladieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaladie>
          }
          groupBy: {
            args: Prisma.MaladieGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaladieGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaladieCountArgs<ExtArgs>
            result: $Utils.Optional<MaladieCountAggregateOutputType> | number
          }
        }
      }
      PersonnageMaladie: {
        payload: Prisma.$PersonnageMaladiePayload<ExtArgs>
        fields: Prisma.PersonnageMaladieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnageMaladieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageMaladiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnageMaladieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageMaladiePayload>
          }
          findFirst: {
            args: Prisma.PersonnageMaladieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageMaladiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnageMaladieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageMaladiePayload>
          }
          findMany: {
            args: Prisma.PersonnageMaladieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageMaladiePayload>[]
          }
          create: {
            args: Prisma.PersonnageMaladieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageMaladiePayload>
          }
          createMany: {
            args: Prisma.PersonnageMaladieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonnageMaladieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageMaladiePayload>[]
          }
          delete: {
            args: Prisma.PersonnageMaladieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageMaladiePayload>
          }
          update: {
            args: Prisma.PersonnageMaladieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageMaladiePayload>
          }
          deleteMany: {
            args: Prisma.PersonnageMaladieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnageMaladieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonnageMaladieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageMaladiePayload>
          }
          aggregate: {
            args: Prisma.PersonnageMaladieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnageMaladie>
          }
          groupBy: {
            args: Prisma.PersonnageMaladieGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnageMaladieGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnageMaladieCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnageMaladieCountAggregateOutputType> | number
          }
        }
      }
      Armee: {
        payload: Prisma.$ArmeePayload<ExtArgs>
        fields: Prisma.ArmeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArmeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArmeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeePayload>
          }
          findFirst: {
            args: Prisma.ArmeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArmeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeePayload>
          }
          findMany: {
            args: Prisma.ArmeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeePayload>[]
          }
          create: {
            args: Prisma.ArmeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeePayload>
          }
          createMany: {
            args: Prisma.ArmeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArmeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeePayload>[]
          }
          delete: {
            args: Prisma.ArmeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeePayload>
          }
          update: {
            args: Prisma.ArmeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeePayload>
          }
          deleteMany: {
            args: Prisma.ArmeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArmeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArmeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeePayload>
          }
          aggregate: {
            args: Prisma.ArmeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArmee>
          }
          groupBy: {
            args: Prisma.ArmeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArmeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArmeeCountArgs<ExtArgs>
            result: $Utils.Optional<ArmeeCountAggregateOutputType> | number
          }
        }
      }
      Bataille: {
        payload: Prisma.$BataillePayload<ExtArgs>
        fields: Prisma.BatailleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatailleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BataillePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatailleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BataillePayload>
          }
          findFirst: {
            args: Prisma.BatailleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BataillePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatailleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BataillePayload>
          }
          findMany: {
            args: Prisma.BatailleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BataillePayload>[]
          }
          create: {
            args: Prisma.BatailleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BataillePayload>
          }
          createMany: {
            args: Prisma.BatailleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatailleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BataillePayload>[]
          }
          delete: {
            args: Prisma.BatailleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BataillePayload>
          }
          update: {
            args: Prisma.BatailleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BataillePayload>
          }
          deleteMany: {
            args: Prisma.BatailleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatailleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BatailleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BataillePayload>
          }
          aggregate: {
            args: Prisma.BatailleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBataille>
          }
          groupBy: {
            args: Prisma.BatailleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatailleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatailleCountArgs<ExtArgs>
            result: $Utils.Optional<BatailleCountAggregateOutputType> | number
          }
        }
      }
      ArmeeBataille: {
        payload: Prisma.$ArmeeBataillePayload<ExtArgs>
        fields: Prisma.ArmeeBatailleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArmeeBatailleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeeBataillePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArmeeBatailleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeeBataillePayload>
          }
          findFirst: {
            args: Prisma.ArmeeBatailleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeeBataillePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArmeeBatailleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeeBataillePayload>
          }
          findMany: {
            args: Prisma.ArmeeBatailleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeeBataillePayload>[]
          }
          create: {
            args: Prisma.ArmeeBatailleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeeBataillePayload>
          }
          createMany: {
            args: Prisma.ArmeeBatailleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArmeeBatailleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeeBataillePayload>[]
          }
          delete: {
            args: Prisma.ArmeeBatailleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeeBataillePayload>
          }
          update: {
            args: Prisma.ArmeeBatailleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeeBataillePayload>
          }
          deleteMany: {
            args: Prisma.ArmeeBatailleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArmeeBatailleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArmeeBatailleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArmeeBataillePayload>
          }
          aggregate: {
            args: Prisma.ArmeeBatailleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArmeeBataille>
          }
          groupBy: {
            args: Prisma.ArmeeBatailleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArmeeBatailleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArmeeBatailleCountArgs<ExtArgs>
            result: $Utils.Optional<ArmeeBatailleCountAggregateOutputType> | number
          }
        }
      }
      GuildeBataille: {
        payload: Prisma.$GuildeBataillePayload<ExtArgs>
        fields: Prisma.GuildeBatailleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildeBatailleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeBataillePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildeBatailleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeBataillePayload>
          }
          findFirst: {
            args: Prisma.GuildeBatailleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeBataillePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildeBatailleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeBataillePayload>
          }
          findMany: {
            args: Prisma.GuildeBatailleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeBataillePayload>[]
          }
          create: {
            args: Prisma.GuildeBatailleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeBataillePayload>
          }
          createMany: {
            args: Prisma.GuildeBatailleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuildeBatailleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeBataillePayload>[]
          }
          delete: {
            args: Prisma.GuildeBatailleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeBataillePayload>
          }
          update: {
            args: Prisma.GuildeBatailleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeBataillePayload>
          }
          deleteMany: {
            args: Prisma.GuildeBatailleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildeBatailleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuildeBatailleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildeBataillePayload>
          }
          aggregate: {
            args: Prisma.GuildeBatailleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildeBataille>
          }
          groupBy: {
            args: Prisma.GuildeBatailleGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildeBatailleGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildeBatailleCountArgs<ExtArgs>
            result: $Utils.Optional<GuildeBatailleCountAggregateOutputType> | number
          }
        }
      }
      CreatureBataille: {
        payload: Prisma.$CreatureBataillePayload<ExtArgs>
        fields: Prisma.CreatureBatailleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureBatailleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureBataillePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureBatailleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureBataillePayload>
          }
          findFirst: {
            args: Prisma.CreatureBatailleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureBataillePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureBatailleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureBataillePayload>
          }
          findMany: {
            args: Prisma.CreatureBatailleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureBataillePayload>[]
          }
          create: {
            args: Prisma.CreatureBatailleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureBataillePayload>
          }
          createMany: {
            args: Prisma.CreatureBatailleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureBatailleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureBataillePayload>[]
          }
          delete: {
            args: Prisma.CreatureBatailleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureBataillePayload>
          }
          update: {
            args: Prisma.CreatureBatailleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureBataillePayload>
          }
          deleteMany: {
            args: Prisma.CreatureBatailleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureBatailleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreatureBatailleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureBataillePayload>
          }
          aggregate: {
            args: Prisma.CreatureBatailleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatureBataille>
          }
          groupBy: {
            args: Prisma.CreatureBatailleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureBatailleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureBatailleCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureBatailleCountAggregateOutputType> | number
          }
        }
      }
      Equipement: {
        payload: Prisma.$EquipementPayload<ExtArgs>
        fields: Prisma.EquipementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          findFirst: {
            args: Prisma.EquipementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          findMany: {
            args: Prisma.EquipementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>[]
          }
          create: {
            args: Prisma.EquipementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          createMany: {
            args: Prisma.EquipementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>[]
          }
          delete: {
            args: Prisma.EquipementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          update: {
            args: Prisma.EquipementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          deleteMany: {
            args: Prisma.EquipementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          aggregate: {
            args: Prisma.EquipementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipement>
          }
          groupBy: {
            args: Prisma.EquipementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipementCountArgs<ExtArgs>
            result: $Utils.Optional<EquipementCountAggregateOutputType> | number
          }
        }
      }
      PersonnageEquipement: {
        payload: Prisma.$PersonnageEquipementPayload<ExtArgs>
        fields: Prisma.PersonnageEquipementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnageEquipementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageEquipementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnageEquipementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageEquipementPayload>
          }
          findFirst: {
            args: Prisma.PersonnageEquipementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageEquipementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnageEquipementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageEquipementPayload>
          }
          findMany: {
            args: Prisma.PersonnageEquipementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageEquipementPayload>[]
          }
          create: {
            args: Prisma.PersonnageEquipementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageEquipementPayload>
          }
          createMany: {
            args: Prisma.PersonnageEquipementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonnageEquipementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageEquipementPayload>[]
          }
          delete: {
            args: Prisma.PersonnageEquipementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageEquipementPayload>
          }
          update: {
            args: Prisma.PersonnageEquipementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageEquipementPayload>
          }
          deleteMany: {
            args: Prisma.PersonnageEquipementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnageEquipementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonnageEquipementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnageEquipementPayload>
          }
          aggregate: {
            args: Prisma.PersonnageEquipementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnageEquipement>
          }
          groupBy: {
            args: Prisma.PersonnageEquipementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnageEquipementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnageEquipementCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnageEquipementCountAggregateOutputType> | number
          }
        }
      }
      Marchand: {
        payload: Prisma.$MarchandPayload<ExtArgs>
        fields: Prisma.MarchandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarchandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarchandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandPayload>
          }
          findFirst: {
            args: Prisma.MarchandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarchandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandPayload>
          }
          findMany: {
            args: Prisma.MarchandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandPayload>[]
          }
          create: {
            args: Prisma.MarchandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandPayload>
          }
          createMany: {
            args: Prisma.MarchandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarchandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandPayload>[]
          }
          delete: {
            args: Prisma.MarchandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandPayload>
          }
          update: {
            args: Prisma.MarchandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandPayload>
          }
          deleteMany: {
            args: Prisma.MarchandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarchandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarchandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandPayload>
          }
          aggregate: {
            args: Prisma.MarchandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarchand>
          }
          groupBy: {
            args: Prisma.MarchandGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarchandGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarchandCountArgs<ExtArgs>
            result: $Utils.Optional<MarchandCountAggregateOutputType> | number
          }
        }
      }
      RouteCommerciale: {
        payload: Prisma.$RouteCommercialePayload<ExtArgs>
        fields: Prisma.RouteCommercialeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteCommercialeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteCommercialePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteCommercialeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteCommercialePayload>
          }
          findFirst: {
            args: Prisma.RouteCommercialeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteCommercialePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteCommercialeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteCommercialePayload>
          }
          findMany: {
            args: Prisma.RouteCommercialeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteCommercialePayload>[]
          }
          create: {
            args: Prisma.RouteCommercialeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteCommercialePayload>
          }
          createMany: {
            args: Prisma.RouteCommercialeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteCommercialeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteCommercialePayload>[]
          }
          delete: {
            args: Prisma.RouteCommercialeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteCommercialePayload>
          }
          update: {
            args: Prisma.RouteCommercialeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteCommercialePayload>
          }
          deleteMany: {
            args: Prisma.RouteCommercialeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteCommercialeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RouteCommercialeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteCommercialePayload>
          }
          aggregate: {
            args: Prisma.RouteCommercialeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteCommerciale>
          }
          groupBy: {
            args: Prisma.RouteCommercialeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteCommercialeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteCommercialeCountArgs<ExtArgs>
            result: $Utils.Optional<RouteCommercialeCountAggregateOutputType> | number
          }
        }
      }
      Lieu: {
        payload: Prisma.$LieuPayload<ExtArgs>
        fields: Prisma.LieuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LieuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LieuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LieuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LieuPayload>
          }
          findFirst: {
            args: Prisma.LieuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LieuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LieuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LieuPayload>
          }
          findMany: {
            args: Prisma.LieuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LieuPayload>[]
          }
          create: {
            args: Prisma.LieuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LieuPayload>
          }
          createMany: {
            args: Prisma.LieuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LieuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LieuPayload>[]
          }
          delete: {
            args: Prisma.LieuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LieuPayload>
          }
          update: {
            args: Prisma.LieuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LieuPayload>
          }
          deleteMany: {
            args: Prisma.LieuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LieuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LieuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LieuPayload>
          }
          aggregate: {
            args: Prisma.LieuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLieu>
          }
          groupBy: {
            args: Prisma.LieuGroupByArgs<ExtArgs>
            result: $Utils.Optional<LieuGroupByOutputType>[]
          }
          count: {
            args: Prisma.LieuCountArgs<ExtArgs>
            result: $Utils.Optional<LieuCountAggregateOutputType> | number
          }
        }
      }
      RouteSegment: {
        payload: Prisma.$RouteSegmentPayload<ExtArgs>
        fields: Prisma.RouteSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteSegmentPayload>
          }
          findFirst: {
            args: Prisma.RouteSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteSegmentPayload>
          }
          findMany: {
            args: Prisma.RouteSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteSegmentPayload>[]
          }
          create: {
            args: Prisma.RouteSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteSegmentPayload>
          }
          createMany: {
            args: Prisma.RouteSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteSegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteSegmentPayload>[]
          }
          delete: {
            args: Prisma.RouteSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteSegmentPayload>
          }
          update: {
            args: Prisma.RouteSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteSegmentPayload>
          }
          deleteMany: {
            args: Prisma.RouteSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RouteSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteSegmentPayload>
          }
          aggregate: {
            args: Prisma.RouteSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteSegment>
          }
          groupBy: {
            args: Prisma.RouteSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<RouteSegmentCountAggregateOutputType> | number
          }
        }
      }
      MarchandRoute: {
        payload: Prisma.$MarchandRoutePayload<ExtArgs>
        fields: Prisma.MarchandRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarchandRouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarchandRouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandRoutePayload>
          }
          findFirst: {
            args: Prisma.MarchandRouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarchandRouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandRoutePayload>
          }
          findMany: {
            args: Prisma.MarchandRouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandRoutePayload>[]
          }
          create: {
            args: Prisma.MarchandRouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandRoutePayload>
          }
          createMany: {
            args: Prisma.MarchandRouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarchandRouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandRoutePayload>[]
          }
          delete: {
            args: Prisma.MarchandRouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandRoutePayload>
          }
          update: {
            args: Prisma.MarchandRouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandRoutePayload>
          }
          deleteMany: {
            args: Prisma.MarchandRouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarchandRouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarchandRouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandRoutePayload>
          }
          aggregate: {
            args: Prisma.MarchandRouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarchandRoute>
          }
          groupBy: {
            args: Prisma.MarchandRouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarchandRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarchandRouteCountArgs<ExtArgs>
            result: $Utils.Optional<MarchandRouteCountAggregateOutputType> | number
          }
        }
      }
      Barde: {
        payload: Prisma.$BardePayload<ExtArgs>
        fields: Prisma.BardeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BardeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BardePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BardeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BardePayload>
          }
          findFirst: {
            args: Prisma.BardeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BardePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BardeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BardePayload>
          }
          findMany: {
            args: Prisma.BardeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BardePayload>[]
          }
          create: {
            args: Prisma.BardeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BardePayload>
          }
          createMany: {
            args: Prisma.BardeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BardeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BardePayload>[]
          }
          delete: {
            args: Prisma.BardeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BardePayload>
          }
          update: {
            args: Prisma.BardeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BardePayload>
          }
          deleteMany: {
            args: Prisma.BardeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BardeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BardeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BardePayload>
          }
          aggregate: {
            args: Prisma.BardeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarde>
          }
          groupBy: {
            args: Prisma.BardeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BardeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BardeCountArgs<ExtArgs>
            result: $Utils.Optional<BardeCountAggregateOutputType> | number
          }
        }
      }
      Histoire: {
        payload: Prisma.$HistoirePayload<ExtArgs>
        fields: Prisma.HistoireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistoireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoirePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistoireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoirePayload>
          }
          findFirst: {
            args: Prisma.HistoireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoirePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistoireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoirePayload>
          }
          findMany: {
            args: Prisma.HistoireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoirePayload>[]
          }
          create: {
            args: Prisma.HistoireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoirePayload>
          }
          createMany: {
            args: Prisma.HistoireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HistoireCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoirePayload>[]
          }
          delete: {
            args: Prisma.HistoireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoirePayload>
          }
          update: {
            args: Prisma.HistoireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoirePayload>
          }
          deleteMany: {
            args: Prisma.HistoireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistoireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HistoireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoirePayload>
          }
          aggregate: {
            args: Prisma.HistoireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistoire>
          }
          groupBy: {
            args: Prisma.HistoireGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoireGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistoireCountArgs<ExtArgs>
            result: $Utils.Optional<HistoireCountAggregateOutputType> | number
          }
        }
      }
      Inventaire: {
        payload: Prisma.$InventairePayload<ExtArgs>
        fields: Prisma.InventaireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventaireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventaireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          findFirst: {
            args: Prisma.InventaireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventaireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          findMany: {
            args: Prisma.InventaireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>[]
          }
          create: {
            args: Prisma.InventaireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          createMany: {
            args: Prisma.InventaireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventaireCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>[]
          }
          delete: {
            args: Prisma.InventaireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          update: {
            args: Prisma.InventaireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          deleteMany: {
            args: Prisma.InventaireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventaireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventaireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          aggregate: {
            args: Prisma.InventaireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventaire>
          }
          groupBy: {
            args: Prisma.InventaireGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventaireGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventaireCountArgs<ExtArgs>
            result: $Utils.Optional<InventaireCountAggregateOutputType> | number
          }
        }
      }
      RelationDiplomatique: {
        payload: Prisma.$RelationDiplomatiquePayload<ExtArgs>
        fields: Prisma.RelationDiplomatiqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelationDiplomatiqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationDiplomatiquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelationDiplomatiqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationDiplomatiquePayload>
          }
          findFirst: {
            args: Prisma.RelationDiplomatiqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationDiplomatiquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelationDiplomatiqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationDiplomatiquePayload>
          }
          findMany: {
            args: Prisma.RelationDiplomatiqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationDiplomatiquePayload>[]
          }
          create: {
            args: Prisma.RelationDiplomatiqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationDiplomatiquePayload>
          }
          createMany: {
            args: Prisma.RelationDiplomatiqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelationDiplomatiqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationDiplomatiquePayload>[]
          }
          delete: {
            args: Prisma.RelationDiplomatiqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationDiplomatiquePayload>
          }
          update: {
            args: Prisma.RelationDiplomatiqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationDiplomatiquePayload>
          }
          deleteMany: {
            args: Prisma.RelationDiplomatiqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelationDiplomatiqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RelationDiplomatiqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationDiplomatiquePayload>
          }
          aggregate: {
            args: Prisma.RelationDiplomatiqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelationDiplomatique>
          }
          groupBy: {
            args: Prisma.RelationDiplomatiqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelationDiplomatiqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelationDiplomatiqueCountArgs<ExtArgs>
            result: $Utils.Optional<RelationDiplomatiqueCountAggregateOutputType> | number
          }
        }
      }
      Loi: {
        payload: Prisma.$LoiPayload<ExtArgs>
        fields: Prisma.LoiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiPayload>
          }
          findFirst: {
            args: Prisma.LoiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiPayload>
          }
          findMany: {
            args: Prisma.LoiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiPayload>[]
          }
          create: {
            args: Prisma.LoiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiPayload>
          }
          createMany: {
            args: Prisma.LoiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiPayload>[]
          }
          delete: {
            args: Prisma.LoiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiPayload>
          }
          update: {
            args: Prisma.LoiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiPayload>
          }
          deleteMany: {
            args: Prisma.LoiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiPayload>
          }
          aggregate: {
            args: Prisma.LoiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoi>
          }
          groupBy: {
            args: Prisma.LoiGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoiGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoiCountArgs<ExtArgs>
            result: $Utils.Optional<LoiCountAggregateOutputType> | number
          }
        }
      }
      LoiTerritoire: {
        payload: Prisma.$LoiTerritoirePayload<ExtArgs>
        fields: Prisma.LoiTerritoireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoiTerritoireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiTerritoirePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoiTerritoireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiTerritoirePayload>
          }
          findFirst: {
            args: Prisma.LoiTerritoireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiTerritoirePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoiTerritoireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiTerritoirePayload>
          }
          findMany: {
            args: Prisma.LoiTerritoireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiTerritoirePayload>[]
          }
          create: {
            args: Prisma.LoiTerritoireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiTerritoirePayload>
          }
          createMany: {
            args: Prisma.LoiTerritoireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoiTerritoireCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiTerritoirePayload>[]
          }
          delete: {
            args: Prisma.LoiTerritoireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiTerritoirePayload>
          }
          update: {
            args: Prisma.LoiTerritoireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiTerritoirePayload>
          }
          deleteMany: {
            args: Prisma.LoiTerritoireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoiTerritoireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoiTerritoireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoiTerritoirePayload>
          }
          aggregate: {
            args: Prisma.LoiTerritoireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoiTerritoire>
          }
          groupBy: {
            args: Prisma.LoiTerritoireGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoiTerritoireGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoiTerritoireCountArgs<ExtArgs>
            result: $Utils.Optional<LoiTerritoireCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RaceCountOutputType
   */

  export type RaceCountOutputType = {
    personnages: number
    competences: number
  }

  export type RaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnages?: boolean | RaceCountOutputTypeCountPersonnagesArgs
    competences?: boolean | RaceCountOutputTypeCountCompetencesArgs
  }

  // Custom InputTypes
  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceCountOutputType
     */
    select?: RaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountPersonnagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageWhereInput
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountCompetencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetenceWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    personnages: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnages?: boolean | RoleCountOutputTypeCountPersonnagesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPersonnagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageRoleWhereInput
  }


  /**
   * Count Type LigneeCountOutputType
   */

  export type LigneeCountOutputType = {
    personnages: number
    titres: number
  }

  export type LigneeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnages?: boolean | LigneeCountOutputTypeCountPersonnagesArgs
    titres?: boolean | LigneeCountOutputTypeCountTitresArgs
  }

  // Custom InputTypes
  /**
   * LigneeCountOutputType without action
   */
  export type LigneeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneeCountOutputType
     */
    select?: LigneeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LigneeCountOutputType without action
   */
  export type LigneeCountOutputTypeCountPersonnagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageWhereInput
  }

  /**
   * LigneeCountOutputType without action
   */
  export type LigneeCountOutputTypeCountTitresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageTitreWhereInput
  }


  /**
   * Count Type PersonnageCountOutputType
   */

  export type PersonnageCountOutputType = {
    roles: number
    competences: number
    titres: number
    maladies: number
    commandements: number
    equipements: number
    guildes: number
  }

  export type PersonnageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PersonnageCountOutputTypeCountRolesArgs
    competences?: boolean | PersonnageCountOutputTypeCountCompetencesArgs
    titres?: boolean | PersonnageCountOutputTypeCountTitresArgs
    maladies?: boolean | PersonnageCountOutputTypeCountMaladiesArgs
    commandements?: boolean | PersonnageCountOutputTypeCountCommandementsArgs
    equipements?: boolean | PersonnageCountOutputTypeCountEquipementsArgs
    guildes?: boolean | PersonnageCountOutputTypeCountGuildesArgs
  }

  // Custom InputTypes
  /**
   * PersonnageCountOutputType without action
   */
  export type PersonnageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCountOutputType
     */
    select?: PersonnageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonnageCountOutputType without action
   */
  export type PersonnageCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageRoleWhereInput
  }

  /**
   * PersonnageCountOutputType without action
   */
  export type PersonnageCountOutputTypeCountCompetencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageCompetenceWhereInput
  }

  /**
   * PersonnageCountOutputType without action
   */
  export type PersonnageCountOutputTypeCountTitresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageTitreWhereInput
  }

  /**
   * PersonnageCountOutputType without action
   */
  export type PersonnageCountOutputTypeCountMaladiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageMaladieWhereInput
  }

  /**
   * PersonnageCountOutputType without action
   */
  export type PersonnageCountOutputTypeCountCommandementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArmeeWhereInput
  }

  /**
   * PersonnageCountOutputType without action
   */
  export type PersonnageCountOutputTypeCountEquipementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageEquipementWhereInput
  }

  /**
   * PersonnageCountOutputType without action
   */
  export type PersonnageCountOutputTypeCountGuildesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildeMembreWhereInput
  }


  /**
   * Count Type CompetenceCountOutputType
   */

  export type CompetenceCountOutputType = {
    personnages: number
  }

  export type CompetenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnages?: boolean | CompetenceCountOutputTypeCountPersonnagesArgs
  }

  // Custom InputTypes
  /**
   * CompetenceCountOutputType without action
   */
  export type CompetenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetenceCountOutputType
     */
    select?: CompetenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompetenceCountOutputType without action
   */
  export type CompetenceCountOutputTypeCountPersonnagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageCompetenceWhereInput
  }


  /**
   * Count Type DomaineCountOutputType
   */

  export type DomaineCountOutputType = {
    villages: number
    titres: number
    armees: number
    relationsSource: number
    relationsCible: number
    lois: number
  }

  export type DomaineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    villages?: boolean | DomaineCountOutputTypeCountVillagesArgs
    titres?: boolean | DomaineCountOutputTypeCountTitresArgs
    armees?: boolean | DomaineCountOutputTypeCountArmeesArgs
    relationsSource?: boolean | DomaineCountOutputTypeCountRelationsSourceArgs
    relationsCible?: boolean | DomaineCountOutputTypeCountRelationsCibleArgs
    lois?: boolean | DomaineCountOutputTypeCountLoisArgs
  }

  // Custom InputTypes
  /**
   * DomaineCountOutputType without action
   */
  export type DomaineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomaineCountOutputType
     */
    select?: DomaineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomaineCountOutputType without action
   */
  export type DomaineCountOutputTypeCountVillagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VillageWhereInput
  }

  /**
   * DomaineCountOutputType without action
   */
  export type DomaineCountOutputTypeCountTitresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageTitreWhereInput
  }

  /**
   * DomaineCountOutputType without action
   */
  export type DomaineCountOutputTypeCountArmeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArmeeWhereInput
  }

  /**
   * DomaineCountOutputType without action
   */
  export type DomaineCountOutputTypeCountRelationsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationDiplomatiqueWhereInput
  }

  /**
   * DomaineCountOutputType without action
   */
  export type DomaineCountOutputTypeCountRelationsCibleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationDiplomatiqueWhereInput
  }

  /**
   * DomaineCountOutputType without action
   */
  export type DomaineCountOutputTypeCountLoisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoiTerritoireWhereInput
  }


  /**
   * Count Type TitreCountOutputType
   */

  export type TitreCountOutputType = {
    attributions: number
  }

  export type TitreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributions?: boolean | TitreCountOutputTypeCountAttributionsArgs
  }

  // Custom InputTypes
  /**
   * TitreCountOutputType without action
   */
  export type TitreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitreCountOutputType
     */
    select?: TitreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TitreCountOutputType without action
   */
  export type TitreCountOutputTypeCountAttributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageTitreWhereInput
  }


  /**
   * Count Type VillageCountOutputType
   */

  export type VillageCountOutputType = {
    inventaires: number
  }

  export type VillageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventaires?: boolean | VillageCountOutputTypeCountInventairesArgs
  }

  // Custom InputTypes
  /**
   * VillageCountOutputType without action
   */
  export type VillageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VillageCountOutputType
     */
    select?: VillageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VillageCountOutputType without action
   */
  export type VillageCountOutputTypeCountInventairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventaireWhereInput
  }


  /**
   * Count Type GuildeCountOutputType
   */

  export type GuildeCountOutputType = {
    membres: number
    batailles: number
  }

  export type GuildeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membres?: boolean | GuildeCountOutputTypeCountMembresArgs
    batailles?: boolean | GuildeCountOutputTypeCountBataillesArgs
  }

  // Custom InputTypes
  /**
   * GuildeCountOutputType without action
   */
  export type GuildeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeCountOutputType
     */
    select?: GuildeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuildeCountOutputType without action
   */
  export type GuildeCountOutputTypeCountMembresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildeMembreWhereInput
  }

  /**
   * GuildeCountOutputType without action
   */
  export type GuildeCountOutputTypeCountBataillesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildeBatailleWhereInput
  }


  /**
   * Count Type CreatureCountOutputType
   */

  export type CreatureCountOutputType = {
    batailles: number
  }

  export type CreatureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batailles?: boolean | CreatureCountOutputTypeCountBataillesArgs
  }

  // Custom InputTypes
  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureCountOutputType
     */
    select?: CreatureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountBataillesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureBatailleWhereInput
  }


  /**
   * Count Type EcoleMagieCountOutputType
   */

  export type EcoleMagieCountOutputType = {
    sorts: number
  }

  export type EcoleMagieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sorts?: boolean | EcoleMagieCountOutputTypeCountSortsArgs
  }

  // Custom InputTypes
  /**
   * EcoleMagieCountOutputType without action
   */
  export type EcoleMagieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagieCountOutputType
     */
    select?: EcoleMagieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EcoleMagieCountOutputType without action
   */
  export type EcoleMagieCountOutputTypeCountSortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SortWhereInput
  }


  /**
   * Count Type MaladieCountOutputType
   */

  export type MaladieCountOutputType = {
    cas: number
  }

  export type MaladieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cas?: boolean | MaladieCountOutputTypeCountCasArgs
  }

  // Custom InputTypes
  /**
   * MaladieCountOutputType without action
   */
  export type MaladieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaladieCountOutputType
     */
    select?: MaladieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaladieCountOutputType without action
   */
  export type MaladieCountOutputTypeCountCasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageMaladieWhereInput
  }


  /**
   * Count Type ArmeeCountOutputType
   */

  export type ArmeeCountOutputType = {
    batailles: number
    inventaires: number
  }

  export type ArmeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batailles?: boolean | ArmeeCountOutputTypeCountBataillesArgs
    inventaires?: boolean | ArmeeCountOutputTypeCountInventairesArgs
  }

  // Custom InputTypes
  /**
   * ArmeeCountOutputType without action
   */
  export type ArmeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeCountOutputType
     */
    select?: ArmeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArmeeCountOutputType without action
   */
  export type ArmeeCountOutputTypeCountBataillesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArmeeBatailleWhereInput
  }

  /**
   * ArmeeCountOutputType without action
   */
  export type ArmeeCountOutputTypeCountInventairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventaireWhereInput
  }


  /**
   * Count Type BatailleCountOutputType
   */

  export type BatailleCountOutputType = {
    armees: number
    guildes: number
    creatures: number
  }

  export type BatailleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    armees?: boolean | BatailleCountOutputTypeCountArmeesArgs
    guildes?: boolean | BatailleCountOutputTypeCountGuildesArgs
    creatures?: boolean | BatailleCountOutputTypeCountCreaturesArgs
  }

  // Custom InputTypes
  /**
   * BatailleCountOutputType without action
   */
  export type BatailleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatailleCountOutputType
     */
    select?: BatailleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BatailleCountOutputType without action
   */
  export type BatailleCountOutputTypeCountArmeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArmeeBatailleWhereInput
  }

  /**
   * BatailleCountOutputType without action
   */
  export type BatailleCountOutputTypeCountGuildesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildeBatailleWhereInput
  }

  /**
   * BatailleCountOutputType without action
   */
  export type BatailleCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureBatailleWhereInput
  }


  /**
   * Count Type EquipementCountOutputType
   */

  export type EquipementCountOutputType = {
    possesseurs: number
  }

  export type EquipementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    possesseurs?: boolean | EquipementCountOutputTypeCountPossesseursArgs
  }

  // Custom InputTypes
  /**
   * EquipementCountOutputType without action
   */
  export type EquipementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipementCountOutputType
     */
    select?: EquipementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipementCountOutputType without action
   */
  export type EquipementCountOutputTypeCountPossesseursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageEquipementWhereInput
  }


  /**
   * Count Type MarchandCountOutputType
   */

  export type MarchandCountOutputType = {
    routes: number
  }

  export type MarchandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routes?: boolean | MarchandCountOutputTypeCountRoutesArgs
  }

  // Custom InputTypes
  /**
   * MarchandCountOutputType without action
   */
  export type MarchandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandCountOutputType
     */
    select?: MarchandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarchandCountOutputType without action
   */
  export type MarchandCountOutputTypeCountRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarchandRouteWhereInput
  }


  /**
   * Count Type RouteCommercialeCountOutputType
   */

  export type RouteCommercialeCountOutputType = {
    segments: number
    marchands: number
  }

  export type RouteCommercialeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segments?: boolean | RouteCommercialeCountOutputTypeCountSegmentsArgs
    marchands?: boolean | RouteCommercialeCountOutputTypeCountMarchandsArgs
  }

  // Custom InputTypes
  /**
   * RouteCommercialeCountOutputType without action
   */
  export type RouteCommercialeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommercialeCountOutputType
     */
    select?: RouteCommercialeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RouteCommercialeCountOutputType without action
   */
  export type RouteCommercialeCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteSegmentWhereInput
  }

  /**
   * RouteCommercialeCountOutputType without action
   */
  export type RouteCommercialeCountOutputTypeCountMarchandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarchandRouteWhereInput
  }


  /**
   * Count Type LieuCountOutputType
   */

  export type LieuCountOutputType = {
    segments: number
    inventaires: number
  }

  export type LieuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segments?: boolean | LieuCountOutputTypeCountSegmentsArgs
    inventaires?: boolean | LieuCountOutputTypeCountInventairesArgs
  }

  // Custom InputTypes
  /**
   * LieuCountOutputType without action
   */
  export type LieuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LieuCountOutputType
     */
    select?: LieuCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LieuCountOutputType without action
   */
  export type LieuCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteSegmentWhereInput
  }

  /**
   * LieuCountOutputType without action
   */
  export type LieuCountOutputTypeCountInventairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventaireWhereInput
  }


  /**
   * Count Type BardeCountOutputType
   */

  export type BardeCountOutputType = {
    histoires: number
  }

  export type BardeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histoires?: boolean | BardeCountOutputTypeCountHistoiresArgs
  }

  // Custom InputTypes
  /**
   * BardeCountOutputType without action
   */
  export type BardeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BardeCountOutputType
     */
    select?: BardeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BardeCountOutputType without action
   */
  export type BardeCountOutputTypeCountHistoiresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoireWhereInput
  }


  /**
   * Count Type LoiCountOutputType
   */

  export type LoiCountOutputType = {
    domaines: number
  }

  export type LoiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domaines?: boolean | LoiCountOutputTypeCountDomainesArgs
  }

  // Custom InputTypes
  /**
   * LoiCountOutputType without action
   */
  export type LoiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiCountOutputType
     */
    select?: LoiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoiCountOutputType without action
   */
  export type LoiCountOutputTypeCountDomainesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoiTerritoireWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Race
   */

  export type AggregateRace = {
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  export type RaceAvgAggregateOutputType = {
    id: number | null
  }

  export type RaceSumAggregateOutputType = {
    id: number | null
  }

  export type RaceMinAggregateOutputType = {
    id: number | null
    libelle: string | null
  }

  export type RaceMaxAggregateOutputType = {
    id: number | null
    libelle: string | null
  }

  export type RaceCountAggregateOutputType = {
    id: number
    libelle: number
    _all: number
  }


  export type RaceAvgAggregateInputType = {
    id?: true
  }

  export type RaceSumAggregateInputType = {
    id?: true
  }

  export type RaceMinAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type RaceMaxAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type RaceCountAggregateInputType = {
    id?: true
    libelle?: true
    _all?: true
  }

  export type RaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Race to aggregate.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Races
    **/
    _count?: true | RaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceMaxAggregateInputType
  }

  export type GetRaceAggregateType<T extends RaceAggregateArgs> = {
        [P in keyof T & keyof AggregateRace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRace[P]>
      : GetScalarType<T[P], AggregateRace[P]>
  }




  export type RaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithAggregationInput | RaceOrderByWithAggregationInput[]
    by: RaceScalarFieldEnum[] | RaceScalarFieldEnum
    having?: RaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceCountAggregateInputType | true
    _avg?: RaceAvgAggregateInputType
    _sum?: RaceSumAggregateInputType
    _min?: RaceMinAggregateInputType
    _max?: RaceMaxAggregateInputType
  }

  export type RaceGroupByOutputType = {
    id: number
    libelle: string
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  type GetRaceGroupByPayload<T extends RaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceGroupByOutputType[P]>
            : GetScalarType<T[P], RaceGroupByOutputType[P]>
        }
      >
    >


  export type RaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    personnages?: boolean | Race$personnagesArgs<ExtArgs>
    competences?: boolean | Race$competencesArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
  }, ExtArgs["result"]["race"]>

  export type RaceSelectScalar = {
    id?: boolean
    libelle?: boolean
  }

  export type RaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnages?: boolean | Race$personnagesArgs<ExtArgs>
    competences?: boolean | Race$competencesArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Race"
    objects: {
      personnages: Prisma.$PersonnagePayload<ExtArgs>[]
      competences: Prisma.$CompetencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      libelle: string
    }, ExtArgs["result"]["race"]>
    composites: {}
  }

  type RaceGetPayload<S extends boolean | null | undefined | RaceDefaultArgs> = $Result.GetResult<Prisma.$RacePayload, S>

  type RaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RaceCountAggregateInputType | true
    }

  export interface RaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Race'], meta: { name: 'Race' } }
    /**
     * Find zero or one Race that matches the filter.
     * @param {RaceFindUniqueArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceFindUniqueArgs>(args: SelectSubset<T, RaceFindUniqueArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Race that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RaceFindUniqueOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Race that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceFindFirstArgs>(args?: SelectSubset<T, RaceFindFirstArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Race that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Races that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Races
     * const races = await prisma.race.findMany()
     * 
     * // Get first 10 Races
     * const races = await prisma.race.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raceWithIdOnly = await prisma.race.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaceFindManyArgs>(args?: SelectSubset<T, RaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Race.
     * @param {RaceCreateArgs} args - Arguments to create a Race.
     * @example
     * // Create one Race
     * const Race = await prisma.race.create({
     *   data: {
     *     // ... data to create a Race
     *   }
     * })
     * 
     */
    create<T extends RaceCreateArgs>(args: SelectSubset<T, RaceCreateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Races.
     * @param {RaceCreateManyArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceCreateManyArgs>(args?: SelectSubset<T, RaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Races and returns the data saved in the database.
     * @param {RaceCreateManyAndReturnArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Races and only return the `id`
     * const raceWithIdOnly = await prisma.race.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Race.
     * @param {RaceDeleteArgs} args - Arguments to delete one Race.
     * @example
     * // Delete one Race
     * const Race = await prisma.race.delete({
     *   where: {
     *     // ... filter to delete one Race
     *   }
     * })
     * 
     */
    delete<T extends RaceDeleteArgs>(args: SelectSubset<T, RaceDeleteArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Race.
     * @param {RaceUpdateArgs} args - Arguments to update one Race.
     * @example
     * // Update one Race
     * const race = await prisma.race.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceUpdateArgs>(args: SelectSubset<T, RaceUpdateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Races.
     * @param {RaceDeleteManyArgs} args - Arguments to filter Races to delete.
     * @example
     * // Delete a few Races
     * const { count } = await prisma.race.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceDeleteManyArgs>(args?: SelectSubset<T, RaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceUpdateManyArgs>(args: SelectSubset<T, RaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Race.
     * @param {RaceUpsertArgs} args - Arguments to update or create a Race.
     * @example
     * // Update or create a Race
     * const race = await prisma.race.upsert({
     *   create: {
     *     // ... data to create a Race
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Race we want to update
     *   }
     * })
     */
    upsert<T extends RaceUpsertArgs>(args: SelectSubset<T, RaceUpsertArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceCountArgs} args - Arguments to filter Races to count.
     * @example
     * // Count the number of Races
     * const count = await prisma.race.count({
     *   where: {
     *     // ... the filter for the Races we want to count
     *   }
     * })
    **/
    count<T extends RaceCountArgs>(
      args?: Subset<T, RaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceAggregateArgs>(args: Subset<T, RaceAggregateArgs>): Prisma.PrismaPromise<GetRaceAggregateType<T>>

    /**
     * Group by Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceGroupByArgs['orderBy'] }
        : { orderBy?: RaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Race model
   */
  readonly fields: RaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Race.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnages<T extends Race$personnagesArgs<ExtArgs> = {}>(args?: Subset<T, Race$personnagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findMany"> | Null>
    competences<T extends Race$competencesArgs<ExtArgs> = {}>(args?: Subset<T, Race$competencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Race model
   */ 
  interface RaceFieldRefs {
    readonly id: FieldRef<"Race", 'Int'>
    readonly libelle: FieldRef<"Race", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Race findUnique
   */
  export type RaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findUniqueOrThrow
   */
  export type RaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findFirst
   */
  export type RaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findFirstOrThrow
   */
  export type RaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findMany
   */
  export type RaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Races to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race create
   */
  export type RaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Race.
     */
    data: XOR<RaceCreateInput, RaceUncheckedCreateInput>
  }

  /**
   * Race createMany
   */
  export type RaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Race createManyAndReturn
   */
  export type RaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Race update
   */
  export type RaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Race.
     */
    data: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
    /**
     * Choose, which Race to update.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race updateMany
   */
  export type RaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
  }

  /**
   * Race upsert
   */
  export type RaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Race to update in case it exists.
     */
    where: RaceWhereUniqueInput
    /**
     * In case the Race found by the `where` argument doesn't exist, create a new Race with this data.
     */
    create: XOR<RaceCreateInput, RaceUncheckedCreateInput>
    /**
     * In case the Race was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
  }

  /**
   * Race delete
   */
  export type RaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter which Race to delete.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race deleteMany
   */
  export type RaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Races to delete
     */
    where?: RaceWhereInput
  }

  /**
   * Race.personnages
   */
  export type Race$personnagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    where?: PersonnageWhereInput
    orderBy?: PersonnageOrderByWithRelationInput | PersonnageOrderByWithRelationInput[]
    cursor?: PersonnageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageScalarFieldEnum | PersonnageScalarFieldEnum[]
  }

  /**
   * Race.competences
   */
  export type Race$competencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    where?: CompetenceWhereInput
    orderBy?: CompetenceOrderByWithRelationInput | CompetenceOrderByWithRelationInput[]
    cursor?: CompetenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompetenceScalarFieldEnum | CompetenceScalarFieldEnum[]
  }

  /**
   * Race without action
   */
  export type RaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    libelle: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    libelle: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    libelle: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    libelle?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    libelle: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    personnages?: boolean | Role$personnagesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    libelle?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnages?: boolean | Role$personnagesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      personnages: Prisma.$PersonnageRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      libelle: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnages<T extends Role$personnagesArgs<ExtArgs> = {}>(args?: Subset<T, Role$personnagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly libelle: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.personnages
   */
  export type Role$personnagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    where?: PersonnageRoleWhereInput
    orderBy?: PersonnageRoleOrderByWithRelationInput | PersonnageRoleOrderByWithRelationInput[]
    cursor?: PersonnageRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageRoleScalarFieldEnum | PersonnageRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Lignee
   */

  export type AggregateLignee = {
    _count: LigneeCountAggregateOutputType | null
    _avg: LigneeAvgAggregateOutputType | null
    _sum: LigneeSumAggregateOutputType | null
    _min: LigneeMinAggregateOutputType | null
    _max: LigneeMaxAggregateOutputType | null
  }

  export type LigneeAvgAggregateOutputType = {
    id: number | null
  }

  export type LigneeSumAggregateOutputType = {
    id: number | null
  }

  export type LigneeMinAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type LigneeMaxAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type LigneeCountAggregateOutputType = {
    id: number
    nom: number
    _all: number
  }


  export type LigneeAvgAggregateInputType = {
    id?: true
  }

  export type LigneeSumAggregateInputType = {
    id?: true
  }

  export type LigneeMinAggregateInputType = {
    id?: true
    nom?: true
  }

  export type LigneeMaxAggregateInputType = {
    id?: true
    nom?: true
  }

  export type LigneeCountAggregateInputType = {
    id?: true
    nom?: true
    _all?: true
  }

  export type LigneeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lignee to aggregate.
     */
    where?: LigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lignees to fetch.
     */
    orderBy?: LigneeOrderByWithRelationInput | LigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lignees
    **/
    _count?: true | LigneeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneeMaxAggregateInputType
  }

  export type GetLigneeAggregateType<T extends LigneeAggregateArgs> = {
        [P in keyof T & keyof AggregateLignee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLignee[P]>
      : GetScalarType<T[P], AggregateLignee[P]>
  }




  export type LigneeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneeWhereInput
    orderBy?: LigneeOrderByWithAggregationInput | LigneeOrderByWithAggregationInput[]
    by: LigneeScalarFieldEnum[] | LigneeScalarFieldEnum
    having?: LigneeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneeCountAggregateInputType | true
    _avg?: LigneeAvgAggregateInputType
    _sum?: LigneeSumAggregateInputType
    _min?: LigneeMinAggregateInputType
    _max?: LigneeMaxAggregateInputType
  }

  export type LigneeGroupByOutputType = {
    id: number
    nom: string
    _count: LigneeCountAggregateOutputType | null
    _avg: LigneeAvgAggregateOutputType | null
    _sum: LigneeSumAggregateOutputType | null
    _min: LigneeMinAggregateOutputType | null
    _max: LigneeMaxAggregateOutputType | null
  }

  type GetLigneeGroupByPayload<T extends LigneeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneeGroupByOutputType[P]>
            : GetScalarType<T[P], LigneeGroupByOutputType[P]>
        }
      >
    >


  export type LigneeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    personnages?: boolean | Lignee$personnagesArgs<ExtArgs>
    titres?: boolean | Lignee$titresArgs<ExtArgs>
    _count?: boolean | LigneeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lignee"]>

  export type LigneeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
  }, ExtArgs["result"]["lignee"]>

  export type LigneeSelectScalar = {
    id?: boolean
    nom?: boolean
  }

  export type LigneeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnages?: boolean | Lignee$personnagesArgs<ExtArgs>
    titres?: boolean | Lignee$titresArgs<ExtArgs>
    _count?: boolean | LigneeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LigneeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LigneePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lignee"
    objects: {
      personnages: Prisma.$PersonnagePayload<ExtArgs>[]
      titres: Prisma.$PersonnageTitrePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
    }, ExtArgs["result"]["lignee"]>
    composites: {}
  }

  type LigneeGetPayload<S extends boolean | null | undefined | LigneeDefaultArgs> = $Result.GetResult<Prisma.$LigneePayload, S>

  type LigneeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LigneeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LigneeCountAggregateInputType | true
    }

  export interface LigneeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lignee'], meta: { name: 'Lignee' } }
    /**
     * Find zero or one Lignee that matches the filter.
     * @param {LigneeFindUniqueArgs} args - Arguments to find a Lignee
     * @example
     * // Get one Lignee
     * const lignee = await prisma.lignee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneeFindUniqueArgs>(args: SelectSubset<T, LigneeFindUniqueArgs<ExtArgs>>): Prisma__LigneeClient<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lignee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LigneeFindUniqueOrThrowArgs} args - Arguments to find a Lignee
     * @example
     * // Get one Lignee
     * const lignee = await prisma.lignee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneeFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneeClient<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lignee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneeFindFirstArgs} args - Arguments to find a Lignee
     * @example
     * // Get one Lignee
     * const lignee = await prisma.lignee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneeFindFirstArgs>(args?: SelectSubset<T, LigneeFindFirstArgs<ExtArgs>>): Prisma__LigneeClient<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lignee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneeFindFirstOrThrowArgs} args - Arguments to find a Lignee
     * @example
     * // Get one Lignee
     * const lignee = await prisma.lignee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneeFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneeClient<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lignees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lignees
     * const lignees = await prisma.lignee.findMany()
     * 
     * // Get first 10 Lignees
     * const lignees = await prisma.lignee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneeWithIdOnly = await prisma.lignee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneeFindManyArgs>(args?: SelectSubset<T, LigneeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lignee.
     * @param {LigneeCreateArgs} args - Arguments to create a Lignee.
     * @example
     * // Create one Lignee
     * const Lignee = await prisma.lignee.create({
     *   data: {
     *     // ... data to create a Lignee
     *   }
     * })
     * 
     */
    create<T extends LigneeCreateArgs>(args: SelectSubset<T, LigneeCreateArgs<ExtArgs>>): Prisma__LigneeClient<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lignees.
     * @param {LigneeCreateManyArgs} args - Arguments to create many Lignees.
     * @example
     * // Create many Lignees
     * const lignee = await prisma.lignee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneeCreateManyArgs>(args?: SelectSubset<T, LigneeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lignees and returns the data saved in the database.
     * @param {LigneeCreateManyAndReturnArgs} args - Arguments to create many Lignees.
     * @example
     * // Create many Lignees
     * const lignee = await prisma.lignee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lignees and only return the `id`
     * const ligneeWithIdOnly = await prisma.lignee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LigneeCreateManyAndReturnArgs>(args?: SelectSubset<T, LigneeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lignee.
     * @param {LigneeDeleteArgs} args - Arguments to delete one Lignee.
     * @example
     * // Delete one Lignee
     * const Lignee = await prisma.lignee.delete({
     *   where: {
     *     // ... filter to delete one Lignee
     *   }
     * })
     * 
     */
    delete<T extends LigneeDeleteArgs>(args: SelectSubset<T, LigneeDeleteArgs<ExtArgs>>): Prisma__LigneeClient<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lignee.
     * @param {LigneeUpdateArgs} args - Arguments to update one Lignee.
     * @example
     * // Update one Lignee
     * const lignee = await prisma.lignee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneeUpdateArgs>(args: SelectSubset<T, LigneeUpdateArgs<ExtArgs>>): Prisma__LigneeClient<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lignees.
     * @param {LigneeDeleteManyArgs} args - Arguments to filter Lignees to delete.
     * @example
     * // Delete a few Lignees
     * const { count } = await prisma.lignee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneeDeleteManyArgs>(args?: SelectSubset<T, LigneeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lignees
     * const lignee = await prisma.lignee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneeUpdateManyArgs>(args: SelectSubset<T, LigneeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lignee.
     * @param {LigneeUpsertArgs} args - Arguments to update or create a Lignee.
     * @example
     * // Update or create a Lignee
     * const lignee = await prisma.lignee.upsert({
     *   create: {
     *     // ... data to create a Lignee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lignee we want to update
     *   }
     * })
     */
    upsert<T extends LigneeUpsertArgs>(args: SelectSubset<T, LigneeUpsertArgs<ExtArgs>>): Prisma__LigneeClient<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneeCountArgs} args - Arguments to filter Lignees to count.
     * @example
     * // Count the number of Lignees
     * const count = await prisma.lignee.count({
     *   where: {
     *     // ... the filter for the Lignees we want to count
     *   }
     * })
    **/
    count<T extends LigneeCountArgs>(
      args?: Subset<T, LigneeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneeAggregateArgs>(args: Subset<T, LigneeAggregateArgs>): Prisma.PrismaPromise<GetLigneeAggregateType<T>>

    /**
     * Group by Lignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneeGroupByArgs['orderBy'] }
        : { orderBy?: LigneeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lignee model
   */
  readonly fields: LigneeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lignee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnages<T extends Lignee$personnagesArgs<ExtArgs> = {}>(args?: Subset<T, Lignee$personnagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findMany"> | Null>
    titres<T extends Lignee$titresArgs<ExtArgs> = {}>(args?: Subset<T, Lignee$titresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lignee model
   */ 
  interface LigneeFieldRefs {
    readonly id: FieldRef<"Lignee", 'Int'>
    readonly nom: FieldRef<"Lignee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lignee findUnique
   */
  export type LigneeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    /**
     * Filter, which Lignee to fetch.
     */
    where: LigneeWhereUniqueInput
  }

  /**
   * Lignee findUniqueOrThrow
   */
  export type LigneeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    /**
     * Filter, which Lignee to fetch.
     */
    where: LigneeWhereUniqueInput
  }

  /**
   * Lignee findFirst
   */
  export type LigneeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    /**
     * Filter, which Lignee to fetch.
     */
    where?: LigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lignees to fetch.
     */
    orderBy?: LigneeOrderByWithRelationInput | LigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lignees.
     */
    cursor?: LigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lignees.
     */
    distinct?: LigneeScalarFieldEnum | LigneeScalarFieldEnum[]
  }

  /**
   * Lignee findFirstOrThrow
   */
  export type LigneeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    /**
     * Filter, which Lignee to fetch.
     */
    where?: LigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lignees to fetch.
     */
    orderBy?: LigneeOrderByWithRelationInput | LigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lignees.
     */
    cursor?: LigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lignees.
     */
    distinct?: LigneeScalarFieldEnum | LigneeScalarFieldEnum[]
  }

  /**
   * Lignee findMany
   */
  export type LigneeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    /**
     * Filter, which Lignees to fetch.
     */
    where?: LigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lignees to fetch.
     */
    orderBy?: LigneeOrderByWithRelationInput | LigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lignees.
     */
    cursor?: LigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lignees.
     */
    skip?: number
    distinct?: LigneeScalarFieldEnum | LigneeScalarFieldEnum[]
  }

  /**
   * Lignee create
   */
  export type LigneeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    /**
     * The data needed to create a Lignee.
     */
    data: XOR<LigneeCreateInput, LigneeUncheckedCreateInput>
  }

  /**
   * Lignee createMany
   */
  export type LigneeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lignees.
     */
    data: LigneeCreateManyInput | LigneeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lignee createManyAndReturn
   */
  export type LigneeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lignees.
     */
    data: LigneeCreateManyInput | LigneeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lignee update
   */
  export type LigneeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    /**
     * The data needed to update a Lignee.
     */
    data: XOR<LigneeUpdateInput, LigneeUncheckedUpdateInput>
    /**
     * Choose, which Lignee to update.
     */
    where: LigneeWhereUniqueInput
  }

  /**
   * Lignee updateMany
   */
  export type LigneeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lignees.
     */
    data: XOR<LigneeUpdateManyMutationInput, LigneeUncheckedUpdateManyInput>
    /**
     * Filter which Lignees to update
     */
    where?: LigneeWhereInput
  }

  /**
   * Lignee upsert
   */
  export type LigneeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    /**
     * The filter to search for the Lignee to update in case it exists.
     */
    where: LigneeWhereUniqueInput
    /**
     * In case the Lignee found by the `where` argument doesn't exist, create a new Lignee with this data.
     */
    create: XOR<LigneeCreateInput, LigneeUncheckedCreateInput>
    /**
     * In case the Lignee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneeUpdateInput, LigneeUncheckedUpdateInput>
  }

  /**
   * Lignee delete
   */
  export type LigneeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    /**
     * Filter which Lignee to delete.
     */
    where: LigneeWhereUniqueInput
  }

  /**
   * Lignee deleteMany
   */
  export type LigneeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lignees to delete
     */
    where?: LigneeWhereInput
  }

  /**
   * Lignee.personnages
   */
  export type Lignee$personnagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    where?: PersonnageWhereInput
    orderBy?: PersonnageOrderByWithRelationInput | PersonnageOrderByWithRelationInput[]
    cursor?: PersonnageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageScalarFieldEnum | PersonnageScalarFieldEnum[]
  }

  /**
   * Lignee.titres
   */
  export type Lignee$titresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    where?: PersonnageTitreWhereInput
    orderBy?: PersonnageTitreOrderByWithRelationInput | PersonnageTitreOrderByWithRelationInput[]
    cursor?: PersonnageTitreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageTitreScalarFieldEnum | PersonnageTitreScalarFieldEnum[]
  }

  /**
   * Lignee without action
   */
  export type LigneeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
  }


  /**
   * Model Personnage
   */

  export type AggregatePersonnage = {
    _count: PersonnageCountAggregateOutputType | null
    _avg: PersonnageAvgAggregateOutputType | null
    _sum: PersonnageSumAggregateOutputType | null
    _min: PersonnageMinAggregateOutputType | null
    _max: PersonnageMaxAggregateOutputType | null
  }

  export type PersonnageAvgAggregateOutputType = {
    id: number | null
    raceId: number | null
    ligneeId: number | null
  }

  export type PersonnageSumAggregateOutputType = {
    id: number | null
    raceId: number | null
    ligneeId: number | null
  }

  export type PersonnageMinAggregateOutputType = {
    id: number | null
    nom: string | null
    dateNaissance: Date | null
    statutVie: string | null
    dateDeces: Date | null
    causeDeces: string | null
    raceId: number | null
    ligneeId: number | null
  }

  export type PersonnageMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    dateNaissance: Date | null
    statutVie: string | null
    dateDeces: Date | null
    causeDeces: string | null
    raceId: number | null
    ligneeId: number | null
  }

  export type PersonnageCountAggregateOutputType = {
    id: number
    nom: number
    dateNaissance: number
    statutVie: number
    dateDeces: number
    causeDeces: number
    raceId: number
    ligneeId: number
    _all: number
  }


  export type PersonnageAvgAggregateInputType = {
    id?: true
    raceId?: true
    ligneeId?: true
  }

  export type PersonnageSumAggregateInputType = {
    id?: true
    raceId?: true
    ligneeId?: true
  }

  export type PersonnageMinAggregateInputType = {
    id?: true
    nom?: true
    dateNaissance?: true
    statutVie?: true
    dateDeces?: true
    causeDeces?: true
    raceId?: true
    ligneeId?: true
  }

  export type PersonnageMaxAggregateInputType = {
    id?: true
    nom?: true
    dateNaissance?: true
    statutVie?: true
    dateDeces?: true
    causeDeces?: true
    raceId?: true
    ligneeId?: true
  }

  export type PersonnageCountAggregateInputType = {
    id?: true
    nom?: true
    dateNaissance?: true
    statutVie?: true
    dateDeces?: true
    causeDeces?: true
    raceId?: true
    ligneeId?: true
    _all?: true
  }

  export type PersonnageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personnage to aggregate.
     */
    where?: PersonnageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnages to fetch.
     */
    orderBy?: PersonnageOrderByWithRelationInput | PersonnageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personnages
    **/
    _count?: true | PersonnageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonnageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonnageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnageMaxAggregateInputType
  }

  export type GetPersonnageAggregateType<T extends PersonnageAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnage[P]>
      : GetScalarType<T[P], AggregatePersonnage[P]>
  }




  export type PersonnageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageWhereInput
    orderBy?: PersonnageOrderByWithAggregationInput | PersonnageOrderByWithAggregationInput[]
    by: PersonnageScalarFieldEnum[] | PersonnageScalarFieldEnum
    having?: PersonnageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnageCountAggregateInputType | true
    _avg?: PersonnageAvgAggregateInputType
    _sum?: PersonnageSumAggregateInputType
    _min?: PersonnageMinAggregateInputType
    _max?: PersonnageMaxAggregateInputType
  }

  export type PersonnageGroupByOutputType = {
    id: number
    nom: string
    dateNaissance: Date | null
    statutVie: string | null
    dateDeces: Date | null
    causeDeces: string | null
    raceId: number | null
    ligneeId: number | null
    _count: PersonnageCountAggregateOutputType | null
    _avg: PersonnageAvgAggregateOutputType | null
    _sum: PersonnageSumAggregateOutputType | null
    _min: PersonnageMinAggregateOutputType | null
    _max: PersonnageMaxAggregateOutputType | null
  }

  type GetPersonnageGroupByPayload<T extends PersonnageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnageGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnageGroupByOutputType[P]>
        }
      >
    >


  export type PersonnageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    dateNaissance?: boolean
    statutVie?: boolean
    dateDeces?: boolean
    causeDeces?: boolean
    raceId?: boolean
    ligneeId?: boolean
    race?: boolean | Personnage$raceArgs<ExtArgs>
    lignee?: boolean | Personnage$ligneeArgs<ExtArgs>
    roles?: boolean | Personnage$rolesArgs<ExtArgs>
    competences?: boolean | Personnage$competencesArgs<ExtArgs>
    titres?: boolean | Personnage$titresArgs<ExtArgs>
    maladies?: boolean | Personnage$maladiesArgs<ExtArgs>
    commandements?: boolean | Personnage$commandementsArgs<ExtArgs>
    equipements?: boolean | Personnage$equipementsArgs<ExtArgs>
    guildes?: boolean | Personnage$guildesArgs<ExtArgs>
    _count?: boolean | PersonnageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnage"]>

  export type PersonnageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    dateNaissance?: boolean
    statutVie?: boolean
    dateDeces?: boolean
    causeDeces?: boolean
    raceId?: boolean
    ligneeId?: boolean
    race?: boolean | Personnage$raceArgs<ExtArgs>
    lignee?: boolean | Personnage$ligneeArgs<ExtArgs>
  }, ExtArgs["result"]["personnage"]>

  export type PersonnageSelectScalar = {
    id?: boolean
    nom?: boolean
    dateNaissance?: boolean
    statutVie?: boolean
    dateDeces?: boolean
    causeDeces?: boolean
    raceId?: boolean
    ligneeId?: boolean
  }

  export type PersonnageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | Personnage$raceArgs<ExtArgs>
    lignee?: boolean | Personnage$ligneeArgs<ExtArgs>
    roles?: boolean | Personnage$rolesArgs<ExtArgs>
    competences?: boolean | Personnage$competencesArgs<ExtArgs>
    titres?: boolean | Personnage$titresArgs<ExtArgs>
    maladies?: boolean | Personnage$maladiesArgs<ExtArgs>
    commandements?: boolean | Personnage$commandementsArgs<ExtArgs>
    equipements?: boolean | Personnage$equipementsArgs<ExtArgs>
    guildes?: boolean | Personnage$guildesArgs<ExtArgs>
    _count?: boolean | PersonnageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonnageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | Personnage$raceArgs<ExtArgs>
    lignee?: boolean | Personnage$ligneeArgs<ExtArgs>
  }

  export type $PersonnagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Personnage"
    objects: {
      race: Prisma.$RacePayload<ExtArgs> | null
      lignee: Prisma.$LigneePayload<ExtArgs> | null
      roles: Prisma.$PersonnageRolePayload<ExtArgs>[]
      competences: Prisma.$PersonnageCompetencePayload<ExtArgs>[]
      titres: Prisma.$PersonnageTitrePayload<ExtArgs>[]
      maladies: Prisma.$PersonnageMaladiePayload<ExtArgs>[]
      commandements: Prisma.$ArmeePayload<ExtArgs>[]
      equipements: Prisma.$PersonnageEquipementPayload<ExtArgs>[]
      guildes: Prisma.$GuildeMembrePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      dateNaissance: Date | null
      statutVie: string | null
      dateDeces: Date | null
      causeDeces: string | null
      raceId: number | null
      ligneeId: number | null
    }, ExtArgs["result"]["personnage"]>
    composites: {}
  }

  type PersonnageGetPayload<S extends boolean | null | undefined | PersonnageDefaultArgs> = $Result.GetResult<Prisma.$PersonnagePayload, S>

  type PersonnageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonnageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonnageCountAggregateInputType | true
    }

  export interface PersonnageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Personnage'], meta: { name: 'Personnage' } }
    /**
     * Find zero or one Personnage that matches the filter.
     * @param {PersonnageFindUniqueArgs} args - Arguments to find a Personnage
     * @example
     * // Get one Personnage
     * const personnage = await prisma.personnage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnageFindUniqueArgs>(args: SelectSubset<T, PersonnageFindUniqueArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Personnage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonnageFindUniqueOrThrowArgs} args - Arguments to find a Personnage
     * @example
     * // Get one Personnage
     * const personnage = await prisma.personnage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnageFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Personnage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageFindFirstArgs} args - Arguments to find a Personnage
     * @example
     * // Get one Personnage
     * const personnage = await prisma.personnage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnageFindFirstArgs>(args?: SelectSubset<T, PersonnageFindFirstArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Personnage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageFindFirstOrThrowArgs} args - Arguments to find a Personnage
     * @example
     * // Get one Personnage
     * const personnage = await prisma.personnage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnageFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Personnages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personnages
     * const personnages = await prisma.personnage.findMany()
     * 
     * // Get first 10 Personnages
     * const personnages = await prisma.personnage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personnageWithIdOnly = await prisma.personnage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonnageFindManyArgs>(args?: SelectSubset<T, PersonnageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Personnage.
     * @param {PersonnageCreateArgs} args - Arguments to create a Personnage.
     * @example
     * // Create one Personnage
     * const Personnage = await prisma.personnage.create({
     *   data: {
     *     // ... data to create a Personnage
     *   }
     * })
     * 
     */
    create<T extends PersonnageCreateArgs>(args: SelectSubset<T, PersonnageCreateArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Personnages.
     * @param {PersonnageCreateManyArgs} args - Arguments to create many Personnages.
     * @example
     * // Create many Personnages
     * const personnage = await prisma.personnage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnageCreateManyArgs>(args?: SelectSubset<T, PersonnageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Personnages and returns the data saved in the database.
     * @param {PersonnageCreateManyAndReturnArgs} args - Arguments to create many Personnages.
     * @example
     * // Create many Personnages
     * const personnage = await prisma.personnage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Personnages and only return the `id`
     * const personnageWithIdOnly = await prisma.personnage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonnageCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonnageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Personnage.
     * @param {PersonnageDeleteArgs} args - Arguments to delete one Personnage.
     * @example
     * // Delete one Personnage
     * const Personnage = await prisma.personnage.delete({
     *   where: {
     *     // ... filter to delete one Personnage
     *   }
     * })
     * 
     */
    delete<T extends PersonnageDeleteArgs>(args: SelectSubset<T, PersonnageDeleteArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Personnage.
     * @param {PersonnageUpdateArgs} args - Arguments to update one Personnage.
     * @example
     * // Update one Personnage
     * const personnage = await prisma.personnage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnageUpdateArgs>(args: SelectSubset<T, PersonnageUpdateArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Personnages.
     * @param {PersonnageDeleteManyArgs} args - Arguments to filter Personnages to delete.
     * @example
     * // Delete a few Personnages
     * const { count } = await prisma.personnage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnageDeleteManyArgs>(args?: SelectSubset<T, PersonnageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personnages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personnages
     * const personnage = await prisma.personnage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnageUpdateManyArgs>(args: SelectSubset<T, PersonnageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personnage.
     * @param {PersonnageUpsertArgs} args - Arguments to update or create a Personnage.
     * @example
     * // Update or create a Personnage
     * const personnage = await prisma.personnage.upsert({
     *   create: {
     *     // ... data to create a Personnage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personnage we want to update
     *   }
     * })
     */
    upsert<T extends PersonnageUpsertArgs>(args: SelectSubset<T, PersonnageUpsertArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Personnages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageCountArgs} args - Arguments to filter Personnages to count.
     * @example
     * // Count the number of Personnages
     * const count = await prisma.personnage.count({
     *   where: {
     *     // ... the filter for the Personnages we want to count
     *   }
     * })
    **/
    count<T extends PersonnageCountArgs>(
      args?: Subset<T, PersonnageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personnage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnageAggregateArgs>(args: Subset<T, PersonnageAggregateArgs>): Prisma.PrismaPromise<GetPersonnageAggregateType<T>>

    /**
     * Group by Personnage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnageGroupByArgs['orderBy'] }
        : { orderBy?: PersonnageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Personnage model
   */
  readonly fields: PersonnageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Personnage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    race<T extends Personnage$raceArgs<ExtArgs> = {}>(args?: Subset<T, Personnage$raceArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lignee<T extends Personnage$ligneeArgs<ExtArgs> = {}>(args?: Subset<T, Personnage$ligneeArgs<ExtArgs>>): Prisma__LigneeClient<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    roles<T extends Personnage$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Personnage$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "findMany"> | Null>
    competences<T extends Personnage$competencesArgs<ExtArgs> = {}>(args?: Subset<T, Personnage$competencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "findMany"> | Null>
    titres<T extends Personnage$titresArgs<ExtArgs> = {}>(args?: Subset<T, Personnage$titresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "findMany"> | Null>
    maladies<T extends Personnage$maladiesArgs<ExtArgs> = {}>(args?: Subset<T, Personnage$maladiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "findMany"> | Null>
    commandements<T extends Personnage$commandementsArgs<ExtArgs> = {}>(args?: Subset<T, Personnage$commandementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "findMany"> | Null>
    equipements<T extends Personnage$equipementsArgs<ExtArgs> = {}>(args?: Subset<T, Personnage$equipementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "findMany"> | Null>
    guildes<T extends Personnage$guildesArgs<ExtArgs> = {}>(args?: Subset<T, Personnage$guildesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Personnage model
   */ 
  interface PersonnageFieldRefs {
    readonly id: FieldRef<"Personnage", 'Int'>
    readonly nom: FieldRef<"Personnage", 'String'>
    readonly dateNaissance: FieldRef<"Personnage", 'DateTime'>
    readonly statutVie: FieldRef<"Personnage", 'String'>
    readonly dateDeces: FieldRef<"Personnage", 'DateTime'>
    readonly causeDeces: FieldRef<"Personnage", 'String'>
    readonly raceId: FieldRef<"Personnage", 'Int'>
    readonly ligneeId: FieldRef<"Personnage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Personnage findUnique
   */
  export type PersonnageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    /**
     * Filter, which Personnage to fetch.
     */
    where: PersonnageWhereUniqueInput
  }

  /**
   * Personnage findUniqueOrThrow
   */
  export type PersonnageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    /**
     * Filter, which Personnage to fetch.
     */
    where: PersonnageWhereUniqueInput
  }

  /**
   * Personnage findFirst
   */
  export type PersonnageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    /**
     * Filter, which Personnage to fetch.
     */
    where?: PersonnageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnages to fetch.
     */
    orderBy?: PersonnageOrderByWithRelationInput | PersonnageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personnages.
     */
    cursor?: PersonnageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personnages.
     */
    distinct?: PersonnageScalarFieldEnum | PersonnageScalarFieldEnum[]
  }

  /**
   * Personnage findFirstOrThrow
   */
  export type PersonnageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    /**
     * Filter, which Personnage to fetch.
     */
    where?: PersonnageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnages to fetch.
     */
    orderBy?: PersonnageOrderByWithRelationInput | PersonnageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personnages.
     */
    cursor?: PersonnageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personnages.
     */
    distinct?: PersonnageScalarFieldEnum | PersonnageScalarFieldEnum[]
  }

  /**
   * Personnage findMany
   */
  export type PersonnageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    /**
     * Filter, which Personnages to fetch.
     */
    where?: PersonnageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnages to fetch.
     */
    orderBy?: PersonnageOrderByWithRelationInput | PersonnageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personnages.
     */
    cursor?: PersonnageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnages.
     */
    skip?: number
    distinct?: PersonnageScalarFieldEnum | PersonnageScalarFieldEnum[]
  }

  /**
   * Personnage create
   */
  export type PersonnageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    /**
     * The data needed to create a Personnage.
     */
    data: XOR<PersonnageCreateInput, PersonnageUncheckedCreateInput>
  }

  /**
   * Personnage createMany
   */
  export type PersonnageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Personnages.
     */
    data: PersonnageCreateManyInput | PersonnageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Personnage createManyAndReturn
   */
  export type PersonnageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Personnages.
     */
    data: PersonnageCreateManyInput | PersonnageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Personnage update
   */
  export type PersonnageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    /**
     * The data needed to update a Personnage.
     */
    data: XOR<PersonnageUpdateInput, PersonnageUncheckedUpdateInput>
    /**
     * Choose, which Personnage to update.
     */
    where: PersonnageWhereUniqueInput
  }

  /**
   * Personnage updateMany
   */
  export type PersonnageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Personnages.
     */
    data: XOR<PersonnageUpdateManyMutationInput, PersonnageUncheckedUpdateManyInput>
    /**
     * Filter which Personnages to update
     */
    where?: PersonnageWhereInput
  }

  /**
   * Personnage upsert
   */
  export type PersonnageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    /**
     * The filter to search for the Personnage to update in case it exists.
     */
    where: PersonnageWhereUniqueInput
    /**
     * In case the Personnage found by the `where` argument doesn't exist, create a new Personnage with this data.
     */
    create: XOR<PersonnageCreateInput, PersonnageUncheckedCreateInput>
    /**
     * In case the Personnage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnageUpdateInput, PersonnageUncheckedUpdateInput>
  }

  /**
   * Personnage delete
   */
  export type PersonnageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    /**
     * Filter which Personnage to delete.
     */
    where: PersonnageWhereUniqueInput
  }

  /**
   * Personnage deleteMany
   */
  export type PersonnageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personnages to delete
     */
    where?: PersonnageWhereInput
  }

  /**
   * Personnage.race
   */
  export type Personnage$raceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    where?: RaceWhereInput
  }

  /**
   * Personnage.lignee
   */
  export type Personnage$ligneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    where?: LigneeWhereInput
  }

  /**
   * Personnage.roles
   */
  export type Personnage$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    where?: PersonnageRoleWhereInput
    orderBy?: PersonnageRoleOrderByWithRelationInput | PersonnageRoleOrderByWithRelationInput[]
    cursor?: PersonnageRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageRoleScalarFieldEnum | PersonnageRoleScalarFieldEnum[]
  }

  /**
   * Personnage.competences
   */
  export type Personnage$competencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    where?: PersonnageCompetenceWhereInput
    orderBy?: PersonnageCompetenceOrderByWithRelationInput | PersonnageCompetenceOrderByWithRelationInput[]
    cursor?: PersonnageCompetenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageCompetenceScalarFieldEnum | PersonnageCompetenceScalarFieldEnum[]
  }

  /**
   * Personnage.titres
   */
  export type Personnage$titresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    where?: PersonnageTitreWhereInput
    orderBy?: PersonnageTitreOrderByWithRelationInput | PersonnageTitreOrderByWithRelationInput[]
    cursor?: PersonnageTitreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageTitreScalarFieldEnum | PersonnageTitreScalarFieldEnum[]
  }

  /**
   * Personnage.maladies
   */
  export type Personnage$maladiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    where?: PersonnageMaladieWhereInput
    orderBy?: PersonnageMaladieOrderByWithRelationInput | PersonnageMaladieOrderByWithRelationInput[]
    cursor?: PersonnageMaladieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageMaladieScalarFieldEnum | PersonnageMaladieScalarFieldEnum[]
  }

  /**
   * Personnage.commandements
   */
  export type Personnage$commandementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    where?: ArmeeWhereInput
    orderBy?: ArmeeOrderByWithRelationInput | ArmeeOrderByWithRelationInput[]
    cursor?: ArmeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArmeeScalarFieldEnum | ArmeeScalarFieldEnum[]
  }

  /**
   * Personnage.equipements
   */
  export type Personnage$equipementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    where?: PersonnageEquipementWhereInput
    orderBy?: PersonnageEquipementOrderByWithRelationInput | PersonnageEquipementOrderByWithRelationInput[]
    cursor?: PersonnageEquipementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageEquipementScalarFieldEnum | PersonnageEquipementScalarFieldEnum[]
  }

  /**
   * Personnage.guildes
   */
  export type Personnage$guildesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    where?: GuildeMembreWhereInput
    orderBy?: GuildeMembreOrderByWithRelationInput | GuildeMembreOrderByWithRelationInput[]
    cursor?: GuildeMembreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuildeMembreScalarFieldEnum | GuildeMembreScalarFieldEnum[]
  }

  /**
   * Personnage without action
   */
  export type PersonnageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
  }


  /**
   * Model PersonnageRole
   */

  export type AggregatePersonnageRole = {
    _count: PersonnageRoleCountAggregateOutputType | null
    _avg: PersonnageRoleAvgAggregateOutputType | null
    _sum: PersonnageRoleSumAggregateOutputType | null
    _min: PersonnageRoleMinAggregateOutputType | null
    _max: PersonnageRoleMaxAggregateOutputType | null
  }

  export type PersonnageRoleAvgAggregateOutputType = {
    personnageId: number | null
    roleId: number | null
  }

  export type PersonnageRoleSumAggregateOutputType = {
    personnageId: number | null
    roleId: number | null
  }

  export type PersonnageRoleMinAggregateOutputType = {
    personnageId: number | null
    roleId: number | null
  }

  export type PersonnageRoleMaxAggregateOutputType = {
    personnageId: number | null
    roleId: number | null
  }

  export type PersonnageRoleCountAggregateOutputType = {
    personnageId: number
    roleId: number
    _all: number
  }


  export type PersonnageRoleAvgAggregateInputType = {
    personnageId?: true
    roleId?: true
  }

  export type PersonnageRoleSumAggregateInputType = {
    personnageId?: true
    roleId?: true
  }

  export type PersonnageRoleMinAggregateInputType = {
    personnageId?: true
    roleId?: true
  }

  export type PersonnageRoleMaxAggregateInputType = {
    personnageId?: true
    roleId?: true
  }

  export type PersonnageRoleCountAggregateInputType = {
    personnageId?: true
    roleId?: true
    _all?: true
  }

  export type PersonnageRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnageRole to aggregate.
     */
    where?: PersonnageRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageRoles to fetch.
     */
    orderBy?: PersonnageRoleOrderByWithRelationInput | PersonnageRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnageRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonnageRoles
    **/
    _count?: true | PersonnageRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonnageRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonnageRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnageRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnageRoleMaxAggregateInputType
  }

  export type GetPersonnageRoleAggregateType<T extends PersonnageRoleAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnageRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnageRole[P]>
      : GetScalarType<T[P], AggregatePersonnageRole[P]>
  }




  export type PersonnageRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageRoleWhereInput
    orderBy?: PersonnageRoleOrderByWithAggregationInput | PersonnageRoleOrderByWithAggregationInput[]
    by: PersonnageRoleScalarFieldEnum[] | PersonnageRoleScalarFieldEnum
    having?: PersonnageRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnageRoleCountAggregateInputType | true
    _avg?: PersonnageRoleAvgAggregateInputType
    _sum?: PersonnageRoleSumAggregateInputType
    _min?: PersonnageRoleMinAggregateInputType
    _max?: PersonnageRoleMaxAggregateInputType
  }

  export type PersonnageRoleGroupByOutputType = {
    personnageId: number
    roleId: number
    _count: PersonnageRoleCountAggregateOutputType | null
    _avg: PersonnageRoleAvgAggregateOutputType | null
    _sum: PersonnageRoleSumAggregateOutputType | null
    _min: PersonnageRoleMinAggregateOutputType | null
    _max: PersonnageRoleMaxAggregateOutputType | null
  }

  type GetPersonnageRoleGroupByPayload<T extends PersonnageRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnageRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnageRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnageRoleGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnageRoleGroupByOutputType[P]>
        }
      >
    >


  export type PersonnageRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnageId?: boolean
    roleId?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnageRole"]>

  export type PersonnageRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnageId?: boolean
    roleId?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnageRole"]>

  export type PersonnageRoleSelectScalar = {
    personnageId?: boolean
    roleId?: boolean
  }

  export type PersonnageRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type PersonnageRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $PersonnageRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonnageRole"
    objects: {
      personnage: Prisma.$PersonnagePayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      personnageId: number
      roleId: number
    }, ExtArgs["result"]["personnageRole"]>
    composites: {}
  }

  type PersonnageRoleGetPayload<S extends boolean | null | undefined | PersonnageRoleDefaultArgs> = $Result.GetResult<Prisma.$PersonnageRolePayload, S>

  type PersonnageRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonnageRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonnageRoleCountAggregateInputType | true
    }

  export interface PersonnageRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonnageRole'], meta: { name: 'PersonnageRole' } }
    /**
     * Find zero or one PersonnageRole that matches the filter.
     * @param {PersonnageRoleFindUniqueArgs} args - Arguments to find a PersonnageRole
     * @example
     * // Get one PersonnageRole
     * const personnageRole = await prisma.personnageRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnageRoleFindUniqueArgs>(args: SelectSubset<T, PersonnageRoleFindUniqueArgs<ExtArgs>>): Prisma__PersonnageRoleClient<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PersonnageRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonnageRoleFindUniqueOrThrowArgs} args - Arguments to find a PersonnageRole
     * @example
     * // Get one PersonnageRole
     * const personnageRole = await prisma.personnageRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnageRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnageRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnageRoleClient<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PersonnageRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageRoleFindFirstArgs} args - Arguments to find a PersonnageRole
     * @example
     * // Get one PersonnageRole
     * const personnageRole = await prisma.personnageRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnageRoleFindFirstArgs>(args?: SelectSubset<T, PersonnageRoleFindFirstArgs<ExtArgs>>): Prisma__PersonnageRoleClient<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PersonnageRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageRoleFindFirstOrThrowArgs} args - Arguments to find a PersonnageRole
     * @example
     * // Get one PersonnageRole
     * const personnageRole = await prisma.personnageRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnageRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnageRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnageRoleClient<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PersonnageRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonnageRoles
     * const personnageRoles = await prisma.personnageRole.findMany()
     * 
     * // Get first 10 PersonnageRoles
     * const personnageRoles = await prisma.personnageRole.findMany({ take: 10 })
     * 
     * // Only select the `personnageId`
     * const personnageRoleWithPersonnageIdOnly = await prisma.personnageRole.findMany({ select: { personnageId: true } })
     * 
     */
    findMany<T extends PersonnageRoleFindManyArgs>(args?: SelectSubset<T, PersonnageRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PersonnageRole.
     * @param {PersonnageRoleCreateArgs} args - Arguments to create a PersonnageRole.
     * @example
     * // Create one PersonnageRole
     * const PersonnageRole = await prisma.personnageRole.create({
     *   data: {
     *     // ... data to create a PersonnageRole
     *   }
     * })
     * 
     */
    create<T extends PersonnageRoleCreateArgs>(args: SelectSubset<T, PersonnageRoleCreateArgs<ExtArgs>>): Prisma__PersonnageRoleClient<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PersonnageRoles.
     * @param {PersonnageRoleCreateManyArgs} args - Arguments to create many PersonnageRoles.
     * @example
     * // Create many PersonnageRoles
     * const personnageRole = await prisma.personnageRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnageRoleCreateManyArgs>(args?: SelectSubset<T, PersonnageRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonnageRoles and returns the data saved in the database.
     * @param {PersonnageRoleCreateManyAndReturnArgs} args - Arguments to create many PersonnageRoles.
     * @example
     * // Create many PersonnageRoles
     * const personnageRole = await prisma.personnageRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonnageRoles and only return the `personnageId`
     * const personnageRoleWithPersonnageIdOnly = await prisma.personnageRole.createManyAndReturn({ 
     *   select: { personnageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonnageRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonnageRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PersonnageRole.
     * @param {PersonnageRoleDeleteArgs} args - Arguments to delete one PersonnageRole.
     * @example
     * // Delete one PersonnageRole
     * const PersonnageRole = await prisma.personnageRole.delete({
     *   where: {
     *     // ... filter to delete one PersonnageRole
     *   }
     * })
     * 
     */
    delete<T extends PersonnageRoleDeleteArgs>(args: SelectSubset<T, PersonnageRoleDeleteArgs<ExtArgs>>): Prisma__PersonnageRoleClient<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PersonnageRole.
     * @param {PersonnageRoleUpdateArgs} args - Arguments to update one PersonnageRole.
     * @example
     * // Update one PersonnageRole
     * const personnageRole = await prisma.personnageRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnageRoleUpdateArgs>(args: SelectSubset<T, PersonnageRoleUpdateArgs<ExtArgs>>): Prisma__PersonnageRoleClient<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PersonnageRoles.
     * @param {PersonnageRoleDeleteManyArgs} args - Arguments to filter PersonnageRoles to delete.
     * @example
     * // Delete a few PersonnageRoles
     * const { count } = await prisma.personnageRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnageRoleDeleteManyArgs>(args?: SelectSubset<T, PersonnageRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonnageRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonnageRoles
     * const personnageRole = await prisma.personnageRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnageRoleUpdateManyArgs>(args: SelectSubset<T, PersonnageRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonnageRole.
     * @param {PersonnageRoleUpsertArgs} args - Arguments to update or create a PersonnageRole.
     * @example
     * // Update or create a PersonnageRole
     * const personnageRole = await prisma.personnageRole.upsert({
     *   create: {
     *     // ... data to create a PersonnageRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonnageRole we want to update
     *   }
     * })
     */
    upsert<T extends PersonnageRoleUpsertArgs>(args: SelectSubset<T, PersonnageRoleUpsertArgs<ExtArgs>>): Prisma__PersonnageRoleClient<$Result.GetResult<Prisma.$PersonnageRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PersonnageRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageRoleCountArgs} args - Arguments to filter PersonnageRoles to count.
     * @example
     * // Count the number of PersonnageRoles
     * const count = await prisma.personnageRole.count({
     *   where: {
     *     // ... the filter for the PersonnageRoles we want to count
     *   }
     * })
    **/
    count<T extends PersonnageRoleCountArgs>(
      args?: Subset<T, PersonnageRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnageRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonnageRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnageRoleAggregateArgs>(args: Subset<T, PersonnageRoleAggregateArgs>): Prisma.PrismaPromise<GetPersonnageRoleAggregateType<T>>

    /**
     * Group by PersonnageRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnageRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnageRoleGroupByArgs['orderBy'] }
        : { orderBy?: PersonnageRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnageRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnageRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonnageRole model
   */
  readonly fields: PersonnageRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonnageRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnageRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnage<T extends PersonnageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnageDefaultArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonnageRole model
   */ 
  interface PersonnageRoleFieldRefs {
    readonly personnageId: FieldRef<"PersonnageRole", 'Int'>
    readonly roleId: FieldRef<"PersonnageRole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PersonnageRole findUnique
   */
  export type PersonnageRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageRole to fetch.
     */
    where: PersonnageRoleWhereUniqueInput
  }

  /**
   * PersonnageRole findUniqueOrThrow
   */
  export type PersonnageRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageRole to fetch.
     */
    where: PersonnageRoleWhereUniqueInput
  }

  /**
   * PersonnageRole findFirst
   */
  export type PersonnageRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageRole to fetch.
     */
    where?: PersonnageRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageRoles to fetch.
     */
    orderBy?: PersonnageRoleOrderByWithRelationInput | PersonnageRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnageRoles.
     */
    cursor?: PersonnageRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnageRoles.
     */
    distinct?: PersonnageRoleScalarFieldEnum | PersonnageRoleScalarFieldEnum[]
  }

  /**
   * PersonnageRole findFirstOrThrow
   */
  export type PersonnageRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageRole to fetch.
     */
    where?: PersonnageRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageRoles to fetch.
     */
    orderBy?: PersonnageRoleOrderByWithRelationInput | PersonnageRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnageRoles.
     */
    cursor?: PersonnageRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnageRoles.
     */
    distinct?: PersonnageRoleScalarFieldEnum | PersonnageRoleScalarFieldEnum[]
  }

  /**
   * PersonnageRole findMany
   */
  export type PersonnageRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageRoles to fetch.
     */
    where?: PersonnageRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageRoles to fetch.
     */
    orderBy?: PersonnageRoleOrderByWithRelationInput | PersonnageRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonnageRoles.
     */
    cursor?: PersonnageRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageRoles.
     */
    skip?: number
    distinct?: PersonnageRoleScalarFieldEnum | PersonnageRoleScalarFieldEnum[]
  }

  /**
   * PersonnageRole create
   */
  export type PersonnageRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonnageRole.
     */
    data: XOR<PersonnageRoleCreateInput, PersonnageRoleUncheckedCreateInput>
  }

  /**
   * PersonnageRole createMany
   */
  export type PersonnageRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonnageRoles.
     */
    data: PersonnageRoleCreateManyInput | PersonnageRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonnageRole createManyAndReturn
   */
  export type PersonnageRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PersonnageRoles.
     */
    data: PersonnageRoleCreateManyInput | PersonnageRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonnageRole update
   */
  export type PersonnageRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonnageRole.
     */
    data: XOR<PersonnageRoleUpdateInput, PersonnageRoleUncheckedUpdateInput>
    /**
     * Choose, which PersonnageRole to update.
     */
    where: PersonnageRoleWhereUniqueInput
  }

  /**
   * PersonnageRole updateMany
   */
  export type PersonnageRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonnageRoles.
     */
    data: XOR<PersonnageRoleUpdateManyMutationInput, PersonnageRoleUncheckedUpdateManyInput>
    /**
     * Filter which PersonnageRoles to update
     */
    where?: PersonnageRoleWhereInput
  }

  /**
   * PersonnageRole upsert
   */
  export type PersonnageRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonnageRole to update in case it exists.
     */
    where: PersonnageRoleWhereUniqueInput
    /**
     * In case the PersonnageRole found by the `where` argument doesn't exist, create a new PersonnageRole with this data.
     */
    create: XOR<PersonnageRoleCreateInput, PersonnageRoleUncheckedCreateInput>
    /**
     * In case the PersonnageRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnageRoleUpdateInput, PersonnageRoleUncheckedUpdateInput>
  }

  /**
   * PersonnageRole delete
   */
  export type PersonnageRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
    /**
     * Filter which PersonnageRole to delete.
     */
    where: PersonnageRoleWhereUniqueInput
  }

  /**
   * PersonnageRole deleteMany
   */
  export type PersonnageRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnageRoles to delete
     */
    where?: PersonnageRoleWhereInput
  }

  /**
   * PersonnageRole without action
   */
  export type PersonnageRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageRole
     */
    select?: PersonnageRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageRoleInclude<ExtArgs> | null
  }


  /**
   * Model Competence
   */

  export type AggregateCompetence = {
    _count: CompetenceCountAggregateOutputType | null
    _avg: CompetenceAvgAggregateOutputType | null
    _sum: CompetenceSumAggregateOutputType | null
    _min: CompetenceMinAggregateOutputType | null
    _max: CompetenceMaxAggregateOutputType | null
  }

  export type CompetenceAvgAggregateOutputType = {
    id: number | null
    exigenceRaceId: number | null
  }

  export type CompetenceSumAggregateOutputType = {
    id: number | null
    exigenceRaceId: number | null
  }

  export type CompetenceMinAggregateOutputType = {
    id: number | null
    nom: string | null
    exigenceFormation: string | null
    exigenceRaceId: number | null
  }

  export type CompetenceMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    exigenceFormation: string | null
    exigenceRaceId: number | null
  }

  export type CompetenceCountAggregateOutputType = {
    id: number
    nom: number
    exigenceFormation: number
    exigenceRaceId: number
    _all: number
  }


  export type CompetenceAvgAggregateInputType = {
    id?: true
    exigenceRaceId?: true
  }

  export type CompetenceSumAggregateInputType = {
    id?: true
    exigenceRaceId?: true
  }

  export type CompetenceMinAggregateInputType = {
    id?: true
    nom?: true
    exigenceFormation?: true
    exigenceRaceId?: true
  }

  export type CompetenceMaxAggregateInputType = {
    id?: true
    nom?: true
    exigenceFormation?: true
    exigenceRaceId?: true
  }

  export type CompetenceCountAggregateInputType = {
    id?: true
    nom?: true
    exigenceFormation?: true
    exigenceRaceId?: true
    _all?: true
  }

  export type CompetenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Competence to aggregate.
     */
    where?: CompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competences to fetch.
     */
    orderBy?: CompetenceOrderByWithRelationInput | CompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Competences
    **/
    _count?: true | CompetenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompetenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompetenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompetenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompetenceMaxAggregateInputType
  }

  export type GetCompetenceAggregateType<T extends CompetenceAggregateArgs> = {
        [P in keyof T & keyof AggregateCompetence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompetence[P]>
      : GetScalarType<T[P], AggregateCompetence[P]>
  }




  export type CompetenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetenceWhereInput
    orderBy?: CompetenceOrderByWithAggregationInput | CompetenceOrderByWithAggregationInput[]
    by: CompetenceScalarFieldEnum[] | CompetenceScalarFieldEnum
    having?: CompetenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompetenceCountAggregateInputType | true
    _avg?: CompetenceAvgAggregateInputType
    _sum?: CompetenceSumAggregateInputType
    _min?: CompetenceMinAggregateInputType
    _max?: CompetenceMaxAggregateInputType
  }

  export type CompetenceGroupByOutputType = {
    id: number
    nom: string
    exigenceFormation: string | null
    exigenceRaceId: number | null
    _count: CompetenceCountAggregateOutputType | null
    _avg: CompetenceAvgAggregateOutputType | null
    _sum: CompetenceSumAggregateOutputType | null
    _min: CompetenceMinAggregateOutputType | null
    _max: CompetenceMaxAggregateOutputType | null
  }

  type GetCompetenceGroupByPayload<T extends CompetenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompetenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompetenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompetenceGroupByOutputType[P]>
            : GetScalarType<T[P], CompetenceGroupByOutputType[P]>
        }
      >
    >


  export type CompetenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    exigenceFormation?: boolean
    exigenceRaceId?: boolean
    exigenceRace?: boolean | Competence$exigenceRaceArgs<ExtArgs>
    personnages?: boolean | Competence$personnagesArgs<ExtArgs>
    _count?: boolean | CompetenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["competence"]>

  export type CompetenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    exigenceFormation?: boolean
    exigenceRaceId?: boolean
    exigenceRace?: boolean | Competence$exigenceRaceArgs<ExtArgs>
  }, ExtArgs["result"]["competence"]>

  export type CompetenceSelectScalar = {
    id?: boolean
    nom?: boolean
    exigenceFormation?: boolean
    exigenceRaceId?: boolean
  }

  export type CompetenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exigenceRace?: boolean | Competence$exigenceRaceArgs<ExtArgs>
    personnages?: boolean | Competence$personnagesArgs<ExtArgs>
    _count?: boolean | CompetenceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompetenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exigenceRace?: boolean | Competence$exigenceRaceArgs<ExtArgs>
  }

  export type $CompetencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Competence"
    objects: {
      exigenceRace: Prisma.$RacePayload<ExtArgs> | null
      personnages: Prisma.$PersonnageCompetencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      exigenceFormation: string | null
      exigenceRaceId: number | null
    }, ExtArgs["result"]["competence"]>
    composites: {}
  }

  type CompetenceGetPayload<S extends boolean | null | undefined | CompetenceDefaultArgs> = $Result.GetResult<Prisma.$CompetencePayload, S>

  type CompetenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompetenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompetenceCountAggregateInputType | true
    }

  export interface CompetenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Competence'], meta: { name: 'Competence' } }
    /**
     * Find zero or one Competence that matches the filter.
     * @param {CompetenceFindUniqueArgs} args - Arguments to find a Competence
     * @example
     * // Get one Competence
     * const competence = await prisma.competence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompetenceFindUniqueArgs>(args: SelectSubset<T, CompetenceFindUniqueArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Competence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompetenceFindUniqueOrThrowArgs} args - Arguments to find a Competence
     * @example
     * // Get one Competence
     * const competence = await prisma.competence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompetenceFindUniqueOrThrowArgs>(args: SelectSubset<T, CompetenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Competence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceFindFirstArgs} args - Arguments to find a Competence
     * @example
     * // Get one Competence
     * const competence = await prisma.competence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompetenceFindFirstArgs>(args?: SelectSubset<T, CompetenceFindFirstArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Competence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceFindFirstOrThrowArgs} args - Arguments to find a Competence
     * @example
     * // Get one Competence
     * const competence = await prisma.competence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompetenceFindFirstOrThrowArgs>(args?: SelectSubset<T, CompetenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Competences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Competences
     * const competences = await prisma.competence.findMany()
     * 
     * // Get first 10 Competences
     * const competences = await prisma.competence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const competenceWithIdOnly = await prisma.competence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompetenceFindManyArgs>(args?: SelectSubset<T, CompetenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Competence.
     * @param {CompetenceCreateArgs} args - Arguments to create a Competence.
     * @example
     * // Create one Competence
     * const Competence = await prisma.competence.create({
     *   data: {
     *     // ... data to create a Competence
     *   }
     * })
     * 
     */
    create<T extends CompetenceCreateArgs>(args: SelectSubset<T, CompetenceCreateArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Competences.
     * @param {CompetenceCreateManyArgs} args - Arguments to create many Competences.
     * @example
     * // Create many Competences
     * const competence = await prisma.competence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompetenceCreateManyArgs>(args?: SelectSubset<T, CompetenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Competences and returns the data saved in the database.
     * @param {CompetenceCreateManyAndReturnArgs} args - Arguments to create many Competences.
     * @example
     * // Create many Competences
     * const competence = await prisma.competence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Competences and only return the `id`
     * const competenceWithIdOnly = await prisma.competence.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompetenceCreateManyAndReturnArgs>(args?: SelectSubset<T, CompetenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Competence.
     * @param {CompetenceDeleteArgs} args - Arguments to delete one Competence.
     * @example
     * // Delete one Competence
     * const Competence = await prisma.competence.delete({
     *   where: {
     *     // ... filter to delete one Competence
     *   }
     * })
     * 
     */
    delete<T extends CompetenceDeleteArgs>(args: SelectSubset<T, CompetenceDeleteArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Competence.
     * @param {CompetenceUpdateArgs} args - Arguments to update one Competence.
     * @example
     * // Update one Competence
     * const competence = await prisma.competence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompetenceUpdateArgs>(args: SelectSubset<T, CompetenceUpdateArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Competences.
     * @param {CompetenceDeleteManyArgs} args - Arguments to filter Competences to delete.
     * @example
     * // Delete a few Competences
     * const { count } = await prisma.competence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompetenceDeleteManyArgs>(args?: SelectSubset<T, CompetenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Competences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Competences
     * const competence = await prisma.competence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompetenceUpdateManyArgs>(args: SelectSubset<T, CompetenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Competence.
     * @param {CompetenceUpsertArgs} args - Arguments to update or create a Competence.
     * @example
     * // Update or create a Competence
     * const competence = await prisma.competence.upsert({
     *   create: {
     *     // ... data to create a Competence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Competence we want to update
     *   }
     * })
     */
    upsert<T extends CompetenceUpsertArgs>(args: SelectSubset<T, CompetenceUpsertArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Competences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceCountArgs} args - Arguments to filter Competences to count.
     * @example
     * // Count the number of Competences
     * const count = await prisma.competence.count({
     *   where: {
     *     // ... the filter for the Competences we want to count
     *   }
     * })
    **/
    count<T extends CompetenceCountArgs>(
      args?: Subset<T, CompetenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompetenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Competence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompetenceAggregateArgs>(args: Subset<T, CompetenceAggregateArgs>): Prisma.PrismaPromise<GetCompetenceAggregateType<T>>

    /**
     * Group by Competence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompetenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompetenceGroupByArgs['orderBy'] }
        : { orderBy?: CompetenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompetenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompetenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Competence model
   */
  readonly fields: CompetenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Competence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompetenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exigenceRace<T extends Competence$exigenceRaceArgs<ExtArgs> = {}>(args?: Subset<T, Competence$exigenceRaceArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    personnages<T extends Competence$personnagesArgs<ExtArgs> = {}>(args?: Subset<T, Competence$personnagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Competence model
   */ 
  interface CompetenceFieldRefs {
    readonly id: FieldRef<"Competence", 'Int'>
    readonly nom: FieldRef<"Competence", 'String'>
    readonly exigenceFormation: FieldRef<"Competence", 'String'>
    readonly exigenceRaceId: FieldRef<"Competence", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Competence findUnique
   */
  export type CompetenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter, which Competence to fetch.
     */
    where: CompetenceWhereUniqueInput
  }

  /**
   * Competence findUniqueOrThrow
   */
  export type CompetenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter, which Competence to fetch.
     */
    where: CompetenceWhereUniqueInput
  }

  /**
   * Competence findFirst
   */
  export type CompetenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter, which Competence to fetch.
     */
    where?: CompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competences to fetch.
     */
    orderBy?: CompetenceOrderByWithRelationInput | CompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Competences.
     */
    cursor?: CompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Competences.
     */
    distinct?: CompetenceScalarFieldEnum | CompetenceScalarFieldEnum[]
  }

  /**
   * Competence findFirstOrThrow
   */
  export type CompetenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter, which Competence to fetch.
     */
    where?: CompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competences to fetch.
     */
    orderBy?: CompetenceOrderByWithRelationInput | CompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Competences.
     */
    cursor?: CompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Competences.
     */
    distinct?: CompetenceScalarFieldEnum | CompetenceScalarFieldEnum[]
  }

  /**
   * Competence findMany
   */
  export type CompetenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter, which Competences to fetch.
     */
    where?: CompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competences to fetch.
     */
    orderBy?: CompetenceOrderByWithRelationInput | CompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Competences.
     */
    cursor?: CompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competences.
     */
    skip?: number
    distinct?: CompetenceScalarFieldEnum | CompetenceScalarFieldEnum[]
  }

  /**
   * Competence create
   */
  export type CompetenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Competence.
     */
    data: XOR<CompetenceCreateInput, CompetenceUncheckedCreateInput>
  }

  /**
   * Competence createMany
   */
  export type CompetenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Competences.
     */
    data: CompetenceCreateManyInput | CompetenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Competence createManyAndReturn
   */
  export type CompetenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Competences.
     */
    data: CompetenceCreateManyInput | CompetenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Competence update
   */
  export type CompetenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Competence.
     */
    data: XOR<CompetenceUpdateInput, CompetenceUncheckedUpdateInput>
    /**
     * Choose, which Competence to update.
     */
    where: CompetenceWhereUniqueInput
  }

  /**
   * Competence updateMany
   */
  export type CompetenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Competences.
     */
    data: XOR<CompetenceUpdateManyMutationInput, CompetenceUncheckedUpdateManyInput>
    /**
     * Filter which Competences to update
     */
    where?: CompetenceWhereInput
  }

  /**
   * Competence upsert
   */
  export type CompetenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Competence to update in case it exists.
     */
    where: CompetenceWhereUniqueInput
    /**
     * In case the Competence found by the `where` argument doesn't exist, create a new Competence with this data.
     */
    create: XOR<CompetenceCreateInput, CompetenceUncheckedCreateInput>
    /**
     * In case the Competence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompetenceUpdateInput, CompetenceUncheckedUpdateInput>
  }

  /**
   * Competence delete
   */
  export type CompetenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
    /**
     * Filter which Competence to delete.
     */
    where: CompetenceWhereUniqueInput
  }

  /**
   * Competence deleteMany
   */
  export type CompetenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Competences to delete
     */
    where?: CompetenceWhereInput
  }

  /**
   * Competence.exigenceRace
   */
  export type Competence$exigenceRaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    where?: RaceWhereInput
  }

  /**
   * Competence.personnages
   */
  export type Competence$personnagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    where?: PersonnageCompetenceWhereInput
    orderBy?: PersonnageCompetenceOrderByWithRelationInput | PersonnageCompetenceOrderByWithRelationInput[]
    cursor?: PersonnageCompetenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageCompetenceScalarFieldEnum | PersonnageCompetenceScalarFieldEnum[]
  }

  /**
   * Competence without action
   */
  export type CompetenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competence
     */
    select?: CompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetenceInclude<ExtArgs> | null
  }


  /**
   * Model PersonnageCompetence
   */

  export type AggregatePersonnageCompetence = {
    _count: PersonnageCompetenceCountAggregateOutputType | null
    _avg: PersonnageCompetenceAvgAggregateOutputType | null
    _sum: PersonnageCompetenceSumAggregateOutputType | null
    _min: PersonnageCompetenceMinAggregateOutputType | null
    _max: PersonnageCompetenceMaxAggregateOutputType | null
  }

  export type PersonnageCompetenceAvgAggregateOutputType = {
    personnageId: number | null
    competenceId: number | null
    niveau: number | null
  }

  export type PersonnageCompetenceSumAggregateOutputType = {
    personnageId: number | null
    competenceId: number | null
    niveau: number | null
  }

  export type PersonnageCompetenceMinAggregateOutputType = {
    personnageId: number | null
    competenceId: number | null
    niveau: number | null
  }

  export type PersonnageCompetenceMaxAggregateOutputType = {
    personnageId: number | null
    competenceId: number | null
    niveau: number | null
  }

  export type PersonnageCompetenceCountAggregateOutputType = {
    personnageId: number
    competenceId: number
    niveau: number
    _all: number
  }


  export type PersonnageCompetenceAvgAggregateInputType = {
    personnageId?: true
    competenceId?: true
    niveau?: true
  }

  export type PersonnageCompetenceSumAggregateInputType = {
    personnageId?: true
    competenceId?: true
    niveau?: true
  }

  export type PersonnageCompetenceMinAggregateInputType = {
    personnageId?: true
    competenceId?: true
    niveau?: true
  }

  export type PersonnageCompetenceMaxAggregateInputType = {
    personnageId?: true
    competenceId?: true
    niveau?: true
  }

  export type PersonnageCompetenceCountAggregateInputType = {
    personnageId?: true
    competenceId?: true
    niveau?: true
    _all?: true
  }

  export type PersonnageCompetenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnageCompetence to aggregate.
     */
    where?: PersonnageCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageCompetences to fetch.
     */
    orderBy?: PersonnageCompetenceOrderByWithRelationInput | PersonnageCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnageCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageCompetences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonnageCompetences
    **/
    _count?: true | PersonnageCompetenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonnageCompetenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonnageCompetenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnageCompetenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnageCompetenceMaxAggregateInputType
  }

  export type GetPersonnageCompetenceAggregateType<T extends PersonnageCompetenceAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnageCompetence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnageCompetence[P]>
      : GetScalarType<T[P], AggregatePersonnageCompetence[P]>
  }




  export type PersonnageCompetenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageCompetenceWhereInput
    orderBy?: PersonnageCompetenceOrderByWithAggregationInput | PersonnageCompetenceOrderByWithAggregationInput[]
    by: PersonnageCompetenceScalarFieldEnum[] | PersonnageCompetenceScalarFieldEnum
    having?: PersonnageCompetenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnageCompetenceCountAggregateInputType | true
    _avg?: PersonnageCompetenceAvgAggregateInputType
    _sum?: PersonnageCompetenceSumAggregateInputType
    _min?: PersonnageCompetenceMinAggregateInputType
    _max?: PersonnageCompetenceMaxAggregateInputType
  }

  export type PersonnageCompetenceGroupByOutputType = {
    personnageId: number
    competenceId: number
    niveau: number
    _count: PersonnageCompetenceCountAggregateOutputType | null
    _avg: PersonnageCompetenceAvgAggregateOutputType | null
    _sum: PersonnageCompetenceSumAggregateOutputType | null
    _min: PersonnageCompetenceMinAggregateOutputType | null
    _max: PersonnageCompetenceMaxAggregateOutputType | null
  }

  type GetPersonnageCompetenceGroupByPayload<T extends PersonnageCompetenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnageCompetenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnageCompetenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnageCompetenceGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnageCompetenceGroupByOutputType[P]>
        }
      >
    >


  export type PersonnageCompetenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnageId?: boolean
    competenceId?: boolean
    niveau?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    competence?: boolean | CompetenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnageCompetence"]>

  export type PersonnageCompetenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnageId?: boolean
    competenceId?: boolean
    niveau?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    competence?: boolean | CompetenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnageCompetence"]>

  export type PersonnageCompetenceSelectScalar = {
    personnageId?: boolean
    competenceId?: boolean
    niveau?: boolean
  }

  export type PersonnageCompetenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    competence?: boolean | CompetenceDefaultArgs<ExtArgs>
  }
  export type PersonnageCompetenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    competence?: boolean | CompetenceDefaultArgs<ExtArgs>
  }

  export type $PersonnageCompetencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonnageCompetence"
    objects: {
      personnage: Prisma.$PersonnagePayload<ExtArgs>
      competence: Prisma.$CompetencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      personnageId: number
      competenceId: number
      niveau: number
    }, ExtArgs["result"]["personnageCompetence"]>
    composites: {}
  }

  type PersonnageCompetenceGetPayload<S extends boolean | null | undefined | PersonnageCompetenceDefaultArgs> = $Result.GetResult<Prisma.$PersonnageCompetencePayload, S>

  type PersonnageCompetenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonnageCompetenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonnageCompetenceCountAggregateInputType | true
    }

  export interface PersonnageCompetenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonnageCompetence'], meta: { name: 'PersonnageCompetence' } }
    /**
     * Find zero or one PersonnageCompetence that matches the filter.
     * @param {PersonnageCompetenceFindUniqueArgs} args - Arguments to find a PersonnageCompetence
     * @example
     * // Get one PersonnageCompetence
     * const personnageCompetence = await prisma.personnageCompetence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnageCompetenceFindUniqueArgs>(args: SelectSubset<T, PersonnageCompetenceFindUniqueArgs<ExtArgs>>): Prisma__PersonnageCompetenceClient<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PersonnageCompetence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonnageCompetenceFindUniqueOrThrowArgs} args - Arguments to find a PersonnageCompetence
     * @example
     * // Get one PersonnageCompetence
     * const personnageCompetence = await prisma.personnageCompetence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnageCompetenceFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnageCompetenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnageCompetenceClient<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PersonnageCompetence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageCompetenceFindFirstArgs} args - Arguments to find a PersonnageCompetence
     * @example
     * // Get one PersonnageCompetence
     * const personnageCompetence = await prisma.personnageCompetence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnageCompetenceFindFirstArgs>(args?: SelectSubset<T, PersonnageCompetenceFindFirstArgs<ExtArgs>>): Prisma__PersonnageCompetenceClient<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PersonnageCompetence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageCompetenceFindFirstOrThrowArgs} args - Arguments to find a PersonnageCompetence
     * @example
     * // Get one PersonnageCompetence
     * const personnageCompetence = await prisma.personnageCompetence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnageCompetenceFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnageCompetenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnageCompetenceClient<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PersonnageCompetences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageCompetenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonnageCompetences
     * const personnageCompetences = await prisma.personnageCompetence.findMany()
     * 
     * // Get first 10 PersonnageCompetences
     * const personnageCompetences = await prisma.personnageCompetence.findMany({ take: 10 })
     * 
     * // Only select the `personnageId`
     * const personnageCompetenceWithPersonnageIdOnly = await prisma.personnageCompetence.findMany({ select: { personnageId: true } })
     * 
     */
    findMany<T extends PersonnageCompetenceFindManyArgs>(args?: SelectSubset<T, PersonnageCompetenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PersonnageCompetence.
     * @param {PersonnageCompetenceCreateArgs} args - Arguments to create a PersonnageCompetence.
     * @example
     * // Create one PersonnageCompetence
     * const PersonnageCompetence = await prisma.personnageCompetence.create({
     *   data: {
     *     // ... data to create a PersonnageCompetence
     *   }
     * })
     * 
     */
    create<T extends PersonnageCompetenceCreateArgs>(args: SelectSubset<T, PersonnageCompetenceCreateArgs<ExtArgs>>): Prisma__PersonnageCompetenceClient<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PersonnageCompetences.
     * @param {PersonnageCompetenceCreateManyArgs} args - Arguments to create many PersonnageCompetences.
     * @example
     * // Create many PersonnageCompetences
     * const personnageCompetence = await prisma.personnageCompetence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnageCompetenceCreateManyArgs>(args?: SelectSubset<T, PersonnageCompetenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonnageCompetences and returns the data saved in the database.
     * @param {PersonnageCompetenceCreateManyAndReturnArgs} args - Arguments to create many PersonnageCompetences.
     * @example
     * // Create many PersonnageCompetences
     * const personnageCompetence = await prisma.personnageCompetence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonnageCompetences and only return the `personnageId`
     * const personnageCompetenceWithPersonnageIdOnly = await prisma.personnageCompetence.createManyAndReturn({ 
     *   select: { personnageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonnageCompetenceCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonnageCompetenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PersonnageCompetence.
     * @param {PersonnageCompetenceDeleteArgs} args - Arguments to delete one PersonnageCompetence.
     * @example
     * // Delete one PersonnageCompetence
     * const PersonnageCompetence = await prisma.personnageCompetence.delete({
     *   where: {
     *     // ... filter to delete one PersonnageCompetence
     *   }
     * })
     * 
     */
    delete<T extends PersonnageCompetenceDeleteArgs>(args: SelectSubset<T, PersonnageCompetenceDeleteArgs<ExtArgs>>): Prisma__PersonnageCompetenceClient<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PersonnageCompetence.
     * @param {PersonnageCompetenceUpdateArgs} args - Arguments to update one PersonnageCompetence.
     * @example
     * // Update one PersonnageCompetence
     * const personnageCompetence = await prisma.personnageCompetence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnageCompetenceUpdateArgs>(args: SelectSubset<T, PersonnageCompetenceUpdateArgs<ExtArgs>>): Prisma__PersonnageCompetenceClient<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PersonnageCompetences.
     * @param {PersonnageCompetenceDeleteManyArgs} args - Arguments to filter PersonnageCompetences to delete.
     * @example
     * // Delete a few PersonnageCompetences
     * const { count } = await prisma.personnageCompetence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnageCompetenceDeleteManyArgs>(args?: SelectSubset<T, PersonnageCompetenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonnageCompetences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageCompetenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonnageCompetences
     * const personnageCompetence = await prisma.personnageCompetence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnageCompetenceUpdateManyArgs>(args: SelectSubset<T, PersonnageCompetenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonnageCompetence.
     * @param {PersonnageCompetenceUpsertArgs} args - Arguments to update or create a PersonnageCompetence.
     * @example
     * // Update or create a PersonnageCompetence
     * const personnageCompetence = await prisma.personnageCompetence.upsert({
     *   create: {
     *     // ... data to create a PersonnageCompetence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonnageCompetence we want to update
     *   }
     * })
     */
    upsert<T extends PersonnageCompetenceUpsertArgs>(args: SelectSubset<T, PersonnageCompetenceUpsertArgs<ExtArgs>>): Prisma__PersonnageCompetenceClient<$Result.GetResult<Prisma.$PersonnageCompetencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PersonnageCompetences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageCompetenceCountArgs} args - Arguments to filter PersonnageCompetences to count.
     * @example
     * // Count the number of PersonnageCompetences
     * const count = await prisma.personnageCompetence.count({
     *   where: {
     *     // ... the filter for the PersonnageCompetences we want to count
     *   }
     * })
    **/
    count<T extends PersonnageCompetenceCountArgs>(
      args?: Subset<T, PersonnageCompetenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnageCompetenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonnageCompetence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageCompetenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnageCompetenceAggregateArgs>(args: Subset<T, PersonnageCompetenceAggregateArgs>): Prisma.PrismaPromise<GetPersonnageCompetenceAggregateType<T>>

    /**
     * Group by PersonnageCompetence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageCompetenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnageCompetenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnageCompetenceGroupByArgs['orderBy'] }
        : { orderBy?: PersonnageCompetenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnageCompetenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnageCompetenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonnageCompetence model
   */
  readonly fields: PersonnageCompetenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonnageCompetence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnageCompetenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnage<T extends PersonnageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnageDefaultArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    competence<T extends CompetenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompetenceDefaultArgs<ExtArgs>>): Prisma__CompetenceClient<$Result.GetResult<Prisma.$CompetencePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonnageCompetence model
   */ 
  interface PersonnageCompetenceFieldRefs {
    readonly personnageId: FieldRef<"PersonnageCompetence", 'Int'>
    readonly competenceId: FieldRef<"PersonnageCompetence", 'Int'>
    readonly niveau: FieldRef<"PersonnageCompetence", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PersonnageCompetence findUnique
   */
  export type PersonnageCompetenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageCompetence to fetch.
     */
    where: PersonnageCompetenceWhereUniqueInput
  }

  /**
   * PersonnageCompetence findUniqueOrThrow
   */
  export type PersonnageCompetenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageCompetence to fetch.
     */
    where: PersonnageCompetenceWhereUniqueInput
  }

  /**
   * PersonnageCompetence findFirst
   */
  export type PersonnageCompetenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageCompetence to fetch.
     */
    where?: PersonnageCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageCompetences to fetch.
     */
    orderBy?: PersonnageCompetenceOrderByWithRelationInput | PersonnageCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnageCompetences.
     */
    cursor?: PersonnageCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageCompetences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnageCompetences.
     */
    distinct?: PersonnageCompetenceScalarFieldEnum | PersonnageCompetenceScalarFieldEnum[]
  }

  /**
   * PersonnageCompetence findFirstOrThrow
   */
  export type PersonnageCompetenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageCompetence to fetch.
     */
    where?: PersonnageCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageCompetences to fetch.
     */
    orderBy?: PersonnageCompetenceOrderByWithRelationInput | PersonnageCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnageCompetences.
     */
    cursor?: PersonnageCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageCompetences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnageCompetences.
     */
    distinct?: PersonnageCompetenceScalarFieldEnum | PersonnageCompetenceScalarFieldEnum[]
  }

  /**
   * PersonnageCompetence findMany
   */
  export type PersonnageCompetenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageCompetences to fetch.
     */
    where?: PersonnageCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageCompetences to fetch.
     */
    orderBy?: PersonnageCompetenceOrderByWithRelationInput | PersonnageCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonnageCompetences.
     */
    cursor?: PersonnageCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageCompetences.
     */
    skip?: number
    distinct?: PersonnageCompetenceScalarFieldEnum | PersonnageCompetenceScalarFieldEnum[]
  }

  /**
   * PersonnageCompetence create
   */
  export type PersonnageCompetenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonnageCompetence.
     */
    data: XOR<PersonnageCompetenceCreateInput, PersonnageCompetenceUncheckedCreateInput>
  }

  /**
   * PersonnageCompetence createMany
   */
  export type PersonnageCompetenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonnageCompetences.
     */
    data: PersonnageCompetenceCreateManyInput | PersonnageCompetenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonnageCompetence createManyAndReturn
   */
  export type PersonnageCompetenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PersonnageCompetences.
     */
    data: PersonnageCompetenceCreateManyInput | PersonnageCompetenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonnageCompetence update
   */
  export type PersonnageCompetenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonnageCompetence.
     */
    data: XOR<PersonnageCompetenceUpdateInput, PersonnageCompetenceUncheckedUpdateInput>
    /**
     * Choose, which PersonnageCompetence to update.
     */
    where: PersonnageCompetenceWhereUniqueInput
  }

  /**
   * PersonnageCompetence updateMany
   */
  export type PersonnageCompetenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonnageCompetences.
     */
    data: XOR<PersonnageCompetenceUpdateManyMutationInput, PersonnageCompetenceUncheckedUpdateManyInput>
    /**
     * Filter which PersonnageCompetences to update
     */
    where?: PersonnageCompetenceWhereInput
  }

  /**
   * PersonnageCompetence upsert
   */
  export type PersonnageCompetenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonnageCompetence to update in case it exists.
     */
    where: PersonnageCompetenceWhereUniqueInput
    /**
     * In case the PersonnageCompetence found by the `where` argument doesn't exist, create a new PersonnageCompetence with this data.
     */
    create: XOR<PersonnageCompetenceCreateInput, PersonnageCompetenceUncheckedCreateInput>
    /**
     * In case the PersonnageCompetence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnageCompetenceUpdateInput, PersonnageCompetenceUncheckedUpdateInput>
  }

  /**
   * PersonnageCompetence delete
   */
  export type PersonnageCompetenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
    /**
     * Filter which PersonnageCompetence to delete.
     */
    where: PersonnageCompetenceWhereUniqueInput
  }

  /**
   * PersonnageCompetence deleteMany
   */
  export type PersonnageCompetenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnageCompetences to delete
     */
    where?: PersonnageCompetenceWhereInput
  }

  /**
   * PersonnageCompetence without action
   */
  export type PersonnageCompetenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageCompetence
     */
    select?: PersonnageCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageCompetenceInclude<ExtArgs> | null
  }


  /**
   * Model Domaine
   */

  export type AggregateDomaine = {
    _count: DomaineCountAggregateOutputType | null
    _avg: DomaineAvgAggregateOutputType | null
    _sum: DomaineSumAggregateOutputType | null
    _min: DomaineMinAggregateOutputType | null
    _max: DomaineMaxAggregateOutputType | null
  }

  export type DomaineAvgAggregateOutputType = {
    id: number | null
    richessesOr: Decimal | null
  }

  export type DomaineSumAggregateOutputType = {
    id: number | null
    richessesOr: Decimal | null
  }

  export type DomaineMinAggregateOutputType = {
    id: number | null
    nom: string | null
    frontieres: string | null
    richessesOr: Decimal | null
    ressources: string | null
  }

  export type DomaineMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    frontieres: string | null
    richessesOr: Decimal | null
    ressources: string | null
  }

  export type DomaineCountAggregateOutputType = {
    id: number
    nom: number
    frontieres: number
    richessesOr: number
    ressources: number
    _all: number
  }


  export type DomaineAvgAggregateInputType = {
    id?: true
    richessesOr?: true
  }

  export type DomaineSumAggregateInputType = {
    id?: true
    richessesOr?: true
  }

  export type DomaineMinAggregateInputType = {
    id?: true
    nom?: true
    frontieres?: true
    richessesOr?: true
    ressources?: true
  }

  export type DomaineMaxAggregateInputType = {
    id?: true
    nom?: true
    frontieres?: true
    richessesOr?: true
    ressources?: true
  }

  export type DomaineCountAggregateInputType = {
    id?: true
    nom?: true
    frontieres?: true
    richessesOr?: true
    ressources?: true
    _all?: true
  }

  export type DomaineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domaine to aggregate.
     */
    where?: DomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domaines to fetch.
     */
    orderBy?: DomaineOrderByWithRelationInput | DomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domaines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Domaines
    **/
    _count?: true | DomaineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomaineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomaineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomaineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomaineMaxAggregateInputType
  }

  export type GetDomaineAggregateType<T extends DomaineAggregateArgs> = {
        [P in keyof T & keyof AggregateDomaine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomaine[P]>
      : GetScalarType<T[P], AggregateDomaine[P]>
  }




  export type DomaineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomaineWhereInput
    orderBy?: DomaineOrderByWithAggregationInput | DomaineOrderByWithAggregationInput[]
    by: DomaineScalarFieldEnum[] | DomaineScalarFieldEnum
    having?: DomaineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomaineCountAggregateInputType | true
    _avg?: DomaineAvgAggregateInputType
    _sum?: DomaineSumAggregateInputType
    _min?: DomaineMinAggregateInputType
    _max?: DomaineMaxAggregateInputType
  }

  export type DomaineGroupByOutputType = {
    id: number
    nom: string
    frontieres: string | null
    richessesOr: Decimal | null
    ressources: string | null
    _count: DomaineCountAggregateOutputType | null
    _avg: DomaineAvgAggregateOutputType | null
    _sum: DomaineSumAggregateOutputType | null
    _min: DomaineMinAggregateOutputType | null
    _max: DomaineMaxAggregateOutputType | null
  }

  type GetDomaineGroupByPayload<T extends DomaineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomaineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomaineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomaineGroupByOutputType[P]>
            : GetScalarType<T[P], DomaineGroupByOutputType[P]>
        }
      >
    >


  export type DomaineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    frontieres?: boolean
    richessesOr?: boolean
    ressources?: boolean
    villages?: boolean | Domaine$villagesArgs<ExtArgs>
    titres?: boolean | Domaine$titresArgs<ExtArgs>
    armees?: boolean | Domaine$armeesArgs<ExtArgs>
    relationsSource?: boolean | Domaine$relationsSourceArgs<ExtArgs>
    relationsCible?: boolean | Domaine$relationsCibleArgs<ExtArgs>
    lois?: boolean | Domaine$loisArgs<ExtArgs>
    _count?: boolean | DomaineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domaine"]>

  export type DomaineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    frontieres?: boolean
    richessesOr?: boolean
    ressources?: boolean
  }, ExtArgs["result"]["domaine"]>

  export type DomaineSelectScalar = {
    id?: boolean
    nom?: boolean
    frontieres?: boolean
    richessesOr?: boolean
    ressources?: boolean
  }

  export type DomaineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    villages?: boolean | Domaine$villagesArgs<ExtArgs>
    titres?: boolean | Domaine$titresArgs<ExtArgs>
    armees?: boolean | Domaine$armeesArgs<ExtArgs>
    relationsSource?: boolean | Domaine$relationsSourceArgs<ExtArgs>
    relationsCible?: boolean | Domaine$relationsCibleArgs<ExtArgs>
    lois?: boolean | Domaine$loisArgs<ExtArgs>
    _count?: boolean | DomaineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomaineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DomainePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Domaine"
    objects: {
      villages: Prisma.$VillagePayload<ExtArgs>[]
      titres: Prisma.$PersonnageTitrePayload<ExtArgs>[]
      armees: Prisma.$ArmeePayload<ExtArgs>[]
      relationsSource: Prisma.$RelationDiplomatiquePayload<ExtArgs>[]
      relationsCible: Prisma.$RelationDiplomatiquePayload<ExtArgs>[]
      lois: Prisma.$LoiTerritoirePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      frontieres: string | null
      richessesOr: Prisma.Decimal | null
      ressources: string | null
    }, ExtArgs["result"]["domaine"]>
    composites: {}
  }

  type DomaineGetPayload<S extends boolean | null | undefined | DomaineDefaultArgs> = $Result.GetResult<Prisma.$DomainePayload, S>

  type DomaineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DomaineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DomaineCountAggregateInputType | true
    }

  export interface DomaineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Domaine'], meta: { name: 'Domaine' } }
    /**
     * Find zero or one Domaine that matches the filter.
     * @param {DomaineFindUniqueArgs} args - Arguments to find a Domaine
     * @example
     * // Get one Domaine
     * const domaine = await prisma.domaine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomaineFindUniqueArgs>(args: SelectSubset<T, DomaineFindUniqueArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Domaine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DomaineFindUniqueOrThrowArgs} args - Arguments to find a Domaine
     * @example
     * // Get one Domaine
     * const domaine = await prisma.domaine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomaineFindUniqueOrThrowArgs>(args: SelectSubset<T, DomaineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Domaine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineFindFirstArgs} args - Arguments to find a Domaine
     * @example
     * // Get one Domaine
     * const domaine = await prisma.domaine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomaineFindFirstArgs>(args?: SelectSubset<T, DomaineFindFirstArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Domaine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineFindFirstOrThrowArgs} args - Arguments to find a Domaine
     * @example
     * // Get one Domaine
     * const domaine = await prisma.domaine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomaineFindFirstOrThrowArgs>(args?: SelectSubset<T, DomaineFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Domaines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Domaines
     * const domaines = await prisma.domaine.findMany()
     * 
     * // Get first 10 Domaines
     * const domaines = await prisma.domaine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domaineWithIdOnly = await prisma.domaine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomaineFindManyArgs>(args?: SelectSubset<T, DomaineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Domaine.
     * @param {DomaineCreateArgs} args - Arguments to create a Domaine.
     * @example
     * // Create one Domaine
     * const Domaine = await prisma.domaine.create({
     *   data: {
     *     // ... data to create a Domaine
     *   }
     * })
     * 
     */
    create<T extends DomaineCreateArgs>(args: SelectSubset<T, DomaineCreateArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Domaines.
     * @param {DomaineCreateManyArgs} args - Arguments to create many Domaines.
     * @example
     * // Create many Domaines
     * const domaine = await prisma.domaine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomaineCreateManyArgs>(args?: SelectSubset<T, DomaineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Domaines and returns the data saved in the database.
     * @param {DomaineCreateManyAndReturnArgs} args - Arguments to create many Domaines.
     * @example
     * // Create many Domaines
     * const domaine = await prisma.domaine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Domaines and only return the `id`
     * const domaineWithIdOnly = await prisma.domaine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomaineCreateManyAndReturnArgs>(args?: SelectSubset<T, DomaineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Domaine.
     * @param {DomaineDeleteArgs} args - Arguments to delete one Domaine.
     * @example
     * // Delete one Domaine
     * const Domaine = await prisma.domaine.delete({
     *   where: {
     *     // ... filter to delete one Domaine
     *   }
     * })
     * 
     */
    delete<T extends DomaineDeleteArgs>(args: SelectSubset<T, DomaineDeleteArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Domaine.
     * @param {DomaineUpdateArgs} args - Arguments to update one Domaine.
     * @example
     * // Update one Domaine
     * const domaine = await prisma.domaine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomaineUpdateArgs>(args: SelectSubset<T, DomaineUpdateArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Domaines.
     * @param {DomaineDeleteManyArgs} args - Arguments to filter Domaines to delete.
     * @example
     * // Delete a few Domaines
     * const { count } = await prisma.domaine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomaineDeleteManyArgs>(args?: SelectSubset<T, DomaineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domaines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Domaines
     * const domaine = await prisma.domaine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomaineUpdateManyArgs>(args: SelectSubset<T, DomaineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Domaine.
     * @param {DomaineUpsertArgs} args - Arguments to update or create a Domaine.
     * @example
     * // Update or create a Domaine
     * const domaine = await prisma.domaine.upsert({
     *   create: {
     *     // ... data to create a Domaine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Domaine we want to update
     *   }
     * })
     */
    upsert<T extends DomaineUpsertArgs>(args: SelectSubset<T, DomaineUpsertArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Domaines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineCountArgs} args - Arguments to filter Domaines to count.
     * @example
     * // Count the number of Domaines
     * const count = await prisma.domaine.count({
     *   where: {
     *     // ... the filter for the Domaines we want to count
     *   }
     * })
    **/
    count<T extends DomaineCountArgs>(
      args?: Subset<T, DomaineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomaineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Domaine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomaineAggregateArgs>(args: Subset<T, DomaineAggregateArgs>): Prisma.PrismaPromise<GetDomaineAggregateType<T>>

    /**
     * Group by Domaine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomaineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomaineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomaineGroupByArgs['orderBy'] }
        : { orderBy?: DomaineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomaineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomaineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Domaine model
   */
  readonly fields: DomaineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Domaine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomaineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    villages<T extends Domaine$villagesArgs<ExtArgs> = {}>(args?: Subset<T, Domaine$villagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "findMany"> | Null>
    titres<T extends Domaine$titresArgs<ExtArgs> = {}>(args?: Subset<T, Domaine$titresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "findMany"> | Null>
    armees<T extends Domaine$armeesArgs<ExtArgs> = {}>(args?: Subset<T, Domaine$armeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "findMany"> | Null>
    relationsSource<T extends Domaine$relationsSourceArgs<ExtArgs> = {}>(args?: Subset<T, Domaine$relationsSourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "findMany"> | Null>
    relationsCible<T extends Domaine$relationsCibleArgs<ExtArgs> = {}>(args?: Subset<T, Domaine$relationsCibleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "findMany"> | Null>
    lois<T extends Domaine$loisArgs<ExtArgs> = {}>(args?: Subset<T, Domaine$loisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Domaine model
   */ 
  interface DomaineFieldRefs {
    readonly id: FieldRef<"Domaine", 'Int'>
    readonly nom: FieldRef<"Domaine", 'String'>
    readonly frontieres: FieldRef<"Domaine", 'String'>
    readonly richessesOr: FieldRef<"Domaine", 'Decimal'>
    readonly ressources: FieldRef<"Domaine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Domaine findUnique
   */
  export type DomaineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter, which Domaine to fetch.
     */
    where: DomaineWhereUniqueInput
  }

  /**
   * Domaine findUniqueOrThrow
   */
  export type DomaineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter, which Domaine to fetch.
     */
    where: DomaineWhereUniqueInput
  }

  /**
   * Domaine findFirst
   */
  export type DomaineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter, which Domaine to fetch.
     */
    where?: DomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domaines to fetch.
     */
    orderBy?: DomaineOrderByWithRelationInput | DomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domaines.
     */
    cursor?: DomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domaines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domaines.
     */
    distinct?: DomaineScalarFieldEnum | DomaineScalarFieldEnum[]
  }

  /**
   * Domaine findFirstOrThrow
   */
  export type DomaineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter, which Domaine to fetch.
     */
    where?: DomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domaines to fetch.
     */
    orderBy?: DomaineOrderByWithRelationInput | DomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domaines.
     */
    cursor?: DomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domaines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domaines.
     */
    distinct?: DomaineScalarFieldEnum | DomaineScalarFieldEnum[]
  }

  /**
   * Domaine findMany
   */
  export type DomaineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter, which Domaines to fetch.
     */
    where?: DomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domaines to fetch.
     */
    orderBy?: DomaineOrderByWithRelationInput | DomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Domaines.
     */
    cursor?: DomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domaines.
     */
    skip?: number
    distinct?: DomaineScalarFieldEnum | DomaineScalarFieldEnum[]
  }

  /**
   * Domaine create
   */
  export type DomaineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * The data needed to create a Domaine.
     */
    data: XOR<DomaineCreateInput, DomaineUncheckedCreateInput>
  }

  /**
   * Domaine createMany
   */
  export type DomaineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Domaines.
     */
    data: DomaineCreateManyInput | DomaineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Domaine createManyAndReturn
   */
  export type DomaineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Domaines.
     */
    data: DomaineCreateManyInput | DomaineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Domaine update
   */
  export type DomaineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * The data needed to update a Domaine.
     */
    data: XOR<DomaineUpdateInput, DomaineUncheckedUpdateInput>
    /**
     * Choose, which Domaine to update.
     */
    where: DomaineWhereUniqueInput
  }

  /**
   * Domaine updateMany
   */
  export type DomaineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Domaines.
     */
    data: XOR<DomaineUpdateManyMutationInput, DomaineUncheckedUpdateManyInput>
    /**
     * Filter which Domaines to update
     */
    where?: DomaineWhereInput
  }

  /**
   * Domaine upsert
   */
  export type DomaineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * The filter to search for the Domaine to update in case it exists.
     */
    where: DomaineWhereUniqueInput
    /**
     * In case the Domaine found by the `where` argument doesn't exist, create a new Domaine with this data.
     */
    create: XOR<DomaineCreateInput, DomaineUncheckedCreateInput>
    /**
     * In case the Domaine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomaineUpdateInput, DomaineUncheckedUpdateInput>
  }

  /**
   * Domaine delete
   */
  export type DomaineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    /**
     * Filter which Domaine to delete.
     */
    where: DomaineWhereUniqueInput
  }

  /**
   * Domaine deleteMany
   */
  export type DomaineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domaines to delete
     */
    where?: DomaineWhereInput
  }

  /**
   * Domaine.villages
   */
  export type Domaine$villagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    where?: VillageWhereInput
    orderBy?: VillageOrderByWithRelationInput | VillageOrderByWithRelationInput[]
    cursor?: VillageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VillageScalarFieldEnum | VillageScalarFieldEnum[]
  }

  /**
   * Domaine.titres
   */
  export type Domaine$titresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    where?: PersonnageTitreWhereInput
    orderBy?: PersonnageTitreOrderByWithRelationInput | PersonnageTitreOrderByWithRelationInput[]
    cursor?: PersonnageTitreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageTitreScalarFieldEnum | PersonnageTitreScalarFieldEnum[]
  }

  /**
   * Domaine.armees
   */
  export type Domaine$armeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    where?: ArmeeWhereInput
    orderBy?: ArmeeOrderByWithRelationInput | ArmeeOrderByWithRelationInput[]
    cursor?: ArmeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArmeeScalarFieldEnum | ArmeeScalarFieldEnum[]
  }

  /**
   * Domaine.relationsSource
   */
  export type Domaine$relationsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    where?: RelationDiplomatiqueWhereInput
    orderBy?: RelationDiplomatiqueOrderByWithRelationInput | RelationDiplomatiqueOrderByWithRelationInput[]
    cursor?: RelationDiplomatiqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationDiplomatiqueScalarFieldEnum | RelationDiplomatiqueScalarFieldEnum[]
  }

  /**
   * Domaine.relationsCible
   */
  export type Domaine$relationsCibleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    where?: RelationDiplomatiqueWhereInput
    orderBy?: RelationDiplomatiqueOrderByWithRelationInput | RelationDiplomatiqueOrderByWithRelationInput[]
    cursor?: RelationDiplomatiqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationDiplomatiqueScalarFieldEnum | RelationDiplomatiqueScalarFieldEnum[]
  }

  /**
   * Domaine.lois
   */
  export type Domaine$loisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    where?: LoiTerritoireWhereInput
    orderBy?: LoiTerritoireOrderByWithRelationInput | LoiTerritoireOrderByWithRelationInput[]
    cursor?: LoiTerritoireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoiTerritoireScalarFieldEnum | LoiTerritoireScalarFieldEnum[]
  }

  /**
   * Domaine without action
   */
  export type DomaineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
  }


  /**
   * Model Titre
   */

  export type AggregateTitre = {
    _count: TitreCountAggregateOutputType | null
    _avg: TitreAvgAggregateOutputType | null
    _sum: TitreSumAggregateOutputType | null
    _min: TitreMinAggregateOutputType | null
    _max: TitreMaxAggregateOutputType | null
  }

  export type TitreAvgAggregateOutputType = {
    id: number | null
  }

  export type TitreSumAggregateOutputType = {
    id: number | null
  }

  export type TitreMinAggregateOutputType = {
    id: number | null
    libelle: string | null
  }

  export type TitreMaxAggregateOutputType = {
    id: number | null
    libelle: string | null
  }

  export type TitreCountAggregateOutputType = {
    id: number
    libelle: number
    _all: number
  }


  export type TitreAvgAggregateInputType = {
    id?: true
  }

  export type TitreSumAggregateInputType = {
    id?: true
  }

  export type TitreMinAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type TitreMaxAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type TitreCountAggregateInputType = {
    id?: true
    libelle?: true
    _all?: true
  }

  export type TitreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Titre to aggregate.
     */
    where?: TitreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Titres to fetch.
     */
    orderBy?: TitreOrderByWithRelationInput | TitreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TitreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Titres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Titres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Titres
    **/
    _count?: true | TitreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TitreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TitreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TitreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TitreMaxAggregateInputType
  }

  export type GetTitreAggregateType<T extends TitreAggregateArgs> = {
        [P in keyof T & keyof AggregateTitre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitre[P]>
      : GetScalarType<T[P], AggregateTitre[P]>
  }




  export type TitreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TitreWhereInput
    orderBy?: TitreOrderByWithAggregationInput | TitreOrderByWithAggregationInput[]
    by: TitreScalarFieldEnum[] | TitreScalarFieldEnum
    having?: TitreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TitreCountAggregateInputType | true
    _avg?: TitreAvgAggregateInputType
    _sum?: TitreSumAggregateInputType
    _min?: TitreMinAggregateInputType
    _max?: TitreMaxAggregateInputType
  }

  export type TitreGroupByOutputType = {
    id: number
    libelle: string
    _count: TitreCountAggregateOutputType | null
    _avg: TitreAvgAggregateOutputType | null
    _sum: TitreSumAggregateOutputType | null
    _min: TitreMinAggregateOutputType | null
    _max: TitreMaxAggregateOutputType | null
  }

  type GetTitreGroupByPayload<T extends TitreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TitreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TitreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TitreGroupByOutputType[P]>
            : GetScalarType<T[P], TitreGroupByOutputType[P]>
        }
      >
    >


  export type TitreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    attributions?: boolean | Titre$attributionsArgs<ExtArgs>
    _count?: boolean | TitreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["titre"]>

  export type TitreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
  }, ExtArgs["result"]["titre"]>

  export type TitreSelectScalar = {
    id?: boolean
    libelle?: boolean
  }

  export type TitreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributions?: boolean | Titre$attributionsArgs<ExtArgs>
    _count?: boolean | TitreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TitreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TitrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Titre"
    objects: {
      attributions: Prisma.$PersonnageTitrePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      libelle: string
    }, ExtArgs["result"]["titre"]>
    composites: {}
  }

  type TitreGetPayload<S extends boolean | null | undefined | TitreDefaultArgs> = $Result.GetResult<Prisma.$TitrePayload, S>

  type TitreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TitreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TitreCountAggregateInputType | true
    }

  export interface TitreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Titre'], meta: { name: 'Titre' } }
    /**
     * Find zero or one Titre that matches the filter.
     * @param {TitreFindUniqueArgs} args - Arguments to find a Titre
     * @example
     * // Get one Titre
     * const titre = await prisma.titre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TitreFindUniqueArgs>(args: SelectSubset<T, TitreFindUniqueArgs<ExtArgs>>): Prisma__TitreClient<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Titre that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TitreFindUniqueOrThrowArgs} args - Arguments to find a Titre
     * @example
     * // Get one Titre
     * const titre = await prisma.titre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TitreFindUniqueOrThrowArgs>(args: SelectSubset<T, TitreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TitreClient<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Titre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitreFindFirstArgs} args - Arguments to find a Titre
     * @example
     * // Get one Titre
     * const titre = await prisma.titre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TitreFindFirstArgs>(args?: SelectSubset<T, TitreFindFirstArgs<ExtArgs>>): Prisma__TitreClient<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Titre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitreFindFirstOrThrowArgs} args - Arguments to find a Titre
     * @example
     * // Get one Titre
     * const titre = await prisma.titre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TitreFindFirstOrThrowArgs>(args?: SelectSubset<T, TitreFindFirstOrThrowArgs<ExtArgs>>): Prisma__TitreClient<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Titres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titres
     * const titres = await prisma.titre.findMany()
     * 
     * // Get first 10 Titres
     * const titres = await prisma.titre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const titreWithIdOnly = await prisma.titre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TitreFindManyArgs>(args?: SelectSubset<T, TitreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Titre.
     * @param {TitreCreateArgs} args - Arguments to create a Titre.
     * @example
     * // Create one Titre
     * const Titre = await prisma.titre.create({
     *   data: {
     *     // ... data to create a Titre
     *   }
     * })
     * 
     */
    create<T extends TitreCreateArgs>(args: SelectSubset<T, TitreCreateArgs<ExtArgs>>): Prisma__TitreClient<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Titres.
     * @param {TitreCreateManyArgs} args - Arguments to create many Titres.
     * @example
     * // Create many Titres
     * const titre = await prisma.titre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TitreCreateManyArgs>(args?: SelectSubset<T, TitreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Titres and returns the data saved in the database.
     * @param {TitreCreateManyAndReturnArgs} args - Arguments to create many Titres.
     * @example
     * // Create many Titres
     * const titre = await prisma.titre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Titres and only return the `id`
     * const titreWithIdOnly = await prisma.titre.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TitreCreateManyAndReturnArgs>(args?: SelectSubset<T, TitreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Titre.
     * @param {TitreDeleteArgs} args - Arguments to delete one Titre.
     * @example
     * // Delete one Titre
     * const Titre = await prisma.titre.delete({
     *   where: {
     *     // ... filter to delete one Titre
     *   }
     * })
     * 
     */
    delete<T extends TitreDeleteArgs>(args: SelectSubset<T, TitreDeleteArgs<ExtArgs>>): Prisma__TitreClient<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Titre.
     * @param {TitreUpdateArgs} args - Arguments to update one Titre.
     * @example
     * // Update one Titre
     * const titre = await prisma.titre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TitreUpdateArgs>(args: SelectSubset<T, TitreUpdateArgs<ExtArgs>>): Prisma__TitreClient<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Titres.
     * @param {TitreDeleteManyArgs} args - Arguments to filter Titres to delete.
     * @example
     * // Delete a few Titres
     * const { count } = await prisma.titre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TitreDeleteManyArgs>(args?: SelectSubset<T, TitreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titres
     * const titre = await prisma.titre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TitreUpdateManyArgs>(args: SelectSubset<T, TitreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Titre.
     * @param {TitreUpsertArgs} args - Arguments to update or create a Titre.
     * @example
     * // Update or create a Titre
     * const titre = await prisma.titre.upsert({
     *   create: {
     *     // ... data to create a Titre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titre we want to update
     *   }
     * })
     */
    upsert<T extends TitreUpsertArgs>(args: SelectSubset<T, TitreUpsertArgs<ExtArgs>>): Prisma__TitreClient<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Titres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitreCountArgs} args - Arguments to filter Titres to count.
     * @example
     * // Count the number of Titres
     * const count = await prisma.titre.count({
     *   where: {
     *     // ... the filter for the Titres we want to count
     *   }
     * })
    **/
    count<T extends TitreCountArgs>(
      args?: Subset<T, TitreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TitreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TitreAggregateArgs>(args: Subset<T, TitreAggregateArgs>): Prisma.PrismaPromise<GetTitreAggregateType<T>>

    /**
     * Group by Titre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TitreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TitreGroupByArgs['orderBy'] }
        : { orderBy?: TitreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TitreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Titre model
   */
  readonly fields: TitreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Titre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TitreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attributions<T extends Titre$attributionsArgs<ExtArgs> = {}>(args?: Subset<T, Titre$attributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Titre model
   */ 
  interface TitreFieldRefs {
    readonly id: FieldRef<"Titre", 'Int'>
    readonly libelle: FieldRef<"Titre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Titre findUnique
   */
  export type TitreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TitreInclude<ExtArgs> | null
    /**
     * Filter, which Titre to fetch.
     */
    where: TitreWhereUniqueInput
  }

  /**
   * Titre findUniqueOrThrow
   */
  export type TitreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TitreInclude<ExtArgs> | null
    /**
     * Filter, which Titre to fetch.
     */
    where: TitreWhereUniqueInput
  }

  /**
   * Titre findFirst
   */
  export type TitreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TitreInclude<ExtArgs> | null
    /**
     * Filter, which Titre to fetch.
     */
    where?: TitreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Titres to fetch.
     */
    orderBy?: TitreOrderByWithRelationInput | TitreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Titres.
     */
    cursor?: TitreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Titres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Titres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Titres.
     */
    distinct?: TitreScalarFieldEnum | TitreScalarFieldEnum[]
  }

  /**
   * Titre findFirstOrThrow
   */
  export type TitreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TitreInclude<ExtArgs> | null
    /**
     * Filter, which Titre to fetch.
     */
    where?: TitreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Titres to fetch.
     */
    orderBy?: TitreOrderByWithRelationInput | TitreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Titres.
     */
    cursor?: TitreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Titres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Titres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Titres.
     */
    distinct?: TitreScalarFieldEnum | TitreScalarFieldEnum[]
  }

  /**
   * Titre findMany
   */
  export type TitreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TitreInclude<ExtArgs> | null
    /**
     * Filter, which Titres to fetch.
     */
    where?: TitreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Titres to fetch.
     */
    orderBy?: TitreOrderByWithRelationInput | TitreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Titres.
     */
    cursor?: TitreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Titres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Titres.
     */
    skip?: number
    distinct?: TitreScalarFieldEnum | TitreScalarFieldEnum[]
  }

  /**
   * Titre create
   */
  export type TitreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TitreInclude<ExtArgs> | null
    /**
     * The data needed to create a Titre.
     */
    data: XOR<TitreCreateInput, TitreUncheckedCreateInput>
  }

  /**
   * Titre createMany
   */
  export type TitreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Titres.
     */
    data: TitreCreateManyInput | TitreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Titre createManyAndReturn
   */
  export type TitreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Titres.
     */
    data: TitreCreateManyInput | TitreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Titre update
   */
  export type TitreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TitreInclude<ExtArgs> | null
    /**
     * The data needed to update a Titre.
     */
    data: XOR<TitreUpdateInput, TitreUncheckedUpdateInput>
    /**
     * Choose, which Titre to update.
     */
    where: TitreWhereUniqueInput
  }

  /**
   * Titre updateMany
   */
  export type TitreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Titres.
     */
    data: XOR<TitreUpdateManyMutationInput, TitreUncheckedUpdateManyInput>
    /**
     * Filter which Titres to update
     */
    where?: TitreWhereInput
  }

  /**
   * Titre upsert
   */
  export type TitreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TitreInclude<ExtArgs> | null
    /**
     * The filter to search for the Titre to update in case it exists.
     */
    where: TitreWhereUniqueInput
    /**
     * In case the Titre found by the `where` argument doesn't exist, create a new Titre with this data.
     */
    create: XOR<TitreCreateInput, TitreUncheckedCreateInput>
    /**
     * In case the Titre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TitreUpdateInput, TitreUncheckedUpdateInput>
  }

  /**
   * Titre delete
   */
  export type TitreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TitreInclude<ExtArgs> | null
    /**
     * Filter which Titre to delete.
     */
    where: TitreWhereUniqueInput
  }

  /**
   * Titre deleteMany
   */
  export type TitreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Titres to delete
     */
    where?: TitreWhereInput
  }

  /**
   * Titre.attributions
   */
  export type Titre$attributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    where?: PersonnageTitreWhereInput
    orderBy?: PersonnageTitreOrderByWithRelationInput | PersonnageTitreOrderByWithRelationInput[]
    cursor?: PersonnageTitreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageTitreScalarFieldEnum | PersonnageTitreScalarFieldEnum[]
  }

  /**
   * Titre without action
   */
  export type TitreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Titre
     */
    select?: TitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TitreInclude<ExtArgs> | null
  }


  /**
   * Model PersonnageTitre
   */

  export type AggregatePersonnageTitre = {
    _count: PersonnageTitreCountAggregateOutputType | null
    _avg: PersonnageTitreAvgAggregateOutputType | null
    _sum: PersonnageTitreSumAggregateOutputType | null
    _min: PersonnageTitreMinAggregateOutputType | null
    _max: PersonnageTitreMaxAggregateOutputType | null
  }

  export type PersonnageTitreAvgAggregateOutputType = {
    id: number | null
    personnageId: number | null
    titreId: number | null
    domaineId: number | null
    ligneeId: number | null
  }

  export type PersonnageTitreSumAggregateOutputType = {
    id: number | null
    personnageId: number | null
    titreId: number | null
    domaineId: number | null
    ligneeId: number | null
  }

  export type PersonnageTitreMinAggregateOutputType = {
    id: number | null
    dateDebut: Date | null
    dateFin: Date | null
    estActif: boolean | null
    personnageId: number | null
    titreId: number | null
    domaineId: number | null
    ligneeId: number | null
  }

  export type PersonnageTitreMaxAggregateOutputType = {
    id: number | null
    dateDebut: Date | null
    dateFin: Date | null
    estActif: boolean | null
    personnageId: number | null
    titreId: number | null
    domaineId: number | null
    ligneeId: number | null
  }

  export type PersonnageTitreCountAggregateOutputType = {
    id: number
    dateDebut: number
    dateFin: number
    estActif: number
    personnageId: number
    titreId: number
    domaineId: number
    ligneeId: number
    _all: number
  }


  export type PersonnageTitreAvgAggregateInputType = {
    id?: true
    personnageId?: true
    titreId?: true
    domaineId?: true
    ligneeId?: true
  }

  export type PersonnageTitreSumAggregateInputType = {
    id?: true
    personnageId?: true
    titreId?: true
    domaineId?: true
    ligneeId?: true
  }

  export type PersonnageTitreMinAggregateInputType = {
    id?: true
    dateDebut?: true
    dateFin?: true
    estActif?: true
    personnageId?: true
    titreId?: true
    domaineId?: true
    ligneeId?: true
  }

  export type PersonnageTitreMaxAggregateInputType = {
    id?: true
    dateDebut?: true
    dateFin?: true
    estActif?: true
    personnageId?: true
    titreId?: true
    domaineId?: true
    ligneeId?: true
  }

  export type PersonnageTitreCountAggregateInputType = {
    id?: true
    dateDebut?: true
    dateFin?: true
    estActif?: true
    personnageId?: true
    titreId?: true
    domaineId?: true
    ligneeId?: true
    _all?: true
  }

  export type PersonnageTitreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnageTitre to aggregate.
     */
    where?: PersonnageTitreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageTitres to fetch.
     */
    orderBy?: PersonnageTitreOrderByWithRelationInput | PersonnageTitreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnageTitreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageTitres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageTitres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonnageTitres
    **/
    _count?: true | PersonnageTitreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonnageTitreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonnageTitreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnageTitreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnageTitreMaxAggregateInputType
  }

  export type GetPersonnageTitreAggregateType<T extends PersonnageTitreAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnageTitre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnageTitre[P]>
      : GetScalarType<T[P], AggregatePersonnageTitre[P]>
  }




  export type PersonnageTitreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageTitreWhereInput
    orderBy?: PersonnageTitreOrderByWithAggregationInput | PersonnageTitreOrderByWithAggregationInput[]
    by: PersonnageTitreScalarFieldEnum[] | PersonnageTitreScalarFieldEnum
    having?: PersonnageTitreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnageTitreCountAggregateInputType | true
    _avg?: PersonnageTitreAvgAggregateInputType
    _sum?: PersonnageTitreSumAggregateInputType
    _min?: PersonnageTitreMinAggregateInputType
    _max?: PersonnageTitreMaxAggregateInputType
  }

  export type PersonnageTitreGroupByOutputType = {
    id: number
    dateDebut: Date | null
    dateFin: Date | null
    estActif: boolean
    personnageId: number
    titreId: number
    domaineId: number | null
    ligneeId: number | null
    _count: PersonnageTitreCountAggregateOutputType | null
    _avg: PersonnageTitreAvgAggregateOutputType | null
    _sum: PersonnageTitreSumAggregateOutputType | null
    _min: PersonnageTitreMinAggregateOutputType | null
    _max: PersonnageTitreMaxAggregateOutputType | null
  }

  type GetPersonnageTitreGroupByPayload<T extends PersonnageTitreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnageTitreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnageTitreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnageTitreGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnageTitreGroupByOutputType[P]>
        }
      >
    >


  export type PersonnageTitreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    estActif?: boolean
    personnageId?: boolean
    titreId?: boolean
    domaineId?: boolean
    ligneeId?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    titre?: boolean | TitreDefaultArgs<ExtArgs>
    domaine?: boolean | PersonnageTitre$domaineArgs<ExtArgs>
    lignee?: boolean | PersonnageTitre$ligneeArgs<ExtArgs>
  }, ExtArgs["result"]["personnageTitre"]>

  export type PersonnageTitreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    estActif?: boolean
    personnageId?: boolean
    titreId?: boolean
    domaineId?: boolean
    ligneeId?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    titre?: boolean | TitreDefaultArgs<ExtArgs>
    domaine?: boolean | PersonnageTitre$domaineArgs<ExtArgs>
    lignee?: boolean | PersonnageTitre$ligneeArgs<ExtArgs>
  }, ExtArgs["result"]["personnageTitre"]>

  export type PersonnageTitreSelectScalar = {
    id?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    estActif?: boolean
    personnageId?: boolean
    titreId?: boolean
    domaineId?: boolean
    ligneeId?: boolean
  }

  export type PersonnageTitreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    titre?: boolean | TitreDefaultArgs<ExtArgs>
    domaine?: boolean | PersonnageTitre$domaineArgs<ExtArgs>
    lignee?: boolean | PersonnageTitre$ligneeArgs<ExtArgs>
  }
  export type PersonnageTitreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    titre?: boolean | TitreDefaultArgs<ExtArgs>
    domaine?: boolean | PersonnageTitre$domaineArgs<ExtArgs>
    lignee?: boolean | PersonnageTitre$ligneeArgs<ExtArgs>
  }

  export type $PersonnageTitrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonnageTitre"
    objects: {
      personnage: Prisma.$PersonnagePayload<ExtArgs>
      titre: Prisma.$TitrePayload<ExtArgs>
      domaine: Prisma.$DomainePayload<ExtArgs> | null
      lignee: Prisma.$LigneePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dateDebut: Date | null
      dateFin: Date | null
      estActif: boolean
      personnageId: number
      titreId: number
      domaineId: number | null
      ligneeId: number | null
    }, ExtArgs["result"]["personnageTitre"]>
    composites: {}
  }

  type PersonnageTitreGetPayload<S extends boolean | null | undefined | PersonnageTitreDefaultArgs> = $Result.GetResult<Prisma.$PersonnageTitrePayload, S>

  type PersonnageTitreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonnageTitreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonnageTitreCountAggregateInputType | true
    }

  export interface PersonnageTitreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonnageTitre'], meta: { name: 'PersonnageTitre' } }
    /**
     * Find zero or one PersonnageTitre that matches the filter.
     * @param {PersonnageTitreFindUniqueArgs} args - Arguments to find a PersonnageTitre
     * @example
     * // Get one PersonnageTitre
     * const personnageTitre = await prisma.personnageTitre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnageTitreFindUniqueArgs>(args: SelectSubset<T, PersonnageTitreFindUniqueArgs<ExtArgs>>): Prisma__PersonnageTitreClient<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PersonnageTitre that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonnageTitreFindUniqueOrThrowArgs} args - Arguments to find a PersonnageTitre
     * @example
     * // Get one PersonnageTitre
     * const personnageTitre = await prisma.personnageTitre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnageTitreFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnageTitreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnageTitreClient<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PersonnageTitre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageTitreFindFirstArgs} args - Arguments to find a PersonnageTitre
     * @example
     * // Get one PersonnageTitre
     * const personnageTitre = await prisma.personnageTitre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnageTitreFindFirstArgs>(args?: SelectSubset<T, PersonnageTitreFindFirstArgs<ExtArgs>>): Prisma__PersonnageTitreClient<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PersonnageTitre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageTitreFindFirstOrThrowArgs} args - Arguments to find a PersonnageTitre
     * @example
     * // Get one PersonnageTitre
     * const personnageTitre = await prisma.personnageTitre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnageTitreFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnageTitreFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnageTitreClient<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PersonnageTitres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageTitreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonnageTitres
     * const personnageTitres = await prisma.personnageTitre.findMany()
     * 
     * // Get first 10 PersonnageTitres
     * const personnageTitres = await prisma.personnageTitre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personnageTitreWithIdOnly = await prisma.personnageTitre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonnageTitreFindManyArgs>(args?: SelectSubset<T, PersonnageTitreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PersonnageTitre.
     * @param {PersonnageTitreCreateArgs} args - Arguments to create a PersonnageTitre.
     * @example
     * // Create one PersonnageTitre
     * const PersonnageTitre = await prisma.personnageTitre.create({
     *   data: {
     *     // ... data to create a PersonnageTitre
     *   }
     * })
     * 
     */
    create<T extends PersonnageTitreCreateArgs>(args: SelectSubset<T, PersonnageTitreCreateArgs<ExtArgs>>): Prisma__PersonnageTitreClient<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PersonnageTitres.
     * @param {PersonnageTitreCreateManyArgs} args - Arguments to create many PersonnageTitres.
     * @example
     * // Create many PersonnageTitres
     * const personnageTitre = await prisma.personnageTitre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnageTitreCreateManyArgs>(args?: SelectSubset<T, PersonnageTitreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonnageTitres and returns the data saved in the database.
     * @param {PersonnageTitreCreateManyAndReturnArgs} args - Arguments to create many PersonnageTitres.
     * @example
     * // Create many PersonnageTitres
     * const personnageTitre = await prisma.personnageTitre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonnageTitres and only return the `id`
     * const personnageTitreWithIdOnly = await prisma.personnageTitre.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonnageTitreCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonnageTitreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PersonnageTitre.
     * @param {PersonnageTitreDeleteArgs} args - Arguments to delete one PersonnageTitre.
     * @example
     * // Delete one PersonnageTitre
     * const PersonnageTitre = await prisma.personnageTitre.delete({
     *   where: {
     *     // ... filter to delete one PersonnageTitre
     *   }
     * })
     * 
     */
    delete<T extends PersonnageTitreDeleteArgs>(args: SelectSubset<T, PersonnageTitreDeleteArgs<ExtArgs>>): Prisma__PersonnageTitreClient<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PersonnageTitre.
     * @param {PersonnageTitreUpdateArgs} args - Arguments to update one PersonnageTitre.
     * @example
     * // Update one PersonnageTitre
     * const personnageTitre = await prisma.personnageTitre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnageTitreUpdateArgs>(args: SelectSubset<T, PersonnageTitreUpdateArgs<ExtArgs>>): Prisma__PersonnageTitreClient<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PersonnageTitres.
     * @param {PersonnageTitreDeleteManyArgs} args - Arguments to filter PersonnageTitres to delete.
     * @example
     * // Delete a few PersonnageTitres
     * const { count } = await prisma.personnageTitre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnageTitreDeleteManyArgs>(args?: SelectSubset<T, PersonnageTitreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonnageTitres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageTitreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonnageTitres
     * const personnageTitre = await prisma.personnageTitre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnageTitreUpdateManyArgs>(args: SelectSubset<T, PersonnageTitreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonnageTitre.
     * @param {PersonnageTitreUpsertArgs} args - Arguments to update or create a PersonnageTitre.
     * @example
     * // Update or create a PersonnageTitre
     * const personnageTitre = await prisma.personnageTitre.upsert({
     *   create: {
     *     // ... data to create a PersonnageTitre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonnageTitre we want to update
     *   }
     * })
     */
    upsert<T extends PersonnageTitreUpsertArgs>(args: SelectSubset<T, PersonnageTitreUpsertArgs<ExtArgs>>): Prisma__PersonnageTitreClient<$Result.GetResult<Prisma.$PersonnageTitrePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PersonnageTitres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageTitreCountArgs} args - Arguments to filter PersonnageTitres to count.
     * @example
     * // Count the number of PersonnageTitres
     * const count = await prisma.personnageTitre.count({
     *   where: {
     *     // ... the filter for the PersonnageTitres we want to count
     *   }
     * })
    **/
    count<T extends PersonnageTitreCountArgs>(
      args?: Subset<T, PersonnageTitreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnageTitreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonnageTitre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageTitreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnageTitreAggregateArgs>(args: Subset<T, PersonnageTitreAggregateArgs>): Prisma.PrismaPromise<GetPersonnageTitreAggregateType<T>>

    /**
     * Group by PersonnageTitre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageTitreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnageTitreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnageTitreGroupByArgs['orderBy'] }
        : { orderBy?: PersonnageTitreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnageTitreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnageTitreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonnageTitre model
   */
  readonly fields: PersonnageTitreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonnageTitre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnageTitreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnage<T extends PersonnageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnageDefaultArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    titre<T extends TitreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TitreDefaultArgs<ExtArgs>>): Prisma__TitreClient<$Result.GetResult<Prisma.$TitrePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    domaine<T extends PersonnageTitre$domaineArgs<ExtArgs> = {}>(args?: Subset<T, PersonnageTitre$domaineArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lignee<T extends PersonnageTitre$ligneeArgs<ExtArgs> = {}>(args?: Subset<T, PersonnageTitre$ligneeArgs<ExtArgs>>): Prisma__LigneeClient<$Result.GetResult<Prisma.$LigneePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonnageTitre model
   */ 
  interface PersonnageTitreFieldRefs {
    readonly id: FieldRef<"PersonnageTitre", 'Int'>
    readonly dateDebut: FieldRef<"PersonnageTitre", 'DateTime'>
    readonly dateFin: FieldRef<"PersonnageTitre", 'DateTime'>
    readonly estActif: FieldRef<"PersonnageTitre", 'Boolean'>
    readonly personnageId: FieldRef<"PersonnageTitre", 'Int'>
    readonly titreId: FieldRef<"PersonnageTitre", 'Int'>
    readonly domaineId: FieldRef<"PersonnageTitre", 'Int'>
    readonly ligneeId: FieldRef<"PersonnageTitre", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PersonnageTitre findUnique
   */
  export type PersonnageTitreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageTitre to fetch.
     */
    where: PersonnageTitreWhereUniqueInput
  }

  /**
   * PersonnageTitre findUniqueOrThrow
   */
  export type PersonnageTitreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageTitre to fetch.
     */
    where: PersonnageTitreWhereUniqueInput
  }

  /**
   * PersonnageTitre findFirst
   */
  export type PersonnageTitreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageTitre to fetch.
     */
    where?: PersonnageTitreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageTitres to fetch.
     */
    orderBy?: PersonnageTitreOrderByWithRelationInput | PersonnageTitreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnageTitres.
     */
    cursor?: PersonnageTitreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageTitres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageTitres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnageTitres.
     */
    distinct?: PersonnageTitreScalarFieldEnum | PersonnageTitreScalarFieldEnum[]
  }

  /**
   * PersonnageTitre findFirstOrThrow
   */
  export type PersonnageTitreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageTitre to fetch.
     */
    where?: PersonnageTitreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageTitres to fetch.
     */
    orderBy?: PersonnageTitreOrderByWithRelationInput | PersonnageTitreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnageTitres.
     */
    cursor?: PersonnageTitreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageTitres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageTitres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnageTitres.
     */
    distinct?: PersonnageTitreScalarFieldEnum | PersonnageTitreScalarFieldEnum[]
  }

  /**
   * PersonnageTitre findMany
   */
  export type PersonnageTitreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageTitres to fetch.
     */
    where?: PersonnageTitreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageTitres to fetch.
     */
    orderBy?: PersonnageTitreOrderByWithRelationInput | PersonnageTitreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonnageTitres.
     */
    cursor?: PersonnageTitreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageTitres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageTitres.
     */
    skip?: number
    distinct?: PersonnageTitreScalarFieldEnum | PersonnageTitreScalarFieldEnum[]
  }

  /**
   * PersonnageTitre create
   */
  export type PersonnageTitreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonnageTitre.
     */
    data: XOR<PersonnageTitreCreateInput, PersonnageTitreUncheckedCreateInput>
  }

  /**
   * PersonnageTitre createMany
   */
  export type PersonnageTitreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonnageTitres.
     */
    data: PersonnageTitreCreateManyInput | PersonnageTitreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonnageTitre createManyAndReturn
   */
  export type PersonnageTitreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PersonnageTitres.
     */
    data: PersonnageTitreCreateManyInput | PersonnageTitreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonnageTitre update
   */
  export type PersonnageTitreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonnageTitre.
     */
    data: XOR<PersonnageTitreUpdateInput, PersonnageTitreUncheckedUpdateInput>
    /**
     * Choose, which PersonnageTitre to update.
     */
    where: PersonnageTitreWhereUniqueInput
  }

  /**
   * PersonnageTitre updateMany
   */
  export type PersonnageTitreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonnageTitres.
     */
    data: XOR<PersonnageTitreUpdateManyMutationInput, PersonnageTitreUncheckedUpdateManyInput>
    /**
     * Filter which PersonnageTitres to update
     */
    where?: PersonnageTitreWhereInput
  }

  /**
   * PersonnageTitre upsert
   */
  export type PersonnageTitreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonnageTitre to update in case it exists.
     */
    where: PersonnageTitreWhereUniqueInput
    /**
     * In case the PersonnageTitre found by the `where` argument doesn't exist, create a new PersonnageTitre with this data.
     */
    create: XOR<PersonnageTitreCreateInput, PersonnageTitreUncheckedCreateInput>
    /**
     * In case the PersonnageTitre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnageTitreUpdateInput, PersonnageTitreUncheckedUpdateInput>
  }

  /**
   * PersonnageTitre delete
   */
  export type PersonnageTitreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
    /**
     * Filter which PersonnageTitre to delete.
     */
    where: PersonnageTitreWhereUniqueInput
  }

  /**
   * PersonnageTitre deleteMany
   */
  export type PersonnageTitreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnageTitres to delete
     */
    where?: PersonnageTitreWhereInput
  }

  /**
   * PersonnageTitre.domaine
   */
  export type PersonnageTitre$domaineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    where?: DomaineWhereInput
  }

  /**
   * PersonnageTitre.lignee
   */
  export type PersonnageTitre$ligneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lignee
     */
    select?: LigneeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneeInclude<ExtArgs> | null
    where?: LigneeWhereInput
  }

  /**
   * PersonnageTitre without action
   */
  export type PersonnageTitreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageTitre
     */
    select?: PersonnageTitreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageTitreInclude<ExtArgs> | null
  }


  /**
   * Model Village
   */

  export type AggregateVillage = {
    _count: VillageCountAggregateOutputType | null
    _avg: VillageAvgAggregateOutputType | null
    _sum: VillageSumAggregateOutputType | null
    _min: VillageMinAggregateOutputType | null
    _max: VillageMaxAggregateOutputType | null
  }

  export type VillageAvgAggregateOutputType = {
    id: number | null
    population: number | null
    domaineId: number | null
  }

  export type VillageSumAggregateOutputType = {
    id: number | null
    population: number | null
    domaineId: number | null
  }

  export type VillageMinAggregateOutputType = {
    id: number | null
    nom: string | null
    localisation: string | null
    population: number | null
    ressourcePrincipale: string | null
    domaineId: number | null
  }

  export type VillageMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    localisation: string | null
    population: number | null
    ressourcePrincipale: string | null
    domaineId: number | null
  }

  export type VillageCountAggregateOutputType = {
    id: number
    nom: number
    localisation: number
    population: number
    ressourcePrincipale: number
    domaineId: number
    _all: number
  }


  export type VillageAvgAggregateInputType = {
    id?: true
    population?: true
    domaineId?: true
  }

  export type VillageSumAggregateInputType = {
    id?: true
    population?: true
    domaineId?: true
  }

  export type VillageMinAggregateInputType = {
    id?: true
    nom?: true
    localisation?: true
    population?: true
    ressourcePrincipale?: true
    domaineId?: true
  }

  export type VillageMaxAggregateInputType = {
    id?: true
    nom?: true
    localisation?: true
    population?: true
    ressourcePrincipale?: true
    domaineId?: true
  }

  export type VillageCountAggregateInputType = {
    id?: true
    nom?: true
    localisation?: true
    population?: true
    ressourcePrincipale?: true
    domaineId?: true
    _all?: true
  }

  export type VillageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Village to aggregate.
     */
    where?: VillageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Villages to fetch.
     */
    orderBy?: VillageOrderByWithRelationInput | VillageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VillageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Villages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Villages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Villages
    **/
    _count?: true | VillageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VillageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VillageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VillageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VillageMaxAggregateInputType
  }

  export type GetVillageAggregateType<T extends VillageAggregateArgs> = {
        [P in keyof T & keyof AggregateVillage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVillage[P]>
      : GetScalarType<T[P], AggregateVillage[P]>
  }




  export type VillageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VillageWhereInput
    orderBy?: VillageOrderByWithAggregationInput | VillageOrderByWithAggregationInput[]
    by: VillageScalarFieldEnum[] | VillageScalarFieldEnum
    having?: VillageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VillageCountAggregateInputType | true
    _avg?: VillageAvgAggregateInputType
    _sum?: VillageSumAggregateInputType
    _min?: VillageMinAggregateInputType
    _max?: VillageMaxAggregateInputType
  }

  export type VillageGroupByOutputType = {
    id: number
    nom: string
    localisation: string | null
    population: number | null
    ressourcePrincipale: string | null
    domaineId: number | null
    _count: VillageCountAggregateOutputType | null
    _avg: VillageAvgAggregateOutputType | null
    _sum: VillageSumAggregateOutputType | null
    _min: VillageMinAggregateOutputType | null
    _max: VillageMaxAggregateOutputType | null
  }

  type GetVillageGroupByPayload<T extends VillageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VillageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VillageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VillageGroupByOutputType[P]>
            : GetScalarType<T[P], VillageGroupByOutputType[P]>
        }
      >
    >


  export type VillageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    localisation?: boolean
    population?: boolean
    ressourcePrincipale?: boolean
    domaineId?: boolean
    domaine?: boolean | Village$domaineArgs<ExtArgs>
    inventaires?: boolean | Village$inventairesArgs<ExtArgs>
    _count?: boolean | VillageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["village"]>

  export type VillageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    localisation?: boolean
    population?: boolean
    ressourcePrincipale?: boolean
    domaineId?: boolean
    domaine?: boolean | Village$domaineArgs<ExtArgs>
  }, ExtArgs["result"]["village"]>

  export type VillageSelectScalar = {
    id?: boolean
    nom?: boolean
    localisation?: boolean
    population?: boolean
    ressourcePrincipale?: boolean
    domaineId?: boolean
  }

  export type VillageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domaine?: boolean | Village$domaineArgs<ExtArgs>
    inventaires?: boolean | Village$inventairesArgs<ExtArgs>
    _count?: boolean | VillageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VillageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domaine?: boolean | Village$domaineArgs<ExtArgs>
  }

  export type $VillagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Village"
    objects: {
      domaine: Prisma.$DomainePayload<ExtArgs> | null
      inventaires: Prisma.$InventairePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      localisation: string | null
      population: number | null
      ressourcePrincipale: string | null
      domaineId: number | null
    }, ExtArgs["result"]["village"]>
    composites: {}
  }

  type VillageGetPayload<S extends boolean | null | undefined | VillageDefaultArgs> = $Result.GetResult<Prisma.$VillagePayload, S>

  type VillageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VillageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VillageCountAggregateInputType | true
    }

  export interface VillageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Village'], meta: { name: 'Village' } }
    /**
     * Find zero or one Village that matches the filter.
     * @param {VillageFindUniqueArgs} args - Arguments to find a Village
     * @example
     * // Get one Village
     * const village = await prisma.village.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VillageFindUniqueArgs>(args: SelectSubset<T, VillageFindUniqueArgs<ExtArgs>>): Prisma__VillageClient<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Village that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VillageFindUniqueOrThrowArgs} args - Arguments to find a Village
     * @example
     * // Get one Village
     * const village = await prisma.village.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VillageFindUniqueOrThrowArgs>(args: SelectSubset<T, VillageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VillageClient<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Village that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VillageFindFirstArgs} args - Arguments to find a Village
     * @example
     * // Get one Village
     * const village = await prisma.village.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VillageFindFirstArgs>(args?: SelectSubset<T, VillageFindFirstArgs<ExtArgs>>): Prisma__VillageClient<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Village that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VillageFindFirstOrThrowArgs} args - Arguments to find a Village
     * @example
     * // Get one Village
     * const village = await prisma.village.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VillageFindFirstOrThrowArgs>(args?: SelectSubset<T, VillageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VillageClient<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Villages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VillageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Villages
     * const villages = await prisma.village.findMany()
     * 
     * // Get first 10 Villages
     * const villages = await prisma.village.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const villageWithIdOnly = await prisma.village.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VillageFindManyArgs>(args?: SelectSubset<T, VillageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Village.
     * @param {VillageCreateArgs} args - Arguments to create a Village.
     * @example
     * // Create one Village
     * const Village = await prisma.village.create({
     *   data: {
     *     // ... data to create a Village
     *   }
     * })
     * 
     */
    create<T extends VillageCreateArgs>(args: SelectSubset<T, VillageCreateArgs<ExtArgs>>): Prisma__VillageClient<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Villages.
     * @param {VillageCreateManyArgs} args - Arguments to create many Villages.
     * @example
     * // Create many Villages
     * const village = await prisma.village.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VillageCreateManyArgs>(args?: SelectSubset<T, VillageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Villages and returns the data saved in the database.
     * @param {VillageCreateManyAndReturnArgs} args - Arguments to create many Villages.
     * @example
     * // Create many Villages
     * const village = await prisma.village.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Villages and only return the `id`
     * const villageWithIdOnly = await prisma.village.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VillageCreateManyAndReturnArgs>(args?: SelectSubset<T, VillageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Village.
     * @param {VillageDeleteArgs} args - Arguments to delete one Village.
     * @example
     * // Delete one Village
     * const Village = await prisma.village.delete({
     *   where: {
     *     // ... filter to delete one Village
     *   }
     * })
     * 
     */
    delete<T extends VillageDeleteArgs>(args: SelectSubset<T, VillageDeleteArgs<ExtArgs>>): Prisma__VillageClient<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Village.
     * @param {VillageUpdateArgs} args - Arguments to update one Village.
     * @example
     * // Update one Village
     * const village = await prisma.village.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VillageUpdateArgs>(args: SelectSubset<T, VillageUpdateArgs<ExtArgs>>): Prisma__VillageClient<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Villages.
     * @param {VillageDeleteManyArgs} args - Arguments to filter Villages to delete.
     * @example
     * // Delete a few Villages
     * const { count } = await prisma.village.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VillageDeleteManyArgs>(args?: SelectSubset<T, VillageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Villages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VillageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Villages
     * const village = await prisma.village.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VillageUpdateManyArgs>(args: SelectSubset<T, VillageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Village.
     * @param {VillageUpsertArgs} args - Arguments to update or create a Village.
     * @example
     * // Update or create a Village
     * const village = await prisma.village.upsert({
     *   create: {
     *     // ... data to create a Village
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Village we want to update
     *   }
     * })
     */
    upsert<T extends VillageUpsertArgs>(args: SelectSubset<T, VillageUpsertArgs<ExtArgs>>): Prisma__VillageClient<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Villages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VillageCountArgs} args - Arguments to filter Villages to count.
     * @example
     * // Count the number of Villages
     * const count = await prisma.village.count({
     *   where: {
     *     // ... the filter for the Villages we want to count
     *   }
     * })
    **/
    count<T extends VillageCountArgs>(
      args?: Subset<T, VillageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VillageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Village.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VillageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VillageAggregateArgs>(args: Subset<T, VillageAggregateArgs>): Prisma.PrismaPromise<GetVillageAggregateType<T>>

    /**
     * Group by Village.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VillageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VillageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VillageGroupByArgs['orderBy'] }
        : { orderBy?: VillageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VillageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVillageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Village model
   */
  readonly fields: VillageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Village.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VillageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domaine<T extends Village$domaineArgs<ExtArgs> = {}>(args?: Subset<T, Village$domaineArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inventaires<T extends Village$inventairesArgs<ExtArgs> = {}>(args?: Subset<T, Village$inventairesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Village model
   */ 
  interface VillageFieldRefs {
    readonly id: FieldRef<"Village", 'Int'>
    readonly nom: FieldRef<"Village", 'String'>
    readonly localisation: FieldRef<"Village", 'String'>
    readonly population: FieldRef<"Village", 'Int'>
    readonly ressourcePrincipale: FieldRef<"Village", 'String'>
    readonly domaineId: FieldRef<"Village", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Village findUnique
   */
  export type VillageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    /**
     * Filter, which Village to fetch.
     */
    where: VillageWhereUniqueInput
  }

  /**
   * Village findUniqueOrThrow
   */
  export type VillageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    /**
     * Filter, which Village to fetch.
     */
    where: VillageWhereUniqueInput
  }

  /**
   * Village findFirst
   */
  export type VillageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    /**
     * Filter, which Village to fetch.
     */
    where?: VillageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Villages to fetch.
     */
    orderBy?: VillageOrderByWithRelationInput | VillageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Villages.
     */
    cursor?: VillageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Villages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Villages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Villages.
     */
    distinct?: VillageScalarFieldEnum | VillageScalarFieldEnum[]
  }

  /**
   * Village findFirstOrThrow
   */
  export type VillageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    /**
     * Filter, which Village to fetch.
     */
    where?: VillageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Villages to fetch.
     */
    orderBy?: VillageOrderByWithRelationInput | VillageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Villages.
     */
    cursor?: VillageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Villages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Villages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Villages.
     */
    distinct?: VillageScalarFieldEnum | VillageScalarFieldEnum[]
  }

  /**
   * Village findMany
   */
  export type VillageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    /**
     * Filter, which Villages to fetch.
     */
    where?: VillageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Villages to fetch.
     */
    orderBy?: VillageOrderByWithRelationInput | VillageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Villages.
     */
    cursor?: VillageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Villages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Villages.
     */
    skip?: number
    distinct?: VillageScalarFieldEnum | VillageScalarFieldEnum[]
  }

  /**
   * Village create
   */
  export type VillageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    /**
     * The data needed to create a Village.
     */
    data: XOR<VillageCreateInput, VillageUncheckedCreateInput>
  }

  /**
   * Village createMany
   */
  export type VillageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Villages.
     */
    data: VillageCreateManyInput | VillageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Village createManyAndReturn
   */
  export type VillageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Villages.
     */
    data: VillageCreateManyInput | VillageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Village update
   */
  export type VillageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    /**
     * The data needed to update a Village.
     */
    data: XOR<VillageUpdateInput, VillageUncheckedUpdateInput>
    /**
     * Choose, which Village to update.
     */
    where: VillageWhereUniqueInput
  }

  /**
   * Village updateMany
   */
  export type VillageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Villages.
     */
    data: XOR<VillageUpdateManyMutationInput, VillageUncheckedUpdateManyInput>
    /**
     * Filter which Villages to update
     */
    where?: VillageWhereInput
  }

  /**
   * Village upsert
   */
  export type VillageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    /**
     * The filter to search for the Village to update in case it exists.
     */
    where: VillageWhereUniqueInput
    /**
     * In case the Village found by the `where` argument doesn't exist, create a new Village with this data.
     */
    create: XOR<VillageCreateInput, VillageUncheckedCreateInput>
    /**
     * In case the Village was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VillageUpdateInput, VillageUncheckedUpdateInput>
  }

  /**
   * Village delete
   */
  export type VillageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    /**
     * Filter which Village to delete.
     */
    where: VillageWhereUniqueInput
  }

  /**
   * Village deleteMany
   */
  export type VillageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Villages to delete
     */
    where?: VillageWhereInput
  }

  /**
   * Village.domaine
   */
  export type Village$domaineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    where?: DomaineWhereInput
  }

  /**
   * Village.inventaires
   */
  export type Village$inventairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    where?: InventaireWhereInput
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    cursor?: InventaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventaireScalarFieldEnum | InventaireScalarFieldEnum[]
  }

  /**
   * Village without action
   */
  export type VillageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
  }


  /**
   * Model Guilde
   */

  export type AggregateGuilde = {
    _count: GuildeCountAggregateOutputType | null
    _avg: GuildeAvgAggregateOutputType | null
    _sum: GuildeSumAggregateOutputType | null
    _min: GuildeMinAggregateOutputType | null
    _max: GuildeMaxAggregateOutputType | null
  }

  export type GuildeAvgAggregateOutputType = {
    id: number | null
  }

  export type GuildeSumAggregateOutputType = {
    id: number | null
  }

  export type GuildeMinAggregateOutputType = {
    id: number | null
    nom: string | null
    specialite: string | null
    reputation: string | null
  }

  export type GuildeMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    specialite: string | null
    reputation: string | null
  }

  export type GuildeCountAggregateOutputType = {
    id: number
    nom: number
    specialite: number
    reputation: number
    _all: number
  }


  export type GuildeAvgAggregateInputType = {
    id?: true
  }

  export type GuildeSumAggregateInputType = {
    id?: true
  }

  export type GuildeMinAggregateInputType = {
    id?: true
    nom?: true
    specialite?: true
    reputation?: true
  }

  export type GuildeMaxAggregateInputType = {
    id?: true
    nom?: true
    specialite?: true
    reputation?: true
  }

  export type GuildeCountAggregateInputType = {
    id?: true
    nom?: true
    specialite?: true
    reputation?: true
    _all?: true
  }

  export type GuildeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guilde to aggregate.
     */
    where?: GuildeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guildes to fetch.
     */
    orderBy?: GuildeOrderByWithRelationInput | GuildeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guildes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guildes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guildes
    **/
    _count?: true | GuildeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildeMaxAggregateInputType
  }

  export type GetGuildeAggregateType<T extends GuildeAggregateArgs> = {
        [P in keyof T & keyof AggregateGuilde]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuilde[P]>
      : GetScalarType<T[P], AggregateGuilde[P]>
  }




  export type GuildeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildeWhereInput
    orderBy?: GuildeOrderByWithAggregationInput | GuildeOrderByWithAggregationInput[]
    by: GuildeScalarFieldEnum[] | GuildeScalarFieldEnum
    having?: GuildeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildeCountAggregateInputType | true
    _avg?: GuildeAvgAggregateInputType
    _sum?: GuildeSumAggregateInputType
    _min?: GuildeMinAggregateInputType
    _max?: GuildeMaxAggregateInputType
  }

  export type GuildeGroupByOutputType = {
    id: number
    nom: string
    specialite: string | null
    reputation: string | null
    _count: GuildeCountAggregateOutputType | null
    _avg: GuildeAvgAggregateOutputType | null
    _sum: GuildeSumAggregateOutputType | null
    _min: GuildeMinAggregateOutputType | null
    _max: GuildeMaxAggregateOutputType | null
  }

  type GetGuildeGroupByPayload<T extends GuildeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildeGroupByOutputType[P]>
            : GetScalarType<T[P], GuildeGroupByOutputType[P]>
        }
      >
    >


  export type GuildeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    specialite?: boolean
    reputation?: boolean
    membres?: boolean | Guilde$membresArgs<ExtArgs>
    batailles?: boolean | Guilde$bataillesArgs<ExtArgs>
    _count?: boolean | GuildeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guilde"]>

  export type GuildeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    specialite?: boolean
    reputation?: boolean
  }, ExtArgs["result"]["guilde"]>

  export type GuildeSelectScalar = {
    id?: boolean
    nom?: boolean
    specialite?: boolean
    reputation?: boolean
  }

  export type GuildeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membres?: boolean | Guilde$membresArgs<ExtArgs>
    batailles?: boolean | Guilde$bataillesArgs<ExtArgs>
    _count?: boolean | GuildeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GuildeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GuildePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guilde"
    objects: {
      membres: Prisma.$GuildeMembrePayload<ExtArgs>[]
      batailles: Prisma.$GuildeBataillePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      specialite: string | null
      reputation: string | null
    }, ExtArgs["result"]["guilde"]>
    composites: {}
  }

  type GuildeGetPayload<S extends boolean | null | undefined | GuildeDefaultArgs> = $Result.GetResult<Prisma.$GuildePayload, S>

  type GuildeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuildeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildeCountAggregateInputType | true
    }

  export interface GuildeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guilde'], meta: { name: 'Guilde' } }
    /**
     * Find zero or one Guilde that matches the filter.
     * @param {GuildeFindUniqueArgs} args - Arguments to find a Guilde
     * @example
     * // Get one Guilde
     * const guilde = await prisma.guilde.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildeFindUniqueArgs>(args: SelectSubset<T, GuildeFindUniqueArgs<ExtArgs>>): Prisma__GuildeClient<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Guilde that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GuildeFindUniqueOrThrowArgs} args - Arguments to find a Guilde
     * @example
     * // Get one Guilde
     * const guilde = await prisma.guilde.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildeFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildeClient<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Guilde that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeFindFirstArgs} args - Arguments to find a Guilde
     * @example
     * // Get one Guilde
     * const guilde = await prisma.guilde.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildeFindFirstArgs>(args?: SelectSubset<T, GuildeFindFirstArgs<ExtArgs>>): Prisma__GuildeClient<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Guilde that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeFindFirstOrThrowArgs} args - Arguments to find a Guilde
     * @example
     * // Get one Guilde
     * const guilde = await prisma.guilde.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildeFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildeClient<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Guildes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guildes
     * const guildes = await prisma.guilde.findMany()
     * 
     * // Get first 10 Guildes
     * const guildes = await prisma.guilde.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildeWithIdOnly = await prisma.guilde.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildeFindManyArgs>(args?: SelectSubset<T, GuildeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Guilde.
     * @param {GuildeCreateArgs} args - Arguments to create a Guilde.
     * @example
     * // Create one Guilde
     * const Guilde = await prisma.guilde.create({
     *   data: {
     *     // ... data to create a Guilde
     *   }
     * })
     * 
     */
    create<T extends GuildeCreateArgs>(args: SelectSubset<T, GuildeCreateArgs<ExtArgs>>): Prisma__GuildeClient<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Guildes.
     * @param {GuildeCreateManyArgs} args - Arguments to create many Guildes.
     * @example
     * // Create many Guildes
     * const guilde = await prisma.guilde.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildeCreateManyArgs>(args?: SelectSubset<T, GuildeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guildes and returns the data saved in the database.
     * @param {GuildeCreateManyAndReturnArgs} args - Arguments to create many Guildes.
     * @example
     * // Create many Guildes
     * const guilde = await prisma.guilde.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guildes and only return the `id`
     * const guildeWithIdOnly = await prisma.guilde.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuildeCreateManyAndReturnArgs>(args?: SelectSubset<T, GuildeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Guilde.
     * @param {GuildeDeleteArgs} args - Arguments to delete one Guilde.
     * @example
     * // Delete one Guilde
     * const Guilde = await prisma.guilde.delete({
     *   where: {
     *     // ... filter to delete one Guilde
     *   }
     * })
     * 
     */
    delete<T extends GuildeDeleteArgs>(args: SelectSubset<T, GuildeDeleteArgs<ExtArgs>>): Prisma__GuildeClient<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Guilde.
     * @param {GuildeUpdateArgs} args - Arguments to update one Guilde.
     * @example
     * // Update one Guilde
     * const guilde = await prisma.guilde.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildeUpdateArgs>(args: SelectSubset<T, GuildeUpdateArgs<ExtArgs>>): Prisma__GuildeClient<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Guildes.
     * @param {GuildeDeleteManyArgs} args - Arguments to filter Guildes to delete.
     * @example
     * // Delete a few Guildes
     * const { count } = await prisma.guilde.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildeDeleteManyArgs>(args?: SelectSubset<T, GuildeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guildes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guildes
     * const guilde = await prisma.guilde.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildeUpdateManyArgs>(args: SelectSubset<T, GuildeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guilde.
     * @param {GuildeUpsertArgs} args - Arguments to update or create a Guilde.
     * @example
     * // Update or create a Guilde
     * const guilde = await prisma.guilde.upsert({
     *   create: {
     *     // ... data to create a Guilde
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guilde we want to update
     *   }
     * })
     */
    upsert<T extends GuildeUpsertArgs>(args: SelectSubset<T, GuildeUpsertArgs<ExtArgs>>): Prisma__GuildeClient<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Guildes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeCountArgs} args - Arguments to filter Guildes to count.
     * @example
     * // Count the number of Guildes
     * const count = await prisma.guilde.count({
     *   where: {
     *     // ... the filter for the Guildes we want to count
     *   }
     * })
    **/
    count<T extends GuildeCountArgs>(
      args?: Subset<T, GuildeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guilde.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildeAggregateArgs>(args: Subset<T, GuildeAggregateArgs>): Prisma.PrismaPromise<GetGuildeAggregateType<T>>

    /**
     * Group by Guilde.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildeGroupByArgs['orderBy'] }
        : { orderBy?: GuildeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guilde model
   */
  readonly fields: GuildeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guilde.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    membres<T extends Guilde$membresArgs<ExtArgs> = {}>(args?: Subset<T, Guilde$membresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "findMany"> | Null>
    batailles<T extends Guilde$bataillesArgs<ExtArgs> = {}>(args?: Subset<T, Guilde$bataillesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guilde model
   */ 
  interface GuildeFieldRefs {
    readonly id: FieldRef<"Guilde", 'Int'>
    readonly nom: FieldRef<"Guilde", 'String'>
    readonly specialite: FieldRef<"Guilde", 'String'>
    readonly reputation: FieldRef<"Guilde", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Guilde findUnique
   */
  export type GuildeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeInclude<ExtArgs> | null
    /**
     * Filter, which Guilde to fetch.
     */
    where: GuildeWhereUniqueInput
  }

  /**
   * Guilde findUniqueOrThrow
   */
  export type GuildeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeInclude<ExtArgs> | null
    /**
     * Filter, which Guilde to fetch.
     */
    where: GuildeWhereUniqueInput
  }

  /**
   * Guilde findFirst
   */
  export type GuildeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeInclude<ExtArgs> | null
    /**
     * Filter, which Guilde to fetch.
     */
    where?: GuildeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guildes to fetch.
     */
    orderBy?: GuildeOrderByWithRelationInput | GuildeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guildes.
     */
    cursor?: GuildeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guildes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guildes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guildes.
     */
    distinct?: GuildeScalarFieldEnum | GuildeScalarFieldEnum[]
  }

  /**
   * Guilde findFirstOrThrow
   */
  export type GuildeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeInclude<ExtArgs> | null
    /**
     * Filter, which Guilde to fetch.
     */
    where?: GuildeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guildes to fetch.
     */
    orderBy?: GuildeOrderByWithRelationInput | GuildeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guildes.
     */
    cursor?: GuildeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guildes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guildes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guildes.
     */
    distinct?: GuildeScalarFieldEnum | GuildeScalarFieldEnum[]
  }

  /**
   * Guilde findMany
   */
  export type GuildeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeInclude<ExtArgs> | null
    /**
     * Filter, which Guildes to fetch.
     */
    where?: GuildeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guildes to fetch.
     */
    orderBy?: GuildeOrderByWithRelationInput | GuildeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guildes.
     */
    cursor?: GuildeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guildes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guildes.
     */
    skip?: number
    distinct?: GuildeScalarFieldEnum | GuildeScalarFieldEnum[]
  }

  /**
   * Guilde create
   */
  export type GuildeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeInclude<ExtArgs> | null
    /**
     * The data needed to create a Guilde.
     */
    data: XOR<GuildeCreateInput, GuildeUncheckedCreateInput>
  }

  /**
   * Guilde createMany
   */
  export type GuildeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guildes.
     */
    data: GuildeCreateManyInput | GuildeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guilde createManyAndReturn
   */
  export type GuildeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Guildes.
     */
    data: GuildeCreateManyInput | GuildeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guilde update
   */
  export type GuildeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeInclude<ExtArgs> | null
    /**
     * The data needed to update a Guilde.
     */
    data: XOR<GuildeUpdateInput, GuildeUncheckedUpdateInput>
    /**
     * Choose, which Guilde to update.
     */
    where: GuildeWhereUniqueInput
  }

  /**
   * Guilde updateMany
   */
  export type GuildeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guildes.
     */
    data: XOR<GuildeUpdateManyMutationInput, GuildeUncheckedUpdateManyInput>
    /**
     * Filter which Guildes to update
     */
    where?: GuildeWhereInput
  }

  /**
   * Guilde upsert
   */
  export type GuildeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeInclude<ExtArgs> | null
    /**
     * The filter to search for the Guilde to update in case it exists.
     */
    where: GuildeWhereUniqueInput
    /**
     * In case the Guilde found by the `where` argument doesn't exist, create a new Guilde with this data.
     */
    create: XOR<GuildeCreateInput, GuildeUncheckedCreateInput>
    /**
     * In case the Guilde was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildeUpdateInput, GuildeUncheckedUpdateInput>
  }

  /**
   * Guilde delete
   */
  export type GuildeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeInclude<ExtArgs> | null
    /**
     * Filter which Guilde to delete.
     */
    where: GuildeWhereUniqueInput
  }

  /**
   * Guilde deleteMany
   */
  export type GuildeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guildes to delete
     */
    where?: GuildeWhereInput
  }

  /**
   * Guilde.membres
   */
  export type Guilde$membresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    where?: GuildeMembreWhereInput
    orderBy?: GuildeMembreOrderByWithRelationInput | GuildeMembreOrderByWithRelationInput[]
    cursor?: GuildeMembreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuildeMembreScalarFieldEnum | GuildeMembreScalarFieldEnum[]
  }

  /**
   * Guilde.batailles
   */
  export type Guilde$bataillesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    where?: GuildeBatailleWhereInput
    orderBy?: GuildeBatailleOrderByWithRelationInput | GuildeBatailleOrderByWithRelationInput[]
    cursor?: GuildeBatailleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuildeBatailleScalarFieldEnum | GuildeBatailleScalarFieldEnum[]
  }

  /**
   * Guilde without action
   */
  export type GuildeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guilde
     */
    select?: GuildeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeInclude<ExtArgs> | null
  }


  /**
   * Model GuildeMembre
   */

  export type AggregateGuildeMembre = {
    _count: GuildeMembreCountAggregateOutputType | null
    _avg: GuildeMembreAvgAggregateOutputType | null
    _sum: GuildeMembreSumAggregateOutputType | null
    _min: GuildeMembreMinAggregateOutputType | null
    _max: GuildeMembreMaxAggregateOutputType | null
  }

  export type GuildeMembreAvgAggregateOutputType = {
    personnageId: number | null
    guildeId: number | null
  }

  export type GuildeMembreSumAggregateOutputType = {
    personnageId: number | null
    guildeId: number | null
  }

  export type GuildeMembreMinAggregateOutputType = {
    personnageId: number | null
    guildeId: number | null
    dateEntree: Date | null
    dateSortie: Date | null
  }

  export type GuildeMembreMaxAggregateOutputType = {
    personnageId: number | null
    guildeId: number | null
    dateEntree: Date | null
    dateSortie: Date | null
  }

  export type GuildeMembreCountAggregateOutputType = {
    personnageId: number
    guildeId: number
    dateEntree: number
    dateSortie: number
    _all: number
  }


  export type GuildeMembreAvgAggregateInputType = {
    personnageId?: true
    guildeId?: true
  }

  export type GuildeMembreSumAggregateInputType = {
    personnageId?: true
    guildeId?: true
  }

  export type GuildeMembreMinAggregateInputType = {
    personnageId?: true
    guildeId?: true
    dateEntree?: true
    dateSortie?: true
  }

  export type GuildeMembreMaxAggregateInputType = {
    personnageId?: true
    guildeId?: true
    dateEntree?: true
    dateSortie?: true
  }

  export type GuildeMembreCountAggregateInputType = {
    personnageId?: true
    guildeId?: true
    dateEntree?: true
    dateSortie?: true
    _all?: true
  }

  export type GuildeMembreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildeMembre to aggregate.
     */
    where?: GuildeMembreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildeMembres to fetch.
     */
    orderBy?: GuildeMembreOrderByWithRelationInput | GuildeMembreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildeMembreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildeMembres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildeMembres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildeMembres
    **/
    _count?: true | GuildeMembreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildeMembreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildeMembreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildeMembreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildeMembreMaxAggregateInputType
  }

  export type GetGuildeMembreAggregateType<T extends GuildeMembreAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildeMembre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildeMembre[P]>
      : GetScalarType<T[P], AggregateGuildeMembre[P]>
  }




  export type GuildeMembreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildeMembreWhereInput
    orderBy?: GuildeMembreOrderByWithAggregationInput | GuildeMembreOrderByWithAggregationInput[]
    by: GuildeMembreScalarFieldEnum[] | GuildeMembreScalarFieldEnum
    having?: GuildeMembreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildeMembreCountAggregateInputType | true
    _avg?: GuildeMembreAvgAggregateInputType
    _sum?: GuildeMembreSumAggregateInputType
    _min?: GuildeMembreMinAggregateInputType
    _max?: GuildeMembreMaxAggregateInputType
  }

  export type GuildeMembreGroupByOutputType = {
    personnageId: number
    guildeId: number
    dateEntree: Date | null
    dateSortie: Date | null
    _count: GuildeMembreCountAggregateOutputType | null
    _avg: GuildeMembreAvgAggregateOutputType | null
    _sum: GuildeMembreSumAggregateOutputType | null
    _min: GuildeMembreMinAggregateOutputType | null
    _max: GuildeMembreMaxAggregateOutputType | null
  }

  type GetGuildeMembreGroupByPayload<T extends GuildeMembreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildeMembreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildeMembreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildeMembreGroupByOutputType[P]>
            : GetScalarType<T[P], GuildeMembreGroupByOutputType[P]>
        }
      >
    >


  export type GuildeMembreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnageId?: boolean
    guildeId?: boolean
    dateEntree?: boolean
    dateSortie?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    guilde?: boolean | GuildeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildeMembre"]>

  export type GuildeMembreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnageId?: boolean
    guildeId?: boolean
    dateEntree?: boolean
    dateSortie?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    guilde?: boolean | GuildeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildeMembre"]>

  export type GuildeMembreSelectScalar = {
    personnageId?: boolean
    guildeId?: boolean
    dateEntree?: boolean
    dateSortie?: boolean
  }

  export type GuildeMembreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    guilde?: boolean | GuildeDefaultArgs<ExtArgs>
  }
  export type GuildeMembreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    guilde?: boolean | GuildeDefaultArgs<ExtArgs>
  }

  export type $GuildeMembrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildeMembre"
    objects: {
      personnage: Prisma.$PersonnagePayload<ExtArgs>
      guilde: Prisma.$GuildePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      personnageId: number
      guildeId: number
      dateEntree: Date | null
      dateSortie: Date | null
    }, ExtArgs["result"]["guildeMembre"]>
    composites: {}
  }

  type GuildeMembreGetPayload<S extends boolean | null | undefined | GuildeMembreDefaultArgs> = $Result.GetResult<Prisma.$GuildeMembrePayload, S>

  type GuildeMembreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuildeMembreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildeMembreCountAggregateInputType | true
    }

  export interface GuildeMembreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildeMembre'], meta: { name: 'GuildeMembre' } }
    /**
     * Find zero or one GuildeMembre that matches the filter.
     * @param {GuildeMembreFindUniqueArgs} args - Arguments to find a GuildeMembre
     * @example
     * // Get one GuildeMembre
     * const guildeMembre = await prisma.guildeMembre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildeMembreFindUniqueArgs>(args: SelectSubset<T, GuildeMembreFindUniqueArgs<ExtArgs>>): Prisma__GuildeMembreClient<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GuildeMembre that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GuildeMembreFindUniqueOrThrowArgs} args - Arguments to find a GuildeMembre
     * @example
     * // Get one GuildeMembre
     * const guildeMembre = await prisma.guildeMembre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildeMembreFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildeMembreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildeMembreClient<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GuildeMembre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeMembreFindFirstArgs} args - Arguments to find a GuildeMembre
     * @example
     * // Get one GuildeMembre
     * const guildeMembre = await prisma.guildeMembre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildeMembreFindFirstArgs>(args?: SelectSubset<T, GuildeMembreFindFirstArgs<ExtArgs>>): Prisma__GuildeMembreClient<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GuildeMembre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeMembreFindFirstOrThrowArgs} args - Arguments to find a GuildeMembre
     * @example
     * // Get one GuildeMembre
     * const guildeMembre = await prisma.guildeMembre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildeMembreFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildeMembreFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildeMembreClient<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GuildeMembres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeMembreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildeMembres
     * const guildeMembres = await prisma.guildeMembre.findMany()
     * 
     * // Get first 10 GuildeMembres
     * const guildeMembres = await prisma.guildeMembre.findMany({ take: 10 })
     * 
     * // Only select the `personnageId`
     * const guildeMembreWithPersonnageIdOnly = await prisma.guildeMembre.findMany({ select: { personnageId: true } })
     * 
     */
    findMany<T extends GuildeMembreFindManyArgs>(args?: SelectSubset<T, GuildeMembreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GuildeMembre.
     * @param {GuildeMembreCreateArgs} args - Arguments to create a GuildeMembre.
     * @example
     * // Create one GuildeMembre
     * const GuildeMembre = await prisma.guildeMembre.create({
     *   data: {
     *     // ... data to create a GuildeMembre
     *   }
     * })
     * 
     */
    create<T extends GuildeMembreCreateArgs>(args: SelectSubset<T, GuildeMembreCreateArgs<ExtArgs>>): Prisma__GuildeMembreClient<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GuildeMembres.
     * @param {GuildeMembreCreateManyArgs} args - Arguments to create many GuildeMembres.
     * @example
     * // Create many GuildeMembres
     * const guildeMembre = await prisma.guildeMembre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildeMembreCreateManyArgs>(args?: SelectSubset<T, GuildeMembreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GuildeMembres and returns the data saved in the database.
     * @param {GuildeMembreCreateManyAndReturnArgs} args - Arguments to create many GuildeMembres.
     * @example
     * // Create many GuildeMembres
     * const guildeMembre = await prisma.guildeMembre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GuildeMembres and only return the `personnageId`
     * const guildeMembreWithPersonnageIdOnly = await prisma.guildeMembre.createManyAndReturn({ 
     *   select: { personnageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuildeMembreCreateManyAndReturnArgs>(args?: SelectSubset<T, GuildeMembreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GuildeMembre.
     * @param {GuildeMembreDeleteArgs} args - Arguments to delete one GuildeMembre.
     * @example
     * // Delete one GuildeMembre
     * const GuildeMembre = await prisma.guildeMembre.delete({
     *   where: {
     *     // ... filter to delete one GuildeMembre
     *   }
     * })
     * 
     */
    delete<T extends GuildeMembreDeleteArgs>(args: SelectSubset<T, GuildeMembreDeleteArgs<ExtArgs>>): Prisma__GuildeMembreClient<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GuildeMembre.
     * @param {GuildeMembreUpdateArgs} args - Arguments to update one GuildeMembre.
     * @example
     * // Update one GuildeMembre
     * const guildeMembre = await prisma.guildeMembre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildeMembreUpdateArgs>(args: SelectSubset<T, GuildeMembreUpdateArgs<ExtArgs>>): Prisma__GuildeMembreClient<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GuildeMembres.
     * @param {GuildeMembreDeleteManyArgs} args - Arguments to filter GuildeMembres to delete.
     * @example
     * // Delete a few GuildeMembres
     * const { count } = await prisma.guildeMembre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildeMembreDeleteManyArgs>(args?: SelectSubset<T, GuildeMembreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildeMembres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeMembreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildeMembres
     * const guildeMembre = await prisma.guildeMembre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildeMembreUpdateManyArgs>(args: SelectSubset<T, GuildeMembreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildeMembre.
     * @param {GuildeMembreUpsertArgs} args - Arguments to update or create a GuildeMembre.
     * @example
     * // Update or create a GuildeMembre
     * const guildeMembre = await prisma.guildeMembre.upsert({
     *   create: {
     *     // ... data to create a GuildeMembre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildeMembre we want to update
     *   }
     * })
     */
    upsert<T extends GuildeMembreUpsertArgs>(args: SelectSubset<T, GuildeMembreUpsertArgs<ExtArgs>>): Prisma__GuildeMembreClient<$Result.GetResult<Prisma.$GuildeMembrePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GuildeMembres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeMembreCountArgs} args - Arguments to filter GuildeMembres to count.
     * @example
     * // Count the number of GuildeMembres
     * const count = await prisma.guildeMembre.count({
     *   where: {
     *     // ... the filter for the GuildeMembres we want to count
     *   }
     * })
    **/
    count<T extends GuildeMembreCountArgs>(
      args?: Subset<T, GuildeMembreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildeMembreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildeMembre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeMembreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildeMembreAggregateArgs>(args: Subset<T, GuildeMembreAggregateArgs>): Prisma.PrismaPromise<GetGuildeMembreAggregateType<T>>

    /**
     * Group by GuildeMembre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeMembreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildeMembreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildeMembreGroupByArgs['orderBy'] }
        : { orderBy?: GuildeMembreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildeMembreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildeMembreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildeMembre model
   */
  readonly fields: GuildeMembreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildeMembre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildeMembreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnage<T extends PersonnageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnageDefaultArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    guilde<T extends GuildeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildeDefaultArgs<ExtArgs>>): Prisma__GuildeClient<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildeMembre model
   */ 
  interface GuildeMembreFieldRefs {
    readonly personnageId: FieldRef<"GuildeMembre", 'Int'>
    readonly guildeId: FieldRef<"GuildeMembre", 'Int'>
    readonly dateEntree: FieldRef<"GuildeMembre", 'DateTime'>
    readonly dateSortie: FieldRef<"GuildeMembre", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GuildeMembre findUnique
   */
  export type GuildeMembreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    /**
     * Filter, which GuildeMembre to fetch.
     */
    where: GuildeMembreWhereUniqueInput
  }

  /**
   * GuildeMembre findUniqueOrThrow
   */
  export type GuildeMembreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    /**
     * Filter, which GuildeMembre to fetch.
     */
    where: GuildeMembreWhereUniqueInput
  }

  /**
   * GuildeMembre findFirst
   */
  export type GuildeMembreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    /**
     * Filter, which GuildeMembre to fetch.
     */
    where?: GuildeMembreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildeMembres to fetch.
     */
    orderBy?: GuildeMembreOrderByWithRelationInput | GuildeMembreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildeMembres.
     */
    cursor?: GuildeMembreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildeMembres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildeMembres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildeMembres.
     */
    distinct?: GuildeMembreScalarFieldEnum | GuildeMembreScalarFieldEnum[]
  }

  /**
   * GuildeMembre findFirstOrThrow
   */
  export type GuildeMembreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    /**
     * Filter, which GuildeMembre to fetch.
     */
    where?: GuildeMembreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildeMembres to fetch.
     */
    orderBy?: GuildeMembreOrderByWithRelationInput | GuildeMembreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildeMembres.
     */
    cursor?: GuildeMembreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildeMembres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildeMembres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildeMembres.
     */
    distinct?: GuildeMembreScalarFieldEnum | GuildeMembreScalarFieldEnum[]
  }

  /**
   * GuildeMembre findMany
   */
  export type GuildeMembreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    /**
     * Filter, which GuildeMembres to fetch.
     */
    where?: GuildeMembreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildeMembres to fetch.
     */
    orderBy?: GuildeMembreOrderByWithRelationInput | GuildeMembreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildeMembres.
     */
    cursor?: GuildeMembreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildeMembres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildeMembres.
     */
    skip?: number
    distinct?: GuildeMembreScalarFieldEnum | GuildeMembreScalarFieldEnum[]
  }

  /**
   * GuildeMembre create
   */
  export type GuildeMembreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildeMembre.
     */
    data: XOR<GuildeMembreCreateInput, GuildeMembreUncheckedCreateInput>
  }

  /**
   * GuildeMembre createMany
   */
  export type GuildeMembreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildeMembres.
     */
    data: GuildeMembreCreateManyInput | GuildeMembreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuildeMembre createManyAndReturn
   */
  export type GuildeMembreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GuildeMembres.
     */
    data: GuildeMembreCreateManyInput | GuildeMembreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuildeMembre update
   */
  export type GuildeMembreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildeMembre.
     */
    data: XOR<GuildeMembreUpdateInput, GuildeMembreUncheckedUpdateInput>
    /**
     * Choose, which GuildeMembre to update.
     */
    where: GuildeMembreWhereUniqueInput
  }

  /**
   * GuildeMembre updateMany
   */
  export type GuildeMembreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildeMembres.
     */
    data: XOR<GuildeMembreUpdateManyMutationInput, GuildeMembreUncheckedUpdateManyInput>
    /**
     * Filter which GuildeMembres to update
     */
    where?: GuildeMembreWhereInput
  }

  /**
   * GuildeMembre upsert
   */
  export type GuildeMembreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildeMembre to update in case it exists.
     */
    where: GuildeMembreWhereUniqueInput
    /**
     * In case the GuildeMembre found by the `where` argument doesn't exist, create a new GuildeMembre with this data.
     */
    create: XOR<GuildeMembreCreateInput, GuildeMembreUncheckedCreateInput>
    /**
     * In case the GuildeMembre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildeMembreUpdateInput, GuildeMembreUncheckedUpdateInput>
  }

  /**
   * GuildeMembre delete
   */
  export type GuildeMembreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
    /**
     * Filter which GuildeMembre to delete.
     */
    where: GuildeMembreWhereUniqueInput
  }

  /**
   * GuildeMembre deleteMany
   */
  export type GuildeMembreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildeMembres to delete
     */
    where?: GuildeMembreWhereInput
  }

  /**
   * GuildeMembre without action
   */
  export type GuildeMembreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeMembre
     */
    select?: GuildeMembreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeMembreInclude<ExtArgs> | null
  }


  /**
   * Model Creature
   */

  export type AggregateCreature = {
    _count: CreatureCountAggregateOutputType | null
    _avg: CreatureAvgAggregateOutputType | null
    _sum: CreatureSumAggregateOutputType | null
    _min: CreatureMinAggregateOutputType | null
    _max: CreatureMaxAggregateOutputType | null
  }

  export type CreatureAvgAggregateOutputType = {
    id: number | null
  }

  export type CreatureSumAggregateOutputType = {
    id: number | null
  }

  export type CreatureMinAggregateOutputType = {
    id: number | null
    espece: string | null
    forces: string | null
    faiblesses: string | null
    dangerosite: string | null
  }

  export type CreatureMaxAggregateOutputType = {
    id: number | null
    espece: string | null
    forces: string | null
    faiblesses: string | null
    dangerosite: string | null
  }

  export type CreatureCountAggregateOutputType = {
    id: number
    espece: number
    forces: number
    faiblesses: number
    dangerosite: number
    _all: number
  }


  export type CreatureAvgAggregateInputType = {
    id?: true
  }

  export type CreatureSumAggregateInputType = {
    id?: true
  }

  export type CreatureMinAggregateInputType = {
    id?: true
    espece?: true
    forces?: true
    faiblesses?: true
    dangerosite?: true
  }

  export type CreatureMaxAggregateInputType = {
    id?: true
    espece?: true
    forces?: true
    faiblesses?: true
    dangerosite?: true
  }

  export type CreatureCountAggregateInputType = {
    id?: true
    espece?: true
    forces?: true
    faiblesses?: true
    dangerosite?: true
    _all?: true
  }

  export type CreatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creature to aggregate.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creatures
    **/
    _count?: true | CreatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureMaxAggregateInputType
  }

  export type GetCreatureAggregateType<T extends CreatureAggregateArgs> = {
        [P in keyof T & keyof AggregateCreature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreature[P]>
      : GetScalarType<T[P], AggregateCreature[P]>
  }




  export type CreatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithAggregationInput | CreatureOrderByWithAggregationInput[]
    by: CreatureScalarFieldEnum[] | CreatureScalarFieldEnum
    having?: CreatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureCountAggregateInputType | true
    _avg?: CreatureAvgAggregateInputType
    _sum?: CreatureSumAggregateInputType
    _min?: CreatureMinAggregateInputType
    _max?: CreatureMaxAggregateInputType
  }

  export type CreatureGroupByOutputType = {
    id: number
    espece: string
    forces: string | null
    faiblesses: string | null
    dangerosite: string | null
    _count: CreatureCountAggregateOutputType | null
    _avg: CreatureAvgAggregateOutputType | null
    _sum: CreatureSumAggregateOutputType | null
    _min: CreatureMinAggregateOutputType | null
    _max: CreatureMaxAggregateOutputType | null
  }

  type GetCreatureGroupByPayload<T extends CreatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureGroupByOutputType[P]>
        }
      >
    >


  export type CreatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    espece?: boolean
    forces?: boolean
    faiblesses?: boolean
    dangerosite?: boolean
    batailles?: boolean | Creature$bataillesArgs<ExtArgs>
    _count?: boolean | CreatureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    espece?: boolean
    forces?: boolean
    faiblesses?: boolean
    dangerosite?: boolean
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectScalar = {
    id?: boolean
    espece?: boolean
    forces?: boolean
    faiblesses?: boolean
    dangerosite?: boolean
  }

  export type CreatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batailles?: boolean | Creature$bataillesArgs<ExtArgs>
    _count?: boolean | CreatureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CreaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Creature"
    objects: {
      batailles: Prisma.$CreatureBataillePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      espece: string
      forces: string | null
      faiblesses: string | null
      dangerosite: string | null
    }, ExtArgs["result"]["creature"]>
    composites: {}
  }

  type CreatureGetPayload<S extends boolean | null | undefined | CreatureDefaultArgs> = $Result.GetResult<Prisma.$CreaturePayload, S>

  type CreatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreatureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreatureCountAggregateInputType | true
    }

  export interface CreatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Creature'], meta: { name: 'Creature' } }
    /**
     * Find zero or one Creature that matches the filter.
     * @param {CreatureFindUniqueArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureFindUniqueArgs>(args: SelectSubset<T, CreatureFindUniqueArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Creature that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreatureFindUniqueOrThrowArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Creature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindFirstArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureFindFirstArgs>(args?: SelectSubset<T, CreatureFindFirstArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Creature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindFirstOrThrowArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Creatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creatures
     * const creatures = await prisma.creature.findMany()
     * 
     * // Get first 10 Creatures
     * const creatures = await prisma.creature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureWithIdOnly = await prisma.creature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureFindManyArgs>(args?: SelectSubset<T, CreatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Creature.
     * @param {CreatureCreateArgs} args - Arguments to create a Creature.
     * @example
     * // Create one Creature
     * const Creature = await prisma.creature.create({
     *   data: {
     *     // ... data to create a Creature
     *   }
     * })
     * 
     */
    create<T extends CreatureCreateArgs>(args: SelectSubset<T, CreatureCreateArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Creatures.
     * @param {CreatureCreateManyArgs} args - Arguments to create many Creatures.
     * @example
     * // Create many Creatures
     * const creature = await prisma.creature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureCreateManyArgs>(args?: SelectSubset<T, CreatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Creatures and returns the data saved in the database.
     * @param {CreatureCreateManyAndReturnArgs} args - Arguments to create many Creatures.
     * @example
     * // Create many Creatures
     * const creature = await prisma.creature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Creatures and only return the `id`
     * const creatureWithIdOnly = await prisma.creature.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Creature.
     * @param {CreatureDeleteArgs} args - Arguments to delete one Creature.
     * @example
     * // Delete one Creature
     * const Creature = await prisma.creature.delete({
     *   where: {
     *     // ... filter to delete one Creature
     *   }
     * })
     * 
     */
    delete<T extends CreatureDeleteArgs>(args: SelectSubset<T, CreatureDeleteArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Creature.
     * @param {CreatureUpdateArgs} args - Arguments to update one Creature.
     * @example
     * // Update one Creature
     * const creature = await prisma.creature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureUpdateArgs>(args: SelectSubset<T, CreatureUpdateArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Creatures.
     * @param {CreatureDeleteManyArgs} args - Arguments to filter Creatures to delete.
     * @example
     * // Delete a few Creatures
     * const { count } = await prisma.creature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureDeleteManyArgs>(args?: SelectSubset<T, CreatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creatures
     * const creature = await prisma.creature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureUpdateManyArgs>(args: SelectSubset<T, CreatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Creature.
     * @param {CreatureUpsertArgs} args - Arguments to update or create a Creature.
     * @example
     * // Update or create a Creature
     * const creature = await prisma.creature.upsert({
     *   create: {
     *     // ... data to create a Creature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creature we want to update
     *   }
     * })
     */
    upsert<T extends CreatureUpsertArgs>(args: SelectSubset<T, CreatureUpsertArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Creatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureCountArgs} args - Arguments to filter Creatures to count.
     * @example
     * // Count the number of Creatures
     * const count = await prisma.creature.count({
     *   where: {
     *     // ... the filter for the Creatures we want to count
     *   }
     * })
    **/
    count<T extends CreatureCountArgs>(
      args?: Subset<T, CreatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureAggregateArgs>(args: Subset<T, CreatureAggregateArgs>): Prisma.PrismaPromise<GetCreatureAggregateType<T>>

    /**
     * Group by Creature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureGroupByArgs['orderBy'] }
        : { orderBy?: CreatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Creature model
   */
  readonly fields: CreatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Creature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batailles<T extends Creature$bataillesArgs<ExtArgs> = {}>(args?: Subset<T, Creature$bataillesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Creature model
   */ 
  interface CreatureFieldRefs {
    readonly id: FieldRef<"Creature", 'Int'>
    readonly espece: FieldRef<"Creature", 'String'>
    readonly forces: FieldRef<"Creature", 'String'>
    readonly faiblesses: FieldRef<"Creature", 'String'>
    readonly dangerosite: FieldRef<"Creature", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Creature findUnique
   */
  export type CreatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature findUniqueOrThrow
   */
  export type CreatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature findFirst
   */
  export type CreatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creatures.
     */
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature findFirstOrThrow
   */
  export type CreatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creatures.
     */
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature findMany
   */
  export type CreatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creatures to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature create
   */
  export type CreatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Creature.
     */
    data: XOR<CreatureCreateInput, CreatureUncheckedCreateInput>
  }

  /**
   * Creature createMany
   */
  export type CreatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creatures.
     */
    data: CreatureCreateManyInput | CreatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creature createManyAndReturn
   */
  export type CreatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Creatures.
     */
    data: CreatureCreateManyInput | CreatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creature update
   */
  export type CreatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Creature.
     */
    data: XOR<CreatureUpdateInput, CreatureUncheckedUpdateInput>
    /**
     * Choose, which Creature to update.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature updateMany
   */
  export type CreatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creatures.
     */
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyInput>
    /**
     * Filter which Creatures to update
     */
    where?: CreatureWhereInput
  }

  /**
   * Creature upsert
   */
  export type CreatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Creature to update in case it exists.
     */
    where: CreatureWhereUniqueInput
    /**
     * In case the Creature found by the `where` argument doesn't exist, create a new Creature with this data.
     */
    create: XOR<CreatureCreateInput, CreatureUncheckedCreateInput>
    /**
     * In case the Creature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureUpdateInput, CreatureUncheckedUpdateInput>
  }

  /**
   * Creature delete
   */
  export type CreatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter which Creature to delete.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature deleteMany
   */
  export type CreatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creatures to delete
     */
    where?: CreatureWhereInput
  }

  /**
   * Creature.batailles
   */
  export type Creature$bataillesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    where?: CreatureBatailleWhereInput
    orderBy?: CreatureBatailleOrderByWithRelationInput | CreatureBatailleOrderByWithRelationInput[]
    cursor?: CreatureBatailleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureBatailleScalarFieldEnum | CreatureBatailleScalarFieldEnum[]
  }

  /**
   * Creature without action
   */
  export type CreatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
  }


  /**
   * Model EcoleMagie
   */

  export type AggregateEcoleMagie = {
    _count: EcoleMagieCountAggregateOutputType | null
    _avg: EcoleMagieAvgAggregateOutputType | null
    _sum: EcoleMagieSumAggregateOutputType | null
    _min: EcoleMagieMinAggregateOutputType | null
    _max: EcoleMagieMaxAggregateOutputType | null
  }

  export type EcoleMagieAvgAggregateOutputType = {
    id: number | null
  }

  export type EcoleMagieSumAggregateOutputType = {
    id: number | null
  }

  export type EcoleMagieMinAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type EcoleMagieMaxAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type EcoleMagieCountAggregateOutputType = {
    id: number
    nom: number
    _all: number
  }


  export type EcoleMagieAvgAggregateInputType = {
    id?: true
  }

  export type EcoleMagieSumAggregateInputType = {
    id?: true
  }

  export type EcoleMagieMinAggregateInputType = {
    id?: true
    nom?: true
  }

  export type EcoleMagieMaxAggregateInputType = {
    id?: true
    nom?: true
  }

  export type EcoleMagieCountAggregateInputType = {
    id?: true
    nom?: true
    _all?: true
  }

  export type EcoleMagieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EcoleMagie to aggregate.
     */
    where?: EcoleMagieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcoleMagies to fetch.
     */
    orderBy?: EcoleMagieOrderByWithRelationInput | EcoleMagieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EcoleMagieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcoleMagies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcoleMagies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EcoleMagies
    **/
    _count?: true | EcoleMagieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EcoleMagieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EcoleMagieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EcoleMagieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EcoleMagieMaxAggregateInputType
  }

  export type GetEcoleMagieAggregateType<T extends EcoleMagieAggregateArgs> = {
        [P in keyof T & keyof AggregateEcoleMagie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEcoleMagie[P]>
      : GetScalarType<T[P], AggregateEcoleMagie[P]>
  }




  export type EcoleMagieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcoleMagieWhereInput
    orderBy?: EcoleMagieOrderByWithAggregationInput | EcoleMagieOrderByWithAggregationInput[]
    by: EcoleMagieScalarFieldEnum[] | EcoleMagieScalarFieldEnum
    having?: EcoleMagieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EcoleMagieCountAggregateInputType | true
    _avg?: EcoleMagieAvgAggregateInputType
    _sum?: EcoleMagieSumAggregateInputType
    _min?: EcoleMagieMinAggregateInputType
    _max?: EcoleMagieMaxAggregateInputType
  }

  export type EcoleMagieGroupByOutputType = {
    id: number
    nom: string
    _count: EcoleMagieCountAggregateOutputType | null
    _avg: EcoleMagieAvgAggregateOutputType | null
    _sum: EcoleMagieSumAggregateOutputType | null
    _min: EcoleMagieMinAggregateOutputType | null
    _max: EcoleMagieMaxAggregateOutputType | null
  }

  type GetEcoleMagieGroupByPayload<T extends EcoleMagieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EcoleMagieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EcoleMagieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EcoleMagieGroupByOutputType[P]>
            : GetScalarType<T[P], EcoleMagieGroupByOutputType[P]>
        }
      >
    >


  export type EcoleMagieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    sorts?: boolean | EcoleMagie$sortsArgs<ExtArgs>
    _count?: boolean | EcoleMagieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ecoleMagie"]>

  export type EcoleMagieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
  }, ExtArgs["result"]["ecoleMagie"]>

  export type EcoleMagieSelectScalar = {
    id?: boolean
    nom?: boolean
  }

  export type EcoleMagieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sorts?: boolean | EcoleMagie$sortsArgs<ExtArgs>
    _count?: boolean | EcoleMagieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EcoleMagieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EcoleMagiePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EcoleMagie"
    objects: {
      sorts: Prisma.$SortPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
    }, ExtArgs["result"]["ecoleMagie"]>
    composites: {}
  }

  type EcoleMagieGetPayload<S extends boolean | null | undefined | EcoleMagieDefaultArgs> = $Result.GetResult<Prisma.$EcoleMagiePayload, S>

  type EcoleMagieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EcoleMagieFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EcoleMagieCountAggregateInputType | true
    }

  export interface EcoleMagieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EcoleMagie'], meta: { name: 'EcoleMagie' } }
    /**
     * Find zero or one EcoleMagie that matches the filter.
     * @param {EcoleMagieFindUniqueArgs} args - Arguments to find a EcoleMagie
     * @example
     * // Get one EcoleMagie
     * const ecoleMagie = await prisma.ecoleMagie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EcoleMagieFindUniqueArgs>(args: SelectSubset<T, EcoleMagieFindUniqueArgs<ExtArgs>>): Prisma__EcoleMagieClient<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EcoleMagie that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EcoleMagieFindUniqueOrThrowArgs} args - Arguments to find a EcoleMagie
     * @example
     * // Get one EcoleMagie
     * const ecoleMagie = await prisma.ecoleMagie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EcoleMagieFindUniqueOrThrowArgs>(args: SelectSubset<T, EcoleMagieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EcoleMagieClient<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EcoleMagie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoleMagieFindFirstArgs} args - Arguments to find a EcoleMagie
     * @example
     * // Get one EcoleMagie
     * const ecoleMagie = await prisma.ecoleMagie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EcoleMagieFindFirstArgs>(args?: SelectSubset<T, EcoleMagieFindFirstArgs<ExtArgs>>): Prisma__EcoleMagieClient<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EcoleMagie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoleMagieFindFirstOrThrowArgs} args - Arguments to find a EcoleMagie
     * @example
     * // Get one EcoleMagie
     * const ecoleMagie = await prisma.ecoleMagie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EcoleMagieFindFirstOrThrowArgs>(args?: SelectSubset<T, EcoleMagieFindFirstOrThrowArgs<ExtArgs>>): Prisma__EcoleMagieClient<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EcoleMagies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoleMagieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EcoleMagies
     * const ecoleMagies = await prisma.ecoleMagie.findMany()
     * 
     * // Get first 10 EcoleMagies
     * const ecoleMagies = await prisma.ecoleMagie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ecoleMagieWithIdOnly = await prisma.ecoleMagie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EcoleMagieFindManyArgs>(args?: SelectSubset<T, EcoleMagieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EcoleMagie.
     * @param {EcoleMagieCreateArgs} args - Arguments to create a EcoleMagie.
     * @example
     * // Create one EcoleMagie
     * const EcoleMagie = await prisma.ecoleMagie.create({
     *   data: {
     *     // ... data to create a EcoleMagie
     *   }
     * })
     * 
     */
    create<T extends EcoleMagieCreateArgs>(args: SelectSubset<T, EcoleMagieCreateArgs<ExtArgs>>): Prisma__EcoleMagieClient<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EcoleMagies.
     * @param {EcoleMagieCreateManyArgs} args - Arguments to create many EcoleMagies.
     * @example
     * // Create many EcoleMagies
     * const ecoleMagie = await prisma.ecoleMagie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EcoleMagieCreateManyArgs>(args?: SelectSubset<T, EcoleMagieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EcoleMagies and returns the data saved in the database.
     * @param {EcoleMagieCreateManyAndReturnArgs} args - Arguments to create many EcoleMagies.
     * @example
     * // Create many EcoleMagies
     * const ecoleMagie = await prisma.ecoleMagie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EcoleMagies and only return the `id`
     * const ecoleMagieWithIdOnly = await prisma.ecoleMagie.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EcoleMagieCreateManyAndReturnArgs>(args?: SelectSubset<T, EcoleMagieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EcoleMagie.
     * @param {EcoleMagieDeleteArgs} args - Arguments to delete one EcoleMagie.
     * @example
     * // Delete one EcoleMagie
     * const EcoleMagie = await prisma.ecoleMagie.delete({
     *   where: {
     *     // ... filter to delete one EcoleMagie
     *   }
     * })
     * 
     */
    delete<T extends EcoleMagieDeleteArgs>(args: SelectSubset<T, EcoleMagieDeleteArgs<ExtArgs>>): Prisma__EcoleMagieClient<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EcoleMagie.
     * @param {EcoleMagieUpdateArgs} args - Arguments to update one EcoleMagie.
     * @example
     * // Update one EcoleMagie
     * const ecoleMagie = await prisma.ecoleMagie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EcoleMagieUpdateArgs>(args: SelectSubset<T, EcoleMagieUpdateArgs<ExtArgs>>): Prisma__EcoleMagieClient<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EcoleMagies.
     * @param {EcoleMagieDeleteManyArgs} args - Arguments to filter EcoleMagies to delete.
     * @example
     * // Delete a few EcoleMagies
     * const { count } = await prisma.ecoleMagie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EcoleMagieDeleteManyArgs>(args?: SelectSubset<T, EcoleMagieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EcoleMagies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoleMagieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EcoleMagies
     * const ecoleMagie = await prisma.ecoleMagie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EcoleMagieUpdateManyArgs>(args: SelectSubset<T, EcoleMagieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EcoleMagie.
     * @param {EcoleMagieUpsertArgs} args - Arguments to update or create a EcoleMagie.
     * @example
     * // Update or create a EcoleMagie
     * const ecoleMagie = await prisma.ecoleMagie.upsert({
     *   create: {
     *     // ... data to create a EcoleMagie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EcoleMagie we want to update
     *   }
     * })
     */
    upsert<T extends EcoleMagieUpsertArgs>(args: SelectSubset<T, EcoleMagieUpsertArgs<ExtArgs>>): Prisma__EcoleMagieClient<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EcoleMagies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoleMagieCountArgs} args - Arguments to filter EcoleMagies to count.
     * @example
     * // Count the number of EcoleMagies
     * const count = await prisma.ecoleMagie.count({
     *   where: {
     *     // ... the filter for the EcoleMagies we want to count
     *   }
     * })
    **/
    count<T extends EcoleMagieCountArgs>(
      args?: Subset<T, EcoleMagieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EcoleMagieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EcoleMagie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoleMagieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EcoleMagieAggregateArgs>(args: Subset<T, EcoleMagieAggregateArgs>): Prisma.PrismaPromise<GetEcoleMagieAggregateType<T>>

    /**
     * Group by EcoleMagie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcoleMagieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EcoleMagieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EcoleMagieGroupByArgs['orderBy'] }
        : { orderBy?: EcoleMagieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EcoleMagieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEcoleMagieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EcoleMagie model
   */
  readonly fields: EcoleMagieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EcoleMagie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EcoleMagieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sorts<T extends EcoleMagie$sortsArgs<ExtArgs> = {}>(args?: Subset<T, EcoleMagie$sortsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EcoleMagie model
   */ 
  interface EcoleMagieFieldRefs {
    readonly id: FieldRef<"EcoleMagie", 'Int'>
    readonly nom: FieldRef<"EcoleMagie", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EcoleMagie findUnique
   */
  export type EcoleMagieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
    /**
     * Filter, which EcoleMagie to fetch.
     */
    where: EcoleMagieWhereUniqueInput
  }

  /**
   * EcoleMagie findUniqueOrThrow
   */
  export type EcoleMagieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
    /**
     * Filter, which EcoleMagie to fetch.
     */
    where: EcoleMagieWhereUniqueInput
  }

  /**
   * EcoleMagie findFirst
   */
  export type EcoleMagieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
    /**
     * Filter, which EcoleMagie to fetch.
     */
    where?: EcoleMagieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcoleMagies to fetch.
     */
    orderBy?: EcoleMagieOrderByWithRelationInput | EcoleMagieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EcoleMagies.
     */
    cursor?: EcoleMagieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcoleMagies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcoleMagies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EcoleMagies.
     */
    distinct?: EcoleMagieScalarFieldEnum | EcoleMagieScalarFieldEnum[]
  }

  /**
   * EcoleMagie findFirstOrThrow
   */
  export type EcoleMagieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
    /**
     * Filter, which EcoleMagie to fetch.
     */
    where?: EcoleMagieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcoleMagies to fetch.
     */
    orderBy?: EcoleMagieOrderByWithRelationInput | EcoleMagieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EcoleMagies.
     */
    cursor?: EcoleMagieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcoleMagies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcoleMagies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EcoleMagies.
     */
    distinct?: EcoleMagieScalarFieldEnum | EcoleMagieScalarFieldEnum[]
  }

  /**
   * EcoleMagie findMany
   */
  export type EcoleMagieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
    /**
     * Filter, which EcoleMagies to fetch.
     */
    where?: EcoleMagieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcoleMagies to fetch.
     */
    orderBy?: EcoleMagieOrderByWithRelationInput | EcoleMagieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EcoleMagies.
     */
    cursor?: EcoleMagieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcoleMagies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcoleMagies.
     */
    skip?: number
    distinct?: EcoleMagieScalarFieldEnum | EcoleMagieScalarFieldEnum[]
  }

  /**
   * EcoleMagie create
   */
  export type EcoleMagieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
    /**
     * The data needed to create a EcoleMagie.
     */
    data: XOR<EcoleMagieCreateInput, EcoleMagieUncheckedCreateInput>
  }

  /**
   * EcoleMagie createMany
   */
  export type EcoleMagieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EcoleMagies.
     */
    data: EcoleMagieCreateManyInput | EcoleMagieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EcoleMagie createManyAndReturn
   */
  export type EcoleMagieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EcoleMagies.
     */
    data: EcoleMagieCreateManyInput | EcoleMagieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EcoleMagie update
   */
  export type EcoleMagieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
    /**
     * The data needed to update a EcoleMagie.
     */
    data: XOR<EcoleMagieUpdateInput, EcoleMagieUncheckedUpdateInput>
    /**
     * Choose, which EcoleMagie to update.
     */
    where: EcoleMagieWhereUniqueInput
  }

  /**
   * EcoleMagie updateMany
   */
  export type EcoleMagieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EcoleMagies.
     */
    data: XOR<EcoleMagieUpdateManyMutationInput, EcoleMagieUncheckedUpdateManyInput>
    /**
     * Filter which EcoleMagies to update
     */
    where?: EcoleMagieWhereInput
  }

  /**
   * EcoleMagie upsert
   */
  export type EcoleMagieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
    /**
     * The filter to search for the EcoleMagie to update in case it exists.
     */
    where: EcoleMagieWhereUniqueInput
    /**
     * In case the EcoleMagie found by the `where` argument doesn't exist, create a new EcoleMagie with this data.
     */
    create: XOR<EcoleMagieCreateInput, EcoleMagieUncheckedCreateInput>
    /**
     * In case the EcoleMagie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EcoleMagieUpdateInput, EcoleMagieUncheckedUpdateInput>
  }

  /**
   * EcoleMagie delete
   */
  export type EcoleMagieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
    /**
     * Filter which EcoleMagie to delete.
     */
    where: EcoleMagieWhereUniqueInput
  }

  /**
   * EcoleMagie deleteMany
   */
  export type EcoleMagieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EcoleMagies to delete
     */
    where?: EcoleMagieWhereInput
  }

  /**
   * EcoleMagie.sorts
   */
  export type EcoleMagie$sortsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
    where?: SortWhereInput
    orderBy?: SortOrderByWithRelationInput | SortOrderByWithRelationInput[]
    cursor?: SortWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SortScalarFieldEnum | SortScalarFieldEnum[]
  }

  /**
   * EcoleMagie without action
   */
  export type EcoleMagieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
  }


  /**
   * Model Sort
   */

  export type AggregateSort = {
    _count: SortCountAggregateOutputType | null
    _avg: SortAvgAggregateOutputType | null
    _sum: SortSumAggregateOutputType | null
    _min: SortMinAggregateOutputType | null
    _max: SortMaxAggregateOutputType | null
  }

  export type SortAvgAggregateOutputType = {
    id: number | null
    coutMana: number | null
    ecoleId: number | null
  }

  export type SortSumAggregateOutputType = {
    id: number | null
    coutMana: number | null
    ecoleId: number | null
  }

  export type SortMinAggregateOutputType = {
    id: number | null
    nom: string | null
    element: string | null
    coutMana: number | null
    niveauRequis: string | null
    estInterdit: boolean | null
    estRituel: boolean | null
    ecoleId: number | null
  }

  export type SortMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    element: string | null
    coutMana: number | null
    niveauRequis: string | null
    estInterdit: boolean | null
    estRituel: boolean | null
    ecoleId: number | null
  }

  export type SortCountAggregateOutputType = {
    id: number
    nom: number
    element: number
    coutMana: number
    niveauRequis: number
    estInterdit: number
    estRituel: number
    ecoleId: number
    _all: number
  }


  export type SortAvgAggregateInputType = {
    id?: true
    coutMana?: true
    ecoleId?: true
  }

  export type SortSumAggregateInputType = {
    id?: true
    coutMana?: true
    ecoleId?: true
  }

  export type SortMinAggregateInputType = {
    id?: true
    nom?: true
    element?: true
    coutMana?: true
    niveauRequis?: true
    estInterdit?: true
    estRituel?: true
    ecoleId?: true
  }

  export type SortMaxAggregateInputType = {
    id?: true
    nom?: true
    element?: true
    coutMana?: true
    niveauRequis?: true
    estInterdit?: true
    estRituel?: true
    ecoleId?: true
  }

  export type SortCountAggregateInputType = {
    id?: true
    nom?: true
    element?: true
    coutMana?: true
    niveauRequis?: true
    estInterdit?: true
    estRituel?: true
    ecoleId?: true
    _all?: true
  }

  export type SortAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sort to aggregate.
     */
    where?: SortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorts to fetch.
     */
    orderBy?: SortOrderByWithRelationInput | SortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sorts
    **/
    _count?: true | SortCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SortAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SortSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SortMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SortMaxAggregateInputType
  }

  export type GetSortAggregateType<T extends SortAggregateArgs> = {
        [P in keyof T & keyof AggregateSort]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSort[P]>
      : GetScalarType<T[P], AggregateSort[P]>
  }




  export type SortGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SortWhereInput
    orderBy?: SortOrderByWithAggregationInput | SortOrderByWithAggregationInput[]
    by: SortScalarFieldEnum[] | SortScalarFieldEnum
    having?: SortScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SortCountAggregateInputType | true
    _avg?: SortAvgAggregateInputType
    _sum?: SortSumAggregateInputType
    _min?: SortMinAggregateInputType
    _max?: SortMaxAggregateInputType
  }

  export type SortGroupByOutputType = {
    id: number
    nom: string
    element: string | null
    coutMana: number | null
    niveauRequis: string | null
    estInterdit: boolean
    estRituel: boolean
    ecoleId: number | null
    _count: SortCountAggregateOutputType | null
    _avg: SortAvgAggregateOutputType | null
    _sum: SortSumAggregateOutputType | null
    _min: SortMinAggregateOutputType | null
    _max: SortMaxAggregateOutputType | null
  }

  type GetSortGroupByPayload<T extends SortGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SortGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SortGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SortGroupByOutputType[P]>
            : GetScalarType<T[P], SortGroupByOutputType[P]>
        }
      >
    >


  export type SortSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    element?: boolean
    coutMana?: boolean
    niveauRequis?: boolean
    estInterdit?: boolean
    estRituel?: boolean
    ecoleId?: boolean
    ecole?: boolean | Sort$ecoleArgs<ExtArgs>
  }, ExtArgs["result"]["sort"]>

  export type SortSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    element?: boolean
    coutMana?: boolean
    niveauRequis?: boolean
    estInterdit?: boolean
    estRituel?: boolean
    ecoleId?: boolean
    ecole?: boolean | Sort$ecoleArgs<ExtArgs>
  }, ExtArgs["result"]["sort"]>

  export type SortSelectScalar = {
    id?: boolean
    nom?: boolean
    element?: boolean
    coutMana?: boolean
    niveauRequis?: boolean
    estInterdit?: boolean
    estRituel?: boolean
    ecoleId?: boolean
  }

  export type SortInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecole?: boolean | Sort$ecoleArgs<ExtArgs>
  }
  export type SortIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecole?: boolean | Sort$ecoleArgs<ExtArgs>
  }

  export type $SortPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sort"
    objects: {
      ecole: Prisma.$EcoleMagiePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      element: string | null
      coutMana: number | null
      niveauRequis: string | null
      estInterdit: boolean
      estRituel: boolean
      ecoleId: number | null
    }, ExtArgs["result"]["sort"]>
    composites: {}
  }

  type SortGetPayload<S extends boolean | null | undefined | SortDefaultArgs> = $Result.GetResult<Prisma.$SortPayload, S>

  type SortCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SortFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SortCountAggregateInputType | true
    }

  export interface SortDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sort'], meta: { name: 'Sort' } }
    /**
     * Find zero or one Sort that matches the filter.
     * @param {SortFindUniqueArgs} args - Arguments to find a Sort
     * @example
     * // Get one Sort
     * const sort = await prisma.sort.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SortFindUniqueArgs>(args: SelectSubset<T, SortFindUniqueArgs<ExtArgs>>): Prisma__SortClient<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sort that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SortFindUniqueOrThrowArgs} args - Arguments to find a Sort
     * @example
     * // Get one Sort
     * const sort = await prisma.sort.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SortFindUniqueOrThrowArgs>(args: SelectSubset<T, SortFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SortClient<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sort that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortFindFirstArgs} args - Arguments to find a Sort
     * @example
     * // Get one Sort
     * const sort = await prisma.sort.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SortFindFirstArgs>(args?: SelectSubset<T, SortFindFirstArgs<ExtArgs>>): Prisma__SortClient<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sort that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortFindFirstOrThrowArgs} args - Arguments to find a Sort
     * @example
     * // Get one Sort
     * const sort = await prisma.sort.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SortFindFirstOrThrowArgs>(args?: SelectSubset<T, SortFindFirstOrThrowArgs<ExtArgs>>): Prisma__SortClient<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sorts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sorts
     * const sorts = await prisma.sort.findMany()
     * 
     * // Get first 10 Sorts
     * const sorts = await prisma.sort.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sortWithIdOnly = await prisma.sort.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SortFindManyArgs>(args?: SelectSubset<T, SortFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sort.
     * @param {SortCreateArgs} args - Arguments to create a Sort.
     * @example
     * // Create one Sort
     * const Sort = await prisma.sort.create({
     *   data: {
     *     // ... data to create a Sort
     *   }
     * })
     * 
     */
    create<T extends SortCreateArgs>(args: SelectSubset<T, SortCreateArgs<ExtArgs>>): Prisma__SortClient<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sorts.
     * @param {SortCreateManyArgs} args - Arguments to create many Sorts.
     * @example
     * // Create many Sorts
     * const sort = await prisma.sort.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SortCreateManyArgs>(args?: SelectSubset<T, SortCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sorts and returns the data saved in the database.
     * @param {SortCreateManyAndReturnArgs} args - Arguments to create many Sorts.
     * @example
     * // Create many Sorts
     * const sort = await prisma.sort.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sorts and only return the `id`
     * const sortWithIdOnly = await prisma.sort.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SortCreateManyAndReturnArgs>(args?: SelectSubset<T, SortCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sort.
     * @param {SortDeleteArgs} args - Arguments to delete one Sort.
     * @example
     * // Delete one Sort
     * const Sort = await prisma.sort.delete({
     *   where: {
     *     // ... filter to delete one Sort
     *   }
     * })
     * 
     */
    delete<T extends SortDeleteArgs>(args: SelectSubset<T, SortDeleteArgs<ExtArgs>>): Prisma__SortClient<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sort.
     * @param {SortUpdateArgs} args - Arguments to update one Sort.
     * @example
     * // Update one Sort
     * const sort = await prisma.sort.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SortUpdateArgs>(args: SelectSubset<T, SortUpdateArgs<ExtArgs>>): Prisma__SortClient<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sorts.
     * @param {SortDeleteManyArgs} args - Arguments to filter Sorts to delete.
     * @example
     * // Delete a few Sorts
     * const { count } = await prisma.sort.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SortDeleteManyArgs>(args?: SelectSubset<T, SortDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sorts
     * const sort = await prisma.sort.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SortUpdateManyArgs>(args: SelectSubset<T, SortUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sort.
     * @param {SortUpsertArgs} args - Arguments to update or create a Sort.
     * @example
     * // Update or create a Sort
     * const sort = await prisma.sort.upsert({
     *   create: {
     *     // ... data to create a Sort
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sort we want to update
     *   }
     * })
     */
    upsert<T extends SortUpsertArgs>(args: SelectSubset<T, SortUpsertArgs<ExtArgs>>): Prisma__SortClient<$Result.GetResult<Prisma.$SortPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortCountArgs} args - Arguments to filter Sorts to count.
     * @example
     * // Count the number of Sorts
     * const count = await prisma.sort.count({
     *   where: {
     *     // ... the filter for the Sorts we want to count
     *   }
     * })
    **/
    count<T extends SortCountArgs>(
      args?: Subset<T, SortCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SortCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sort.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SortAggregateArgs>(args: Subset<T, SortAggregateArgs>): Prisma.PrismaPromise<GetSortAggregateType<T>>

    /**
     * Group by Sort.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SortGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SortGroupByArgs['orderBy'] }
        : { orderBy?: SortGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SortGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSortGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sort model
   */
  readonly fields: SortFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sort.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SortClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ecole<T extends Sort$ecoleArgs<ExtArgs> = {}>(args?: Subset<T, Sort$ecoleArgs<ExtArgs>>): Prisma__EcoleMagieClient<$Result.GetResult<Prisma.$EcoleMagiePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sort model
   */ 
  interface SortFieldRefs {
    readonly id: FieldRef<"Sort", 'Int'>
    readonly nom: FieldRef<"Sort", 'String'>
    readonly element: FieldRef<"Sort", 'String'>
    readonly coutMana: FieldRef<"Sort", 'Int'>
    readonly niveauRequis: FieldRef<"Sort", 'String'>
    readonly estInterdit: FieldRef<"Sort", 'Boolean'>
    readonly estRituel: FieldRef<"Sort", 'Boolean'>
    readonly ecoleId: FieldRef<"Sort", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Sort findUnique
   */
  export type SortFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
    /**
     * Filter, which Sort to fetch.
     */
    where: SortWhereUniqueInput
  }

  /**
   * Sort findUniqueOrThrow
   */
  export type SortFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
    /**
     * Filter, which Sort to fetch.
     */
    where: SortWhereUniqueInput
  }

  /**
   * Sort findFirst
   */
  export type SortFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
    /**
     * Filter, which Sort to fetch.
     */
    where?: SortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorts to fetch.
     */
    orderBy?: SortOrderByWithRelationInput | SortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sorts.
     */
    cursor?: SortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sorts.
     */
    distinct?: SortScalarFieldEnum | SortScalarFieldEnum[]
  }

  /**
   * Sort findFirstOrThrow
   */
  export type SortFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
    /**
     * Filter, which Sort to fetch.
     */
    where?: SortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorts to fetch.
     */
    orderBy?: SortOrderByWithRelationInput | SortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sorts.
     */
    cursor?: SortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sorts.
     */
    distinct?: SortScalarFieldEnum | SortScalarFieldEnum[]
  }

  /**
   * Sort findMany
   */
  export type SortFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
    /**
     * Filter, which Sorts to fetch.
     */
    where?: SortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorts to fetch.
     */
    orderBy?: SortOrderByWithRelationInput | SortOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sorts.
     */
    cursor?: SortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorts.
     */
    skip?: number
    distinct?: SortScalarFieldEnum | SortScalarFieldEnum[]
  }

  /**
   * Sort create
   */
  export type SortCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
    /**
     * The data needed to create a Sort.
     */
    data: XOR<SortCreateInput, SortUncheckedCreateInput>
  }

  /**
   * Sort createMany
   */
  export type SortCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sorts.
     */
    data: SortCreateManyInput | SortCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sort createManyAndReturn
   */
  export type SortCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sorts.
     */
    data: SortCreateManyInput | SortCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sort update
   */
  export type SortUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
    /**
     * The data needed to update a Sort.
     */
    data: XOR<SortUpdateInput, SortUncheckedUpdateInput>
    /**
     * Choose, which Sort to update.
     */
    where: SortWhereUniqueInput
  }

  /**
   * Sort updateMany
   */
  export type SortUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sorts.
     */
    data: XOR<SortUpdateManyMutationInput, SortUncheckedUpdateManyInput>
    /**
     * Filter which Sorts to update
     */
    where?: SortWhereInput
  }

  /**
   * Sort upsert
   */
  export type SortUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
    /**
     * The filter to search for the Sort to update in case it exists.
     */
    where: SortWhereUniqueInput
    /**
     * In case the Sort found by the `where` argument doesn't exist, create a new Sort with this data.
     */
    create: XOR<SortCreateInput, SortUncheckedCreateInput>
    /**
     * In case the Sort was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SortUpdateInput, SortUncheckedUpdateInput>
  }

  /**
   * Sort delete
   */
  export type SortDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
    /**
     * Filter which Sort to delete.
     */
    where: SortWhereUniqueInput
  }

  /**
   * Sort deleteMany
   */
  export type SortDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sorts to delete
     */
    where?: SortWhereInput
  }

  /**
   * Sort.ecole
   */
  export type Sort$ecoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcoleMagie
     */
    select?: EcoleMagieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcoleMagieInclude<ExtArgs> | null
    where?: EcoleMagieWhereInput
  }

  /**
   * Sort without action
   */
  export type SortDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sort
     */
    select?: SortSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SortInclude<ExtArgs> | null
  }


  /**
   * Model Maladie
   */

  export type AggregateMaladie = {
    _count: MaladieCountAggregateOutputType | null
    _avg: MaladieAvgAggregateOutputType | null
    _sum: MaladieSumAggregateOutputType | null
    _min: MaladieMinAggregateOutputType | null
    _max: MaladieMaxAggregateOutputType | null
  }

  export type MaladieAvgAggregateOutputType = {
    id: number | null
    tauxMortalite: number | null
  }

  export type MaladieSumAggregateOutputType = {
    id: number | null
    tauxMortalite: number | null
  }

  export type MaladieMinAggregateOutputType = {
    id: number | null
    nom: string | null
    effets: string | null
    contagion: string | null
    remede: string | null
    tauxMortalite: number | null
  }

  export type MaladieMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    effets: string | null
    contagion: string | null
    remede: string | null
    tauxMortalite: number | null
  }

  export type MaladieCountAggregateOutputType = {
    id: number
    nom: number
    effets: number
    contagion: number
    remede: number
    tauxMortalite: number
    _all: number
  }


  export type MaladieAvgAggregateInputType = {
    id?: true
    tauxMortalite?: true
  }

  export type MaladieSumAggregateInputType = {
    id?: true
    tauxMortalite?: true
  }

  export type MaladieMinAggregateInputType = {
    id?: true
    nom?: true
    effets?: true
    contagion?: true
    remede?: true
    tauxMortalite?: true
  }

  export type MaladieMaxAggregateInputType = {
    id?: true
    nom?: true
    effets?: true
    contagion?: true
    remede?: true
    tauxMortalite?: true
  }

  export type MaladieCountAggregateInputType = {
    id?: true
    nom?: true
    effets?: true
    contagion?: true
    remede?: true
    tauxMortalite?: true
    _all?: true
  }

  export type MaladieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maladie to aggregate.
     */
    where?: MaladieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maladies to fetch.
     */
    orderBy?: MaladieOrderByWithRelationInput | MaladieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaladieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maladies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maladies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maladies
    **/
    _count?: true | MaladieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaladieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaladieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaladieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaladieMaxAggregateInputType
  }

  export type GetMaladieAggregateType<T extends MaladieAggregateArgs> = {
        [P in keyof T & keyof AggregateMaladie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaladie[P]>
      : GetScalarType<T[P], AggregateMaladie[P]>
  }




  export type MaladieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaladieWhereInput
    orderBy?: MaladieOrderByWithAggregationInput | MaladieOrderByWithAggregationInput[]
    by: MaladieScalarFieldEnum[] | MaladieScalarFieldEnum
    having?: MaladieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaladieCountAggregateInputType | true
    _avg?: MaladieAvgAggregateInputType
    _sum?: MaladieSumAggregateInputType
    _min?: MaladieMinAggregateInputType
    _max?: MaladieMaxAggregateInputType
  }

  export type MaladieGroupByOutputType = {
    id: number
    nom: string
    effets: string | null
    contagion: string | null
    remede: string | null
    tauxMortalite: number | null
    _count: MaladieCountAggregateOutputType | null
    _avg: MaladieAvgAggregateOutputType | null
    _sum: MaladieSumAggregateOutputType | null
    _min: MaladieMinAggregateOutputType | null
    _max: MaladieMaxAggregateOutputType | null
  }

  type GetMaladieGroupByPayload<T extends MaladieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaladieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaladieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaladieGroupByOutputType[P]>
            : GetScalarType<T[P], MaladieGroupByOutputType[P]>
        }
      >
    >


  export type MaladieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    effets?: boolean
    contagion?: boolean
    remede?: boolean
    tauxMortalite?: boolean
    cas?: boolean | Maladie$casArgs<ExtArgs>
    _count?: boolean | MaladieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maladie"]>

  export type MaladieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    effets?: boolean
    contagion?: boolean
    remede?: boolean
    tauxMortalite?: boolean
  }, ExtArgs["result"]["maladie"]>

  export type MaladieSelectScalar = {
    id?: boolean
    nom?: boolean
    effets?: boolean
    contagion?: boolean
    remede?: boolean
    tauxMortalite?: boolean
  }

  export type MaladieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cas?: boolean | Maladie$casArgs<ExtArgs>
    _count?: boolean | MaladieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaladieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MaladiePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maladie"
    objects: {
      cas: Prisma.$PersonnageMaladiePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      effets: string | null
      contagion: string | null
      remede: string | null
      tauxMortalite: number | null
    }, ExtArgs["result"]["maladie"]>
    composites: {}
  }

  type MaladieGetPayload<S extends boolean | null | undefined | MaladieDefaultArgs> = $Result.GetResult<Prisma.$MaladiePayload, S>

  type MaladieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaladieFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaladieCountAggregateInputType | true
    }

  export interface MaladieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maladie'], meta: { name: 'Maladie' } }
    /**
     * Find zero or one Maladie that matches the filter.
     * @param {MaladieFindUniqueArgs} args - Arguments to find a Maladie
     * @example
     * // Get one Maladie
     * const maladie = await prisma.maladie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaladieFindUniqueArgs>(args: SelectSubset<T, MaladieFindUniqueArgs<ExtArgs>>): Prisma__MaladieClient<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Maladie that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaladieFindUniqueOrThrowArgs} args - Arguments to find a Maladie
     * @example
     * // Get one Maladie
     * const maladie = await prisma.maladie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaladieFindUniqueOrThrowArgs>(args: SelectSubset<T, MaladieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaladieClient<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Maladie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaladieFindFirstArgs} args - Arguments to find a Maladie
     * @example
     * // Get one Maladie
     * const maladie = await prisma.maladie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaladieFindFirstArgs>(args?: SelectSubset<T, MaladieFindFirstArgs<ExtArgs>>): Prisma__MaladieClient<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Maladie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaladieFindFirstOrThrowArgs} args - Arguments to find a Maladie
     * @example
     * // Get one Maladie
     * const maladie = await prisma.maladie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaladieFindFirstOrThrowArgs>(args?: SelectSubset<T, MaladieFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaladieClient<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Maladies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaladieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maladies
     * const maladies = await prisma.maladie.findMany()
     * 
     * // Get first 10 Maladies
     * const maladies = await prisma.maladie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maladieWithIdOnly = await prisma.maladie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaladieFindManyArgs>(args?: SelectSubset<T, MaladieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Maladie.
     * @param {MaladieCreateArgs} args - Arguments to create a Maladie.
     * @example
     * // Create one Maladie
     * const Maladie = await prisma.maladie.create({
     *   data: {
     *     // ... data to create a Maladie
     *   }
     * })
     * 
     */
    create<T extends MaladieCreateArgs>(args: SelectSubset<T, MaladieCreateArgs<ExtArgs>>): Prisma__MaladieClient<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Maladies.
     * @param {MaladieCreateManyArgs} args - Arguments to create many Maladies.
     * @example
     * // Create many Maladies
     * const maladie = await prisma.maladie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaladieCreateManyArgs>(args?: SelectSubset<T, MaladieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maladies and returns the data saved in the database.
     * @param {MaladieCreateManyAndReturnArgs} args - Arguments to create many Maladies.
     * @example
     * // Create many Maladies
     * const maladie = await prisma.maladie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maladies and only return the `id`
     * const maladieWithIdOnly = await prisma.maladie.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaladieCreateManyAndReturnArgs>(args?: SelectSubset<T, MaladieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Maladie.
     * @param {MaladieDeleteArgs} args - Arguments to delete one Maladie.
     * @example
     * // Delete one Maladie
     * const Maladie = await prisma.maladie.delete({
     *   where: {
     *     // ... filter to delete one Maladie
     *   }
     * })
     * 
     */
    delete<T extends MaladieDeleteArgs>(args: SelectSubset<T, MaladieDeleteArgs<ExtArgs>>): Prisma__MaladieClient<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Maladie.
     * @param {MaladieUpdateArgs} args - Arguments to update one Maladie.
     * @example
     * // Update one Maladie
     * const maladie = await prisma.maladie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaladieUpdateArgs>(args: SelectSubset<T, MaladieUpdateArgs<ExtArgs>>): Prisma__MaladieClient<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Maladies.
     * @param {MaladieDeleteManyArgs} args - Arguments to filter Maladies to delete.
     * @example
     * // Delete a few Maladies
     * const { count } = await prisma.maladie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaladieDeleteManyArgs>(args?: SelectSubset<T, MaladieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maladies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaladieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maladies
     * const maladie = await prisma.maladie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaladieUpdateManyArgs>(args: SelectSubset<T, MaladieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Maladie.
     * @param {MaladieUpsertArgs} args - Arguments to update or create a Maladie.
     * @example
     * // Update or create a Maladie
     * const maladie = await prisma.maladie.upsert({
     *   create: {
     *     // ... data to create a Maladie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maladie we want to update
     *   }
     * })
     */
    upsert<T extends MaladieUpsertArgs>(args: SelectSubset<T, MaladieUpsertArgs<ExtArgs>>): Prisma__MaladieClient<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Maladies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaladieCountArgs} args - Arguments to filter Maladies to count.
     * @example
     * // Count the number of Maladies
     * const count = await prisma.maladie.count({
     *   where: {
     *     // ... the filter for the Maladies we want to count
     *   }
     * })
    **/
    count<T extends MaladieCountArgs>(
      args?: Subset<T, MaladieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaladieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maladie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaladieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaladieAggregateArgs>(args: Subset<T, MaladieAggregateArgs>): Prisma.PrismaPromise<GetMaladieAggregateType<T>>

    /**
     * Group by Maladie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaladieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaladieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaladieGroupByArgs['orderBy'] }
        : { orderBy?: MaladieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaladieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaladieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maladie model
   */
  readonly fields: MaladieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maladie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaladieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cas<T extends Maladie$casArgs<ExtArgs> = {}>(args?: Subset<T, Maladie$casArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maladie model
   */ 
  interface MaladieFieldRefs {
    readonly id: FieldRef<"Maladie", 'Int'>
    readonly nom: FieldRef<"Maladie", 'String'>
    readonly effets: FieldRef<"Maladie", 'String'>
    readonly contagion: FieldRef<"Maladie", 'String'>
    readonly remede: FieldRef<"Maladie", 'String'>
    readonly tauxMortalite: FieldRef<"Maladie", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Maladie findUnique
   */
  export type MaladieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaladieInclude<ExtArgs> | null
    /**
     * Filter, which Maladie to fetch.
     */
    where: MaladieWhereUniqueInput
  }

  /**
   * Maladie findUniqueOrThrow
   */
  export type MaladieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaladieInclude<ExtArgs> | null
    /**
     * Filter, which Maladie to fetch.
     */
    where: MaladieWhereUniqueInput
  }

  /**
   * Maladie findFirst
   */
  export type MaladieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaladieInclude<ExtArgs> | null
    /**
     * Filter, which Maladie to fetch.
     */
    where?: MaladieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maladies to fetch.
     */
    orderBy?: MaladieOrderByWithRelationInput | MaladieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maladies.
     */
    cursor?: MaladieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maladies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maladies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maladies.
     */
    distinct?: MaladieScalarFieldEnum | MaladieScalarFieldEnum[]
  }

  /**
   * Maladie findFirstOrThrow
   */
  export type MaladieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaladieInclude<ExtArgs> | null
    /**
     * Filter, which Maladie to fetch.
     */
    where?: MaladieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maladies to fetch.
     */
    orderBy?: MaladieOrderByWithRelationInput | MaladieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maladies.
     */
    cursor?: MaladieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maladies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maladies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maladies.
     */
    distinct?: MaladieScalarFieldEnum | MaladieScalarFieldEnum[]
  }

  /**
   * Maladie findMany
   */
  export type MaladieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaladieInclude<ExtArgs> | null
    /**
     * Filter, which Maladies to fetch.
     */
    where?: MaladieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maladies to fetch.
     */
    orderBy?: MaladieOrderByWithRelationInput | MaladieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maladies.
     */
    cursor?: MaladieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maladies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maladies.
     */
    skip?: number
    distinct?: MaladieScalarFieldEnum | MaladieScalarFieldEnum[]
  }

  /**
   * Maladie create
   */
  export type MaladieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaladieInclude<ExtArgs> | null
    /**
     * The data needed to create a Maladie.
     */
    data: XOR<MaladieCreateInput, MaladieUncheckedCreateInput>
  }

  /**
   * Maladie createMany
   */
  export type MaladieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maladies.
     */
    data: MaladieCreateManyInput | MaladieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maladie createManyAndReturn
   */
  export type MaladieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Maladies.
     */
    data: MaladieCreateManyInput | MaladieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maladie update
   */
  export type MaladieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaladieInclude<ExtArgs> | null
    /**
     * The data needed to update a Maladie.
     */
    data: XOR<MaladieUpdateInput, MaladieUncheckedUpdateInput>
    /**
     * Choose, which Maladie to update.
     */
    where: MaladieWhereUniqueInput
  }

  /**
   * Maladie updateMany
   */
  export type MaladieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maladies.
     */
    data: XOR<MaladieUpdateManyMutationInput, MaladieUncheckedUpdateManyInput>
    /**
     * Filter which Maladies to update
     */
    where?: MaladieWhereInput
  }

  /**
   * Maladie upsert
   */
  export type MaladieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaladieInclude<ExtArgs> | null
    /**
     * The filter to search for the Maladie to update in case it exists.
     */
    where: MaladieWhereUniqueInput
    /**
     * In case the Maladie found by the `where` argument doesn't exist, create a new Maladie with this data.
     */
    create: XOR<MaladieCreateInput, MaladieUncheckedCreateInput>
    /**
     * In case the Maladie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaladieUpdateInput, MaladieUncheckedUpdateInput>
  }

  /**
   * Maladie delete
   */
  export type MaladieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaladieInclude<ExtArgs> | null
    /**
     * Filter which Maladie to delete.
     */
    where: MaladieWhereUniqueInput
  }

  /**
   * Maladie deleteMany
   */
  export type MaladieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maladies to delete
     */
    where?: MaladieWhereInput
  }

  /**
   * Maladie.cas
   */
  export type Maladie$casArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    where?: PersonnageMaladieWhereInput
    orderBy?: PersonnageMaladieOrderByWithRelationInput | PersonnageMaladieOrderByWithRelationInput[]
    cursor?: PersonnageMaladieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageMaladieScalarFieldEnum | PersonnageMaladieScalarFieldEnum[]
  }

  /**
   * Maladie without action
   */
  export type MaladieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maladie
     */
    select?: MaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaladieInclude<ExtArgs> | null
  }


  /**
   * Model PersonnageMaladie
   */

  export type AggregatePersonnageMaladie = {
    _count: PersonnageMaladieCountAggregateOutputType | null
    _avg: PersonnageMaladieAvgAggregateOutputType | null
    _sum: PersonnageMaladieSumAggregateOutputType | null
    _min: PersonnageMaladieMinAggregateOutputType | null
    _max: PersonnageMaladieMaxAggregateOutputType | null
  }

  export type PersonnageMaladieAvgAggregateOutputType = {
    personnageId: number | null
    maladieId: number | null
  }

  export type PersonnageMaladieSumAggregateOutputType = {
    personnageId: number | null
    maladieId: number | null
  }

  export type PersonnageMaladieMinAggregateOutputType = {
    personnageId: number | null
    maladieId: number | null
    dateDebut: Date | null
    dateFin: Date | null
    issue: string | null
  }

  export type PersonnageMaladieMaxAggregateOutputType = {
    personnageId: number | null
    maladieId: number | null
    dateDebut: Date | null
    dateFin: Date | null
    issue: string | null
  }

  export type PersonnageMaladieCountAggregateOutputType = {
    personnageId: number
    maladieId: number
    dateDebut: number
    dateFin: number
    issue: number
    _all: number
  }


  export type PersonnageMaladieAvgAggregateInputType = {
    personnageId?: true
    maladieId?: true
  }

  export type PersonnageMaladieSumAggregateInputType = {
    personnageId?: true
    maladieId?: true
  }

  export type PersonnageMaladieMinAggregateInputType = {
    personnageId?: true
    maladieId?: true
    dateDebut?: true
    dateFin?: true
    issue?: true
  }

  export type PersonnageMaladieMaxAggregateInputType = {
    personnageId?: true
    maladieId?: true
    dateDebut?: true
    dateFin?: true
    issue?: true
  }

  export type PersonnageMaladieCountAggregateInputType = {
    personnageId?: true
    maladieId?: true
    dateDebut?: true
    dateFin?: true
    issue?: true
    _all?: true
  }

  export type PersonnageMaladieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnageMaladie to aggregate.
     */
    where?: PersonnageMaladieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageMaladies to fetch.
     */
    orderBy?: PersonnageMaladieOrderByWithRelationInput | PersonnageMaladieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnageMaladieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageMaladies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageMaladies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonnageMaladies
    **/
    _count?: true | PersonnageMaladieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonnageMaladieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonnageMaladieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnageMaladieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnageMaladieMaxAggregateInputType
  }

  export type GetPersonnageMaladieAggregateType<T extends PersonnageMaladieAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnageMaladie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnageMaladie[P]>
      : GetScalarType<T[P], AggregatePersonnageMaladie[P]>
  }




  export type PersonnageMaladieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageMaladieWhereInput
    orderBy?: PersonnageMaladieOrderByWithAggregationInput | PersonnageMaladieOrderByWithAggregationInput[]
    by: PersonnageMaladieScalarFieldEnum[] | PersonnageMaladieScalarFieldEnum
    having?: PersonnageMaladieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnageMaladieCountAggregateInputType | true
    _avg?: PersonnageMaladieAvgAggregateInputType
    _sum?: PersonnageMaladieSumAggregateInputType
    _min?: PersonnageMaladieMinAggregateInputType
    _max?: PersonnageMaladieMaxAggregateInputType
  }

  export type PersonnageMaladieGroupByOutputType = {
    personnageId: number
    maladieId: number
    dateDebut: Date
    dateFin: Date | null
    issue: string | null
    _count: PersonnageMaladieCountAggregateOutputType | null
    _avg: PersonnageMaladieAvgAggregateOutputType | null
    _sum: PersonnageMaladieSumAggregateOutputType | null
    _min: PersonnageMaladieMinAggregateOutputType | null
    _max: PersonnageMaladieMaxAggregateOutputType | null
  }

  type GetPersonnageMaladieGroupByPayload<T extends PersonnageMaladieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnageMaladieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnageMaladieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnageMaladieGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnageMaladieGroupByOutputType[P]>
        }
      >
    >


  export type PersonnageMaladieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnageId?: boolean
    maladieId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    issue?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    maladie?: boolean | MaladieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnageMaladie"]>

  export type PersonnageMaladieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnageId?: boolean
    maladieId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    issue?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    maladie?: boolean | MaladieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnageMaladie"]>

  export type PersonnageMaladieSelectScalar = {
    personnageId?: boolean
    maladieId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    issue?: boolean
  }

  export type PersonnageMaladieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    maladie?: boolean | MaladieDefaultArgs<ExtArgs>
  }
  export type PersonnageMaladieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    maladie?: boolean | MaladieDefaultArgs<ExtArgs>
  }

  export type $PersonnageMaladiePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonnageMaladie"
    objects: {
      personnage: Prisma.$PersonnagePayload<ExtArgs>
      maladie: Prisma.$MaladiePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      personnageId: number
      maladieId: number
      dateDebut: Date
      dateFin: Date | null
      issue: string | null
    }, ExtArgs["result"]["personnageMaladie"]>
    composites: {}
  }

  type PersonnageMaladieGetPayload<S extends boolean | null | undefined | PersonnageMaladieDefaultArgs> = $Result.GetResult<Prisma.$PersonnageMaladiePayload, S>

  type PersonnageMaladieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonnageMaladieFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonnageMaladieCountAggregateInputType | true
    }

  export interface PersonnageMaladieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonnageMaladie'], meta: { name: 'PersonnageMaladie' } }
    /**
     * Find zero or one PersonnageMaladie that matches the filter.
     * @param {PersonnageMaladieFindUniqueArgs} args - Arguments to find a PersonnageMaladie
     * @example
     * // Get one PersonnageMaladie
     * const personnageMaladie = await prisma.personnageMaladie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnageMaladieFindUniqueArgs>(args: SelectSubset<T, PersonnageMaladieFindUniqueArgs<ExtArgs>>): Prisma__PersonnageMaladieClient<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PersonnageMaladie that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonnageMaladieFindUniqueOrThrowArgs} args - Arguments to find a PersonnageMaladie
     * @example
     * // Get one PersonnageMaladie
     * const personnageMaladie = await prisma.personnageMaladie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnageMaladieFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnageMaladieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnageMaladieClient<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PersonnageMaladie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageMaladieFindFirstArgs} args - Arguments to find a PersonnageMaladie
     * @example
     * // Get one PersonnageMaladie
     * const personnageMaladie = await prisma.personnageMaladie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnageMaladieFindFirstArgs>(args?: SelectSubset<T, PersonnageMaladieFindFirstArgs<ExtArgs>>): Prisma__PersonnageMaladieClient<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PersonnageMaladie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageMaladieFindFirstOrThrowArgs} args - Arguments to find a PersonnageMaladie
     * @example
     * // Get one PersonnageMaladie
     * const personnageMaladie = await prisma.personnageMaladie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnageMaladieFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnageMaladieFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnageMaladieClient<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PersonnageMaladies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageMaladieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonnageMaladies
     * const personnageMaladies = await prisma.personnageMaladie.findMany()
     * 
     * // Get first 10 PersonnageMaladies
     * const personnageMaladies = await prisma.personnageMaladie.findMany({ take: 10 })
     * 
     * // Only select the `personnageId`
     * const personnageMaladieWithPersonnageIdOnly = await prisma.personnageMaladie.findMany({ select: { personnageId: true } })
     * 
     */
    findMany<T extends PersonnageMaladieFindManyArgs>(args?: SelectSubset<T, PersonnageMaladieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PersonnageMaladie.
     * @param {PersonnageMaladieCreateArgs} args - Arguments to create a PersonnageMaladie.
     * @example
     * // Create one PersonnageMaladie
     * const PersonnageMaladie = await prisma.personnageMaladie.create({
     *   data: {
     *     // ... data to create a PersonnageMaladie
     *   }
     * })
     * 
     */
    create<T extends PersonnageMaladieCreateArgs>(args: SelectSubset<T, PersonnageMaladieCreateArgs<ExtArgs>>): Prisma__PersonnageMaladieClient<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PersonnageMaladies.
     * @param {PersonnageMaladieCreateManyArgs} args - Arguments to create many PersonnageMaladies.
     * @example
     * // Create many PersonnageMaladies
     * const personnageMaladie = await prisma.personnageMaladie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnageMaladieCreateManyArgs>(args?: SelectSubset<T, PersonnageMaladieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonnageMaladies and returns the data saved in the database.
     * @param {PersonnageMaladieCreateManyAndReturnArgs} args - Arguments to create many PersonnageMaladies.
     * @example
     * // Create many PersonnageMaladies
     * const personnageMaladie = await prisma.personnageMaladie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonnageMaladies and only return the `personnageId`
     * const personnageMaladieWithPersonnageIdOnly = await prisma.personnageMaladie.createManyAndReturn({ 
     *   select: { personnageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonnageMaladieCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonnageMaladieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PersonnageMaladie.
     * @param {PersonnageMaladieDeleteArgs} args - Arguments to delete one PersonnageMaladie.
     * @example
     * // Delete one PersonnageMaladie
     * const PersonnageMaladie = await prisma.personnageMaladie.delete({
     *   where: {
     *     // ... filter to delete one PersonnageMaladie
     *   }
     * })
     * 
     */
    delete<T extends PersonnageMaladieDeleteArgs>(args: SelectSubset<T, PersonnageMaladieDeleteArgs<ExtArgs>>): Prisma__PersonnageMaladieClient<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PersonnageMaladie.
     * @param {PersonnageMaladieUpdateArgs} args - Arguments to update one PersonnageMaladie.
     * @example
     * // Update one PersonnageMaladie
     * const personnageMaladie = await prisma.personnageMaladie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnageMaladieUpdateArgs>(args: SelectSubset<T, PersonnageMaladieUpdateArgs<ExtArgs>>): Prisma__PersonnageMaladieClient<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PersonnageMaladies.
     * @param {PersonnageMaladieDeleteManyArgs} args - Arguments to filter PersonnageMaladies to delete.
     * @example
     * // Delete a few PersonnageMaladies
     * const { count } = await prisma.personnageMaladie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnageMaladieDeleteManyArgs>(args?: SelectSubset<T, PersonnageMaladieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonnageMaladies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageMaladieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonnageMaladies
     * const personnageMaladie = await prisma.personnageMaladie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnageMaladieUpdateManyArgs>(args: SelectSubset<T, PersonnageMaladieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonnageMaladie.
     * @param {PersonnageMaladieUpsertArgs} args - Arguments to update or create a PersonnageMaladie.
     * @example
     * // Update or create a PersonnageMaladie
     * const personnageMaladie = await prisma.personnageMaladie.upsert({
     *   create: {
     *     // ... data to create a PersonnageMaladie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonnageMaladie we want to update
     *   }
     * })
     */
    upsert<T extends PersonnageMaladieUpsertArgs>(args: SelectSubset<T, PersonnageMaladieUpsertArgs<ExtArgs>>): Prisma__PersonnageMaladieClient<$Result.GetResult<Prisma.$PersonnageMaladiePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PersonnageMaladies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageMaladieCountArgs} args - Arguments to filter PersonnageMaladies to count.
     * @example
     * // Count the number of PersonnageMaladies
     * const count = await prisma.personnageMaladie.count({
     *   where: {
     *     // ... the filter for the PersonnageMaladies we want to count
     *   }
     * })
    **/
    count<T extends PersonnageMaladieCountArgs>(
      args?: Subset<T, PersonnageMaladieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnageMaladieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonnageMaladie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageMaladieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnageMaladieAggregateArgs>(args: Subset<T, PersonnageMaladieAggregateArgs>): Prisma.PrismaPromise<GetPersonnageMaladieAggregateType<T>>

    /**
     * Group by PersonnageMaladie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageMaladieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnageMaladieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnageMaladieGroupByArgs['orderBy'] }
        : { orderBy?: PersonnageMaladieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnageMaladieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnageMaladieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonnageMaladie model
   */
  readonly fields: PersonnageMaladieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonnageMaladie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnageMaladieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnage<T extends PersonnageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnageDefaultArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    maladie<T extends MaladieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaladieDefaultArgs<ExtArgs>>): Prisma__MaladieClient<$Result.GetResult<Prisma.$MaladiePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonnageMaladie model
   */ 
  interface PersonnageMaladieFieldRefs {
    readonly personnageId: FieldRef<"PersonnageMaladie", 'Int'>
    readonly maladieId: FieldRef<"PersonnageMaladie", 'Int'>
    readonly dateDebut: FieldRef<"PersonnageMaladie", 'DateTime'>
    readonly dateFin: FieldRef<"PersonnageMaladie", 'DateTime'>
    readonly issue: FieldRef<"PersonnageMaladie", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PersonnageMaladie findUnique
   */
  export type PersonnageMaladieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageMaladie to fetch.
     */
    where: PersonnageMaladieWhereUniqueInput
  }

  /**
   * PersonnageMaladie findUniqueOrThrow
   */
  export type PersonnageMaladieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageMaladie to fetch.
     */
    where: PersonnageMaladieWhereUniqueInput
  }

  /**
   * PersonnageMaladie findFirst
   */
  export type PersonnageMaladieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageMaladie to fetch.
     */
    where?: PersonnageMaladieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageMaladies to fetch.
     */
    orderBy?: PersonnageMaladieOrderByWithRelationInput | PersonnageMaladieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnageMaladies.
     */
    cursor?: PersonnageMaladieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageMaladies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageMaladies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnageMaladies.
     */
    distinct?: PersonnageMaladieScalarFieldEnum | PersonnageMaladieScalarFieldEnum[]
  }

  /**
   * PersonnageMaladie findFirstOrThrow
   */
  export type PersonnageMaladieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageMaladie to fetch.
     */
    where?: PersonnageMaladieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageMaladies to fetch.
     */
    orderBy?: PersonnageMaladieOrderByWithRelationInput | PersonnageMaladieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnageMaladies.
     */
    cursor?: PersonnageMaladieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageMaladies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageMaladies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnageMaladies.
     */
    distinct?: PersonnageMaladieScalarFieldEnum | PersonnageMaladieScalarFieldEnum[]
  }

  /**
   * PersonnageMaladie findMany
   */
  export type PersonnageMaladieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageMaladies to fetch.
     */
    where?: PersonnageMaladieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageMaladies to fetch.
     */
    orderBy?: PersonnageMaladieOrderByWithRelationInput | PersonnageMaladieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonnageMaladies.
     */
    cursor?: PersonnageMaladieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageMaladies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageMaladies.
     */
    skip?: number
    distinct?: PersonnageMaladieScalarFieldEnum | PersonnageMaladieScalarFieldEnum[]
  }

  /**
   * PersonnageMaladie create
   */
  export type PersonnageMaladieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonnageMaladie.
     */
    data: XOR<PersonnageMaladieCreateInput, PersonnageMaladieUncheckedCreateInput>
  }

  /**
   * PersonnageMaladie createMany
   */
  export type PersonnageMaladieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonnageMaladies.
     */
    data: PersonnageMaladieCreateManyInput | PersonnageMaladieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonnageMaladie createManyAndReturn
   */
  export type PersonnageMaladieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PersonnageMaladies.
     */
    data: PersonnageMaladieCreateManyInput | PersonnageMaladieCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonnageMaladie update
   */
  export type PersonnageMaladieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonnageMaladie.
     */
    data: XOR<PersonnageMaladieUpdateInput, PersonnageMaladieUncheckedUpdateInput>
    /**
     * Choose, which PersonnageMaladie to update.
     */
    where: PersonnageMaladieWhereUniqueInput
  }

  /**
   * PersonnageMaladie updateMany
   */
  export type PersonnageMaladieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonnageMaladies.
     */
    data: XOR<PersonnageMaladieUpdateManyMutationInput, PersonnageMaladieUncheckedUpdateManyInput>
    /**
     * Filter which PersonnageMaladies to update
     */
    where?: PersonnageMaladieWhereInput
  }

  /**
   * PersonnageMaladie upsert
   */
  export type PersonnageMaladieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonnageMaladie to update in case it exists.
     */
    where: PersonnageMaladieWhereUniqueInput
    /**
     * In case the PersonnageMaladie found by the `where` argument doesn't exist, create a new PersonnageMaladie with this data.
     */
    create: XOR<PersonnageMaladieCreateInput, PersonnageMaladieUncheckedCreateInput>
    /**
     * In case the PersonnageMaladie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnageMaladieUpdateInput, PersonnageMaladieUncheckedUpdateInput>
  }

  /**
   * PersonnageMaladie delete
   */
  export type PersonnageMaladieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
    /**
     * Filter which PersonnageMaladie to delete.
     */
    where: PersonnageMaladieWhereUniqueInput
  }

  /**
   * PersonnageMaladie deleteMany
   */
  export type PersonnageMaladieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnageMaladies to delete
     */
    where?: PersonnageMaladieWhereInput
  }

  /**
   * PersonnageMaladie without action
   */
  export type PersonnageMaladieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageMaladie
     */
    select?: PersonnageMaladieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageMaladieInclude<ExtArgs> | null
  }


  /**
   * Model Armee
   */

  export type AggregateArmee = {
    _count: ArmeeCountAggregateOutputType | null
    _avg: ArmeeAvgAggregateOutputType | null
    _sum: ArmeeSumAggregateOutputType | null
    _min: ArmeeMinAggregateOutputType | null
    _max: ArmeeMaxAggregateOutputType | null
  }

  export type ArmeeAvgAggregateOutputType = {
    id: number | null
    effectif: number | null
    domaineId: number | null
    commandantId: number | null
  }

  export type ArmeeSumAggregateOutputType = {
    id: number | null
    effectif: number | null
    domaineId: number | null
    commandantId: number | null
  }

  export type ArmeeMinAggregateOutputType = {
    id: number | null
    nom: string | null
    effectif: number | null
    composition: string | null
    moral: string | null
    etatApprovisionnement: string | null
    domaineId: number | null
    commandantId: number | null
  }

  export type ArmeeMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    effectif: number | null
    composition: string | null
    moral: string | null
    etatApprovisionnement: string | null
    domaineId: number | null
    commandantId: number | null
  }

  export type ArmeeCountAggregateOutputType = {
    id: number
    nom: number
    effectif: number
    composition: number
    moral: number
    etatApprovisionnement: number
    domaineId: number
    commandantId: number
    _all: number
  }


  export type ArmeeAvgAggregateInputType = {
    id?: true
    effectif?: true
    domaineId?: true
    commandantId?: true
  }

  export type ArmeeSumAggregateInputType = {
    id?: true
    effectif?: true
    domaineId?: true
    commandantId?: true
  }

  export type ArmeeMinAggregateInputType = {
    id?: true
    nom?: true
    effectif?: true
    composition?: true
    moral?: true
    etatApprovisionnement?: true
    domaineId?: true
    commandantId?: true
  }

  export type ArmeeMaxAggregateInputType = {
    id?: true
    nom?: true
    effectif?: true
    composition?: true
    moral?: true
    etatApprovisionnement?: true
    domaineId?: true
    commandantId?: true
  }

  export type ArmeeCountAggregateInputType = {
    id?: true
    nom?: true
    effectif?: true
    composition?: true
    moral?: true
    etatApprovisionnement?: true
    domaineId?: true
    commandantId?: true
    _all?: true
  }

  export type ArmeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Armee to aggregate.
     */
    where?: ArmeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armees to fetch.
     */
    orderBy?: ArmeeOrderByWithRelationInput | ArmeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArmeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Armees
    **/
    _count?: true | ArmeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArmeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArmeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArmeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArmeeMaxAggregateInputType
  }

  export type GetArmeeAggregateType<T extends ArmeeAggregateArgs> = {
        [P in keyof T & keyof AggregateArmee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArmee[P]>
      : GetScalarType<T[P], AggregateArmee[P]>
  }




  export type ArmeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArmeeWhereInput
    orderBy?: ArmeeOrderByWithAggregationInput | ArmeeOrderByWithAggregationInput[]
    by: ArmeeScalarFieldEnum[] | ArmeeScalarFieldEnum
    having?: ArmeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArmeeCountAggregateInputType | true
    _avg?: ArmeeAvgAggregateInputType
    _sum?: ArmeeSumAggregateInputType
    _min?: ArmeeMinAggregateInputType
    _max?: ArmeeMaxAggregateInputType
  }

  export type ArmeeGroupByOutputType = {
    id: number
    nom: string | null
    effectif: number | null
    composition: string | null
    moral: string | null
    etatApprovisionnement: string | null
    domaineId: number | null
    commandantId: number | null
    _count: ArmeeCountAggregateOutputType | null
    _avg: ArmeeAvgAggregateOutputType | null
    _sum: ArmeeSumAggregateOutputType | null
    _min: ArmeeMinAggregateOutputType | null
    _max: ArmeeMaxAggregateOutputType | null
  }

  type GetArmeeGroupByPayload<T extends ArmeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArmeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArmeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArmeeGroupByOutputType[P]>
            : GetScalarType<T[P], ArmeeGroupByOutputType[P]>
        }
      >
    >


  export type ArmeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    effectif?: boolean
    composition?: boolean
    moral?: boolean
    etatApprovisionnement?: boolean
    domaineId?: boolean
    commandantId?: boolean
    domaine?: boolean | Armee$domaineArgs<ExtArgs>
    commandant?: boolean | Armee$commandantArgs<ExtArgs>
    batailles?: boolean | Armee$bataillesArgs<ExtArgs>
    inventaires?: boolean | Armee$inventairesArgs<ExtArgs>
    _count?: boolean | ArmeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["armee"]>

  export type ArmeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    effectif?: boolean
    composition?: boolean
    moral?: boolean
    etatApprovisionnement?: boolean
    domaineId?: boolean
    commandantId?: boolean
    domaine?: boolean | Armee$domaineArgs<ExtArgs>
    commandant?: boolean | Armee$commandantArgs<ExtArgs>
  }, ExtArgs["result"]["armee"]>

  export type ArmeeSelectScalar = {
    id?: boolean
    nom?: boolean
    effectif?: boolean
    composition?: boolean
    moral?: boolean
    etatApprovisionnement?: boolean
    domaineId?: boolean
    commandantId?: boolean
  }

  export type ArmeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domaine?: boolean | Armee$domaineArgs<ExtArgs>
    commandant?: boolean | Armee$commandantArgs<ExtArgs>
    batailles?: boolean | Armee$bataillesArgs<ExtArgs>
    inventaires?: boolean | Armee$inventairesArgs<ExtArgs>
    _count?: boolean | ArmeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArmeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domaine?: boolean | Armee$domaineArgs<ExtArgs>
    commandant?: boolean | Armee$commandantArgs<ExtArgs>
  }

  export type $ArmeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Armee"
    objects: {
      domaine: Prisma.$DomainePayload<ExtArgs> | null
      commandant: Prisma.$PersonnagePayload<ExtArgs> | null
      batailles: Prisma.$ArmeeBataillePayload<ExtArgs>[]
      inventaires: Prisma.$InventairePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string | null
      effectif: number | null
      composition: string | null
      moral: string | null
      etatApprovisionnement: string | null
      domaineId: number | null
      commandantId: number | null
    }, ExtArgs["result"]["armee"]>
    composites: {}
  }

  type ArmeeGetPayload<S extends boolean | null | undefined | ArmeeDefaultArgs> = $Result.GetResult<Prisma.$ArmeePayload, S>

  type ArmeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArmeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArmeeCountAggregateInputType | true
    }

  export interface ArmeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Armee'], meta: { name: 'Armee' } }
    /**
     * Find zero or one Armee that matches the filter.
     * @param {ArmeeFindUniqueArgs} args - Arguments to find a Armee
     * @example
     * // Get one Armee
     * const armee = await prisma.armee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArmeeFindUniqueArgs>(args: SelectSubset<T, ArmeeFindUniqueArgs<ExtArgs>>): Prisma__ArmeeClient<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Armee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ArmeeFindUniqueOrThrowArgs} args - Arguments to find a Armee
     * @example
     * // Get one Armee
     * const armee = await prisma.armee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArmeeFindUniqueOrThrowArgs>(args: SelectSubset<T, ArmeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArmeeClient<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Armee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeFindFirstArgs} args - Arguments to find a Armee
     * @example
     * // Get one Armee
     * const armee = await prisma.armee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArmeeFindFirstArgs>(args?: SelectSubset<T, ArmeeFindFirstArgs<ExtArgs>>): Prisma__ArmeeClient<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Armee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeFindFirstOrThrowArgs} args - Arguments to find a Armee
     * @example
     * // Get one Armee
     * const armee = await prisma.armee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArmeeFindFirstOrThrowArgs>(args?: SelectSubset<T, ArmeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArmeeClient<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Armees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Armees
     * const armees = await prisma.armee.findMany()
     * 
     * // Get first 10 Armees
     * const armees = await prisma.armee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const armeeWithIdOnly = await prisma.armee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArmeeFindManyArgs>(args?: SelectSubset<T, ArmeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Armee.
     * @param {ArmeeCreateArgs} args - Arguments to create a Armee.
     * @example
     * // Create one Armee
     * const Armee = await prisma.armee.create({
     *   data: {
     *     // ... data to create a Armee
     *   }
     * })
     * 
     */
    create<T extends ArmeeCreateArgs>(args: SelectSubset<T, ArmeeCreateArgs<ExtArgs>>): Prisma__ArmeeClient<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Armees.
     * @param {ArmeeCreateManyArgs} args - Arguments to create many Armees.
     * @example
     * // Create many Armees
     * const armee = await prisma.armee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArmeeCreateManyArgs>(args?: SelectSubset<T, ArmeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Armees and returns the data saved in the database.
     * @param {ArmeeCreateManyAndReturnArgs} args - Arguments to create many Armees.
     * @example
     * // Create many Armees
     * const armee = await prisma.armee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Armees and only return the `id`
     * const armeeWithIdOnly = await prisma.armee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArmeeCreateManyAndReturnArgs>(args?: SelectSubset<T, ArmeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Armee.
     * @param {ArmeeDeleteArgs} args - Arguments to delete one Armee.
     * @example
     * // Delete one Armee
     * const Armee = await prisma.armee.delete({
     *   where: {
     *     // ... filter to delete one Armee
     *   }
     * })
     * 
     */
    delete<T extends ArmeeDeleteArgs>(args: SelectSubset<T, ArmeeDeleteArgs<ExtArgs>>): Prisma__ArmeeClient<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Armee.
     * @param {ArmeeUpdateArgs} args - Arguments to update one Armee.
     * @example
     * // Update one Armee
     * const armee = await prisma.armee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArmeeUpdateArgs>(args: SelectSubset<T, ArmeeUpdateArgs<ExtArgs>>): Prisma__ArmeeClient<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Armees.
     * @param {ArmeeDeleteManyArgs} args - Arguments to filter Armees to delete.
     * @example
     * // Delete a few Armees
     * const { count } = await prisma.armee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArmeeDeleteManyArgs>(args?: SelectSubset<T, ArmeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Armees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Armees
     * const armee = await prisma.armee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArmeeUpdateManyArgs>(args: SelectSubset<T, ArmeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Armee.
     * @param {ArmeeUpsertArgs} args - Arguments to update or create a Armee.
     * @example
     * // Update or create a Armee
     * const armee = await prisma.armee.upsert({
     *   create: {
     *     // ... data to create a Armee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Armee we want to update
     *   }
     * })
     */
    upsert<T extends ArmeeUpsertArgs>(args: SelectSubset<T, ArmeeUpsertArgs<ExtArgs>>): Prisma__ArmeeClient<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Armees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeCountArgs} args - Arguments to filter Armees to count.
     * @example
     * // Count the number of Armees
     * const count = await prisma.armee.count({
     *   where: {
     *     // ... the filter for the Armees we want to count
     *   }
     * })
    **/
    count<T extends ArmeeCountArgs>(
      args?: Subset<T, ArmeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArmeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Armee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArmeeAggregateArgs>(args: Subset<T, ArmeeAggregateArgs>): Prisma.PrismaPromise<GetArmeeAggregateType<T>>

    /**
     * Group by Armee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArmeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArmeeGroupByArgs['orderBy'] }
        : { orderBy?: ArmeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArmeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArmeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Armee model
   */
  readonly fields: ArmeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Armee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArmeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domaine<T extends Armee$domaineArgs<ExtArgs> = {}>(args?: Subset<T, Armee$domaineArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    commandant<T extends Armee$commandantArgs<ExtArgs> = {}>(args?: Subset<T, Armee$commandantArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    batailles<T extends Armee$bataillesArgs<ExtArgs> = {}>(args?: Subset<T, Armee$bataillesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "findMany"> | Null>
    inventaires<T extends Armee$inventairesArgs<ExtArgs> = {}>(args?: Subset<T, Armee$inventairesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Armee model
   */ 
  interface ArmeeFieldRefs {
    readonly id: FieldRef<"Armee", 'Int'>
    readonly nom: FieldRef<"Armee", 'String'>
    readonly effectif: FieldRef<"Armee", 'Int'>
    readonly composition: FieldRef<"Armee", 'String'>
    readonly moral: FieldRef<"Armee", 'String'>
    readonly etatApprovisionnement: FieldRef<"Armee", 'String'>
    readonly domaineId: FieldRef<"Armee", 'Int'>
    readonly commandantId: FieldRef<"Armee", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Armee findUnique
   */
  export type ArmeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    /**
     * Filter, which Armee to fetch.
     */
    where: ArmeeWhereUniqueInput
  }

  /**
   * Armee findUniqueOrThrow
   */
  export type ArmeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    /**
     * Filter, which Armee to fetch.
     */
    where: ArmeeWhereUniqueInput
  }

  /**
   * Armee findFirst
   */
  export type ArmeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    /**
     * Filter, which Armee to fetch.
     */
    where?: ArmeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armees to fetch.
     */
    orderBy?: ArmeeOrderByWithRelationInput | ArmeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Armees.
     */
    cursor?: ArmeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Armees.
     */
    distinct?: ArmeeScalarFieldEnum | ArmeeScalarFieldEnum[]
  }

  /**
   * Armee findFirstOrThrow
   */
  export type ArmeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    /**
     * Filter, which Armee to fetch.
     */
    where?: ArmeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armees to fetch.
     */
    orderBy?: ArmeeOrderByWithRelationInput | ArmeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Armees.
     */
    cursor?: ArmeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Armees.
     */
    distinct?: ArmeeScalarFieldEnum | ArmeeScalarFieldEnum[]
  }

  /**
   * Armee findMany
   */
  export type ArmeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    /**
     * Filter, which Armees to fetch.
     */
    where?: ArmeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Armees to fetch.
     */
    orderBy?: ArmeeOrderByWithRelationInput | ArmeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Armees.
     */
    cursor?: ArmeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Armees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Armees.
     */
    skip?: number
    distinct?: ArmeeScalarFieldEnum | ArmeeScalarFieldEnum[]
  }

  /**
   * Armee create
   */
  export type ArmeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Armee.
     */
    data?: XOR<ArmeeCreateInput, ArmeeUncheckedCreateInput>
  }

  /**
   * Armee createMany
   */
  export type ArmeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Armees.
     */
    data: ArmeeCreateManyInput | ArmeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Armee createManyAndReturn
   */
  export type ArmeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Armees.
     */
    data: ArmeeCreateManyInput | ArmeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Armee update
   */
  export type ArmeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Armee.
     */
    data: XOR<ArmeeUpdateInput, ArmeeUncheckedUpdateInput>
    /**
     * Choose, which Armee to update.
     */
    where: ArmeeWhereUniqueInput
  }

  /**
   * Armee updateMany
   */
  export type ArmeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Armees.
     */
    data: XOR<ArmeeUpdateManyMutationInput, ArmeeUncheckedUpdateManyInput>
    /**
     * Filter which Armees to update
     */
    where?: ArmeeWhereInput
  }

  /**
   * Armee upsert
   */
  export type ArmeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Armee to update in case it exists.
     */
    where: ArmeeWhereUniqueInput
    /**
     * In case the Armee found by the `where` argument doesn't exist, create a new Armee with this data.
     */
    create: XOR<ArmeeCreateInput, ArmeeUncheckedCreateInput>
    /**
     * In case the Armee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArmeeUpdateInput, ArmeeUncheckedUpdateInput>
  }

  /**
   * Armee delete
   */
  export type ArmeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    /**
     * Filter which Armee to delete.
     */
    where: ArmeeWhereUniqueInput
  }

  /**
   * Armee deleteMany
   */
  export type ArmeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Armees to delete
     */
    where?: ArmeeWhereInput
  }

  /**
   * Armee.domaine
   */
  export type Armee$domaineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domaine
     */
    select?: DomaineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomaineInclude<ExtArgs> | null
    where?: DomaineWhereInput
  }

  /**
   * Armee.commandant
   */
  export type Armee$commandantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnage
     */
    select?: PersonnageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageInclude<ExtArgs> | null
    where?: PersonnageWhereInput
  }

  /**
   * Armee.batailles
   */
  export type Armee$bataillesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    where?: ArmeeBatailleWhereInput
    orderBy?: ArmeeBatailleOrderByWithRelationInput | ArmeeBatailleOrderByWithRelationInput[]
    cursor?: ArmeeBatailleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArmeeBatailleScalarFieldEnum | ArmeeBatailleScalarFieldEnum[]
  }

  /**
   * Armee.inventaires
   */
  export type Armee$inventairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    where?: InventaireWhereInput
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    cursor?: InventaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventaireScalarFieldEnum | InventaireScalarFieldEnum[]
  }

  /**
   * Armee without action
   */
  export type ArmeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
  }


  /**
   * Model Bataille
   */

  export type AggregateBataille = {
    _count: BatailleCountAggregateOutputType | null
    _avg: BatailleAvgAggregateOutputType | null
    _sum: BatailleSumAggregateOutputType | null
    _min: BatailleMinAggregateOutputType | null
    _max: BatailleMaxAggregateOutputType | null
  }

  export type BatailleAvgAggregateOutputType = {
    id: number | null
    pertesA: number | null
    pertesB: number | null
  }

  export type BatailleSumAggregateOutputType = {
    id: number | null
    pertesA: number | null
    pertesB: number | null
  }

  export type BatailleMinAggregateOutputType = {
    id: number | null
    nom: string | null
    dateBataille: Date | null
    lieu: string | null
    pertesA: number | null
    pertesB: number | null
    vainqueurTexte: string | null
  }

  export type BatailleMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    dateBataille: Date | null
    lieu: string | null
    pertesA: number | null
    pertesB: number | null
    vainqueurTexte: string | null
  }

  export type BatailleCountAggregateOutputType = {
    id: number
    nom: number
    dateBataille: number
    lieu: number
    pertesA: number
    pertesB: number
    vainqueurTexte: number
    _all: number
  }


  export type BatailleAvgAggregateInputType = {
    id?: true
    pertesA?: true
    pertesB?: true
  }

  export type BatailleSumAggregateInputType = {
    id?: true
    pertesA?: true
    pertesB?: true
  }

  export type BatailleMinAggregateInputType = {
    id?: true
    nom?: true
    dateBataille?: true
    lieu?: true
    pertesA?: true
    pertesB?: true
    vainqueurTexte?: true
  }

  export type BatailleMaxAggregateInputType = {
    id?: true
    nom?: true
    dateBataille?: true
    lieu?: true
    pertesA?: true
    pertesB?: true
    vainqueurTexte?: true
  }

  export type BatailleCountAggregateInputType = {
    id?: true
    nom?: true
    dateBataille?: true
    lieu?: true
    pertesA?: true
    pertesB?: true
    vainqueurTexte?: true
    _all?: true
  }

  export type BatailleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bataille to aggregate.
     */
    where?: BatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batailles to fetch.
     */
    orderBy?: BatailleOrderByWithRelationInput | BatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batailles
    **/
    _count?: true | BatailleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatailleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatailleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatailleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatailleMaxAggregateInputType
  }

  export type GetBatailleAggregateType<T extends BatailleAggregateArgs> = {
        [P in keyof T & keyof AggregateBataille]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBataille[P]>
      : GetScalarType<T[P], AggregateBataille[P]>
  }




  export type BatailleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatailleWhereInput
    orderBy?: BatailleOrderByWithAggregationInput | BatailleOrderByWithAggregationInput[]
    by: BatailleScalarFieldEnum[] | BatailleScalarFieldEnum
    having?: BatailleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatailleCountAggregateInputType | true
    _avg?: BatailleAvgAggregateInputType
    _sum?: BatailleSumAggregateInputType
    _min?: BatailleMinAggregateInputType
    _max?: BatailleMaxAggregateInputType
  }

  export type BatailleGroupByOutputType = {
    id: number
    nom: string | null
    dateBataille: Date | null
    lieu: string | null
    pertesA: number | null
    pertesB: number | null
    vainqueurTexte: string | null
    _count: BatailleCountAggregateOutputType | null
    _avg: BatailleAvgAggregateOutputType | null
    _sum: BatailleSumAggregateOutputType | null
    _min: BatailleMinAggregateOutputType | null
    _max: BatailleMaxAggregateOutputType | null
  }

  type GetBatailleGroupByPayload<T extends BatailleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatailleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatailleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatailleGroupByOutputType[P]>
            : GetScalarType<T[P], BatailleGroupByOutputType[P]>
        }
      >
    >


  export type BatailleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    dateBataille?: boolean
    lieu?: boolean
    pertesA?: boolean
    pertesB?: boolean
    vainqueurTexte?: boolean
    armees?: boolean | Bataille$armeesArgs<ExtArgs>
    guildes?: boolean | Bataille$guildesArgs<ExtArgs>
    creatures?: boolean | Bataille$creaturesArgs<ExtArgs>
    _count?: boolean | BatailleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bataille"]>

  export type BatailleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    dateBataille?: boolean
    lieu?: boolean
    pertesA?: boolean
    pertesB?: boolean
    vainqueurTexte?: boolean
  }, ExtArgs["result"]["bataille"]>

  export type BatailleSelectScalar = {
    id?: boolean
    nom?: boolean
    dateBataille?: boolean
    lieu?: boolean
    pertesA?: boolean
    pertesB?: boolean
    vainqueurTexte?: boolean
  }

  export type BatailleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    armees?: boolean | Bataille$armeesArgs<ExtArgs>
    guildes?: boolean | Bataille$guildesArgs<ExtArgs>
    creatures?: boolean | Bataille$creaturesArgs<ExtArgs>
    _count?: boolean | BatailleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BatailleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BataillePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bataille"
    objects: {
      armees: Prisma.$ArmeeBataillePayload<ExtArgs>[]
      guildes: Prisma.$GuildeBataillePayload<ExtArgs>[]
      creatures: Prisma.$CreatureBataillePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string | null
      dateBataille: Date | null
      lieu: string | null
      pertesA: number | null
      pertesB: number | null
      vainqueurTexte: string | null
    }, ExtArgs["result"]["bataille"]>
    composites: {}
  }

  type BatailleGetPayload<S extends boolean | null | undefined | BatailleDefaultArgs> = $Result.GetResult<Prisma.$BataillePayload, S>

  type BatailleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BatailleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BatailleCountAggregateInputType | true
    }

  export interface BatailleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bataille'], meta: { name: 'Bataille' } }
    /**
     * Find zero or one Bataille that matches the filter.
     * @param {BatailleFindUniqueArgs} args - Arguments to find a Bataille
     * @example
     * // Get one Bataille
     * const bataille = await prisma.bataille.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatailleFindUniqueArgs>(args: SelectSubset<T, BatailleFindUniqueArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bataille that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BatailleFindUniqueOrThrowArgs} args - Arguments to find a Bataille
     * @example
     * // Get one Bataille
     * const bataille = await prisma.bataille.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatailleFindUniqueOrThrowArgs>(args: SelectSubset<T, BatailleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bataille that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatailleFindFirstArgs} args - Arguments to find a Bataille
     * @example
     * // Get one Bataille
     * const bataille = await prisma.bataille.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatailleFindFirstArgs>(args?: SelectSubset<T, BatailleFindFirstArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bataille that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatailleFindFirstOrThrowArgs} args - Arguments to find a Bataille
     * @example
     * // Get one Bataille
     * const bataille = await prisma.bataille.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatailleFindFirstOrThrowArgs>(args?: SelectSubset<T, BatailleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Batailles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatailleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batailles
     * const batailles = await prisma.bataille.findMany()
     * 
     * // Get first 10 Batailles
     * const batailles = await prisma.bataille.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batailleWithIdOnly = await prisma.bataille.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatailleFindManyArgs>(args?: SelectSubset<T, BatailleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bataille.
     * @param {BatailleCreateArgs} args - Arguments to create a Bataille.
     * @example
     * // Create one Bataille
     * const Bataille = await prisma.bataille.create({
     *   data: {
     *     // ... data to create a Bataille
     *   }
     * })
     * 
     */
    create<T extends BatailleCreateArgs>(args: SelectSubset<T, BatailleCreateArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Batailles.
     * @param {BatailleCreateManyArgs} args - Arguments to create many Batailles.
     * @example
     * // Create many Batailles
     * const bataille = await prisma.bataille.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatailleCreateManyArgs>(args?: SelectSubset<T, BatailleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batailles and returns the data saved in the database.
     * @param {BatailleCreateManyAndReturnArgs} args - Arguments to create many Batailles.
     * @example
     * // Create many Batailles
     * const bataille = await prisma.bataille.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batailles and only return the `id`
     * const batailleWithIdOnly = await prisma.bataille.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatailleCreateManyAndReturnArgs>(args?: SelectSubset<T, BatailleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bataille.
     * @param {BatailleDeleteArgs} args - Arguments to delete one Bataille.
     * @example
     * // Delete one Bataille
     * const Bataille = await prisma.bataille.delete({
     *   where: {
     *     // ... filter to delete one Bataille
     *   }
     * })
     * 
     */
    delete<T extends BatailleDeleteArgs>(args: SelectSubset<T, BatailleDeleteArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bataille.
     * @param {BatailleUpdateArgs} args - Arguments to update one Bataille.
     * @example
     * // Update one Bataille
     * const bataille = await prisma.bataille.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatailleUpdateArgs>(args: SelectSubset<T, BatailleUpdateArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Batailles.
     * @param {BatailleDeleteManyArgs} args - Arguments to filter Batailles to delete.
     * @example
     * // Delete a few Batailles
     * const { count } = await prisma.bataille.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatailleDeleteManyArgs>(args?: SelectSubset<T, BatailleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batailles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatailleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batailles
     * const bataille = await prisma.bataille.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatailleUpdateManyArgs>(args: SelectSubset<T, BatailleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bataille.
     * @param {BatailleUpsertArgs} args - Arguments to update or create a Bataille.
     * @example
     * // Update or create a Bataille
     * const bataille = await prisma.bataille.upsert({
     *   create: {
     *     // ... data to create a Bataille
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bataille we want to update
     *   }
     * })
     */
    upsert<T extends BatailleUpsertArgs>(args: SelectSubset<T, BatailleUpsertArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Batailles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatailleCountArgs} args - Arguments to filter Batailles to count.
     * @example
     * // Count the number of Batailles
     * const count = await prisma.bataille.count({
     *   where: {
     *     // ... the filter for the Batailles we want to count
     *   }
     * })
    **/
    count<T extends BatailleCountArgs>(
      args?: Subset<T, BatailleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatailleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bataille.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatailleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatailleAggregateArgs>(args: Subset<T, BatailleAggregateArgs>): Prisma.PrismaPromise<GetBatailleAggregateType<T>>

    /**
     * Group by Bataille.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatailleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatailleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatailleGroupByArgs['orderBy'] }
        : { orderBy?: BatailleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatailleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatailleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bataille model
   */
  readonly fields: BatailleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bataille.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatailleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    armees<T extends Bataille$armeesArgs<ExtArgs> = {}>(args?: Subset<T, Bataille$armeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "findMany"> | Null>
    guildes<T extends Bataille$guildesArgs<ExtArgs> = {}>(args?: Subset<T, Bataille$guildesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "findMany"> | Null>
    creatures<T extends Bataille$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, Bataille$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bataille model
   */ 
  interface BatailleFieldRefs {
    readonly id: FieldRef<"Bataille", 'Int'>
    readonly nom: FieldRef<"Bataille", 'String'>
    readonly dateBataille: FieldRef<"Bataille", 'DateTime'>
    readonly lieu: FieldRef<"Bataille", 'String'>
    readonly pertesA: FieldRef<"Bataille", 'Int'>
    readonly pertesB: FieldRef<"Bataille", 'Int'>
    readonly vainqueurTexte: FieldRef<"Bataille", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Bataille findUnique
   */
  export type BatailleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatailleInclude<ExtArgs> | null
    /**
     * Filter, which Bataille to fetch.
     */
    where: BatailleWhereUniqueInput
  }

  /**
   * Bataille findUniqueOrThrow
   */
  export type BatailleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatailleInclude<ExtArgs> | null
    /**
     * Filter, which Bataille to fetch.
     */
    where: BatailleWhereUniqueInput
  }

  /**
   * Bataille findFirst
   */
  export type BatailleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatailleInclude<ExtArgs> | null
    /**
     * Filter, which Bataille to fetch.
     */
    where?: BatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batailles to fetch.
     */
    orderBy?: BatailleOrderByWithRelationInput | BatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batailles.
     */
    cursor?: BatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batailles.
     */
    distinct?: BatailleScalarFieldEnum | BatailleScalarFieldEnum[]
  }

  /**
   * Bataille findFirstOrThrow
   */
  export type BatailleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatailleInclude<ExtArgs> | null
    /**
     * Filter, which Bataille to fetch.
     */
    where?: BatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batailles to fetch.
     */
    orderBy?: BatailleOrderByWithRelationInput | BatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batailles.
     */
    cursor?: BatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batailles.
     */
    distinct?: BatailleScalarFieldEnum | BatailleScalarFieldEnum[]
  }

  /**
   * Bataille findMany
   */
  export type BatailleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatailleInclude<ExtArgs> | null
    /**
     * Filter, which Batailles to fetch.
     */
    where?: BatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batailles to fetch.
     */
    orderBy?: BatailleOrderByWithRelationInput | BatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batailles.
     */
    cursor?: BatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batailles.
     */
    skip?: number
    distinct?: BatailleScalarFieldEnum | BatailleScalarFieldEnum[]
  }

  /**
   * Bataille create
   */
  export type BatailleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatailleInclude<ExtArgs> | null
    /**
     * The data needed to create a Bataille.
     */
    data?: XOR<BatailleCreateInput, BatailleUncheckedCreateInput>
  }

  /**
   * Bataille createMany
   */
  export type BatailleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batailles.
     */
    data: BatailleCreateManyInput | BatailleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bataille createManyAndReturn
   */
  export type BatailleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Batailles.
     */
    data: BatailleCreateManyInput | BatailleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bataille update
   */
  export type BatailleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatailleInclude<ExtArgs> | null
    /**
     * The data needed to update a Bataille.
     */
    data: XOR<BatailleUpdateInput, BatailleUncheckedUpdateInput>
    /**
     * Choose, which Bataille to update.
     */
    where: BatailleWhereUniqueInput
  }

  /**
   * Bataille updateMany
   */
  export type BatailleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batailles.
     */
    data: XOR<BatailleUpdateManyMutationInput, BatailleUncheckedUpdateManyInput>
    /**
     * Filter which Batailles to update
     */
    where?: BatailleWhereInput
  }

  /**
   * Bataille upsert
   */
  export type BatailleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatailleInclude<ExtArgs> | null
    /**
     * The filter to search for the Bataille to update in case it exists.
     */
    where: BatailleWhereUniqueInput
    /**
     * In case the Bataille found by the `where` argument doesn't exist, create a new Bataille with this data.
     */
    create: XOR<BatailleCreateInput, BatailleUncheckedCreateInput>
    /**
     * In case the Bataille was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatailleUpdateInput, BatailleUncheckedUpdateInput>
  }

  /**
   * Bataille delete
   */
  export type BatailleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatailleInclude<ExtArgs> | null
    /**
     * Filter which Bataille to delete.
     */
    where: BatailleWhereUniqueInput
  }

  /**
   * Bataille deleteMany
   */
  export type BatailleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batailles to delete
     */
    where?: BatailleWhereInput
  }

  /**
   * Bataille.armees
   */
  export type Bataille$armeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    where?: ArmeeBatailleWhereInput
    orderBy?: ArmeeBatailleOrderByWithRelationInput | ArmeeBatailleOrderByWithRelationInput[]
    cursor?: ArmeeBatailleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArmeeBatailleScalarFieldEnum | ArmeeBatailleScalarFieldEnum[]
  }

  /**
   * Bataille.guildes
   */
  export type Bataille$guildesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    where?: GuildeBatailleWhereInput
    orderBy?: GuildeBatailleOrderByWithRelationInput | GuildeBatailleOrderByWithRelationInput[]
    cursor?: GuildeBatailleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuildeBatailleScalarFieldEnum | GuildeBatailleScalarFieldEnum[]
  }

  /**
   * Bataille.creatures
   */
  export type Bataille$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    where?: CreatureBatailleWhereInput
    orderBy?: CreatureBatailleOrderByWithRelationInput | CreatureBatailleOrderByWithRelationInput[]
    cursor?: CreatureBatailleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureBatailleScalarFieldEnum | CreatureBatailleScalarFieldEnum[]
  }

  /**
   * Bataille without action
   */
  export type BatailleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bataille
     */
    select?: BatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatailleInclude<ExtArgs> | null
  }


  /**
   * Model ArmeeBataille
   */

  export type AggregateArmeeBataille = {
    _count: ArmeeBatailleCountAggregateOutputType | null
    _avg: ArmeeBatailleAvgAggregateOutputType | null
    _sum: ArmeeBatailleSumAggregateOutputType | null
    _min: ArmeeBatailleMinAggregateOutputType | null
    _max: ArmeeBatailleMaxAggregateOutputType | null
  }

  export type ArmeeBatailleAvgAggregateOutputType = {
    armeeId: number | null
    batailleId: number | null
    pertes: number | null
  }

  export type ArmeeBatailleSumAggregateOutputType = {
    armeeId: number | null
    batailleId: number | null
    pertes: number | null
  }

  export type ArmeeBatailleMinAggregateOutputType = {
    armeeId: number | null
    batailleId: number | null
    cote: string | null
    pertes: number | null
  }

  export type ArmeeBatailleMaxAggregateOutputType = {
    armeeId: number | null
    batailleId: number | null
    cote: string | null
    pertes: number | null
  }

  export type ArmeeBatailleCountAggregateOutputType = {
    armeeId: number
    batailleId: number
    cote: number
    pertes: number
    _all: number
  }


  export type ArmeeBatailleAvgAggregateInputType = {
    armeeId?: true
    batailleId?: true
    pertes?: true
  }

  export type ArmeeBatailleSumAggregateInputType = {
    armeeId?: true
    batailleId?: true
    pertes?: true
  }

  export type ArmeeBatailleMinAggregateInputType = {
    armeeId?: true
    batailleId?: true
    cote?: true
    pertes?: true
  }

  export type ArmeeBatailleMaxAggregateInputType = {
    armeeId?: true
    batailleId?: true
    cote?: true
    pertes?: true
  }

  export type ArmeeBatailleCountAggregateInputType = {
    armeeId?: true
    batailleId?: true
    cote?: true
    pertes?: true
    _all?: true
  }

  export type ArmeeBatailleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArmeeBataille to aggregate.
     */
    where?: ArmeeBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArmeeBatailles to fetch.
     */
    orderBy?: ArmeeBatailleOrderByWithRelationInput | ArmeeBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArmeeBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArmeeBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArmeeBatailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArmeeBatailles
    **/
    _count?: true | ArmeeBatailleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArmeeBatailleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArmeeBatailleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArmeeBatailleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArmeeBatailleMaxAggregateInputType
  }

  export type GetArmeeBatailleAggregateType<T extends ArmeeBatailleAggregateArgs> = {
        [P in keyof T & keyof AggregateArmeeBataille]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArmeeBataille[P]>
      : GetScalarType<T[P], AggregateArmeeBataille[P]>
  }




  export type ArmeeBatailleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArmeeBatailleWhereInput
    orderBy?: ArmeeBatailleOrderByWithAggregationInput | ArmeeBatailleOrderByWithAggregationInput[]
    by: ArmeeBatailleScalarFieldEnum[] | ArmeeBatailleScalarFieldEnum
    having?: ArmeeBatailleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArmeeBatailleCountAggregateInputType | true
    _avg?: ArmeeBatailleAvgAggregateInputType
    _sum?: ArmeeBatailleSumAggregateInputType
    _min?: ArmeeBatailleMinAggregateInputType
    _max?: ArmeeBatailleMaxAggregateInputType
  }

  export type ArmeeBatailleGroupByOutputType = {
    armeeId: number
    batailleId: number
    cote: string | null
    pertes: number | null
    _count: ArmeeBatailleCountAggregateOutputType | null
    _avg: ArmeeBatailleAvgAggregateOutputType | null
    _sum: ArmeeBatailleSumAggregateOutputType | null
    _min: ArmeeBatailleMinAggregateOutputType | null
    _max: ArmeeBatailleMaxAggregateOutputType | null
  }

  type GetArmeeBatailleGroupByPayload<T extends ArmeeBatailleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArmeeBatailleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArmeeBatailleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArmeeBatailleGroupByOutputType[P]>
            : GetScalarType<T[P], ArmeeBatailleGroupByOutputType[P]>
        }
      >
    >


  export type ArmeeBatailleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    armeeId?: boolean
    batailleId?: boolean
    cote?: boolean
    pertes?: boolean
    armee?: boolean | ArmeeDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["armeeBataille"]>

  export type ArmeeBatailleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    armeeId?: boolean
    batailleId?: boolean
    cote?: boolean
    pertes?: boolean
    armee?: boolean | ArmeeDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["armeeBataille"]>

  export type ArmeeBatailleSelectScalar = {
    armeeId?: boolean
    batailleId?: boolean
    cote?: boolean
    pertes?: boolean
  }

  export type ArmeeBatailleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    armee?: boolean | ArmeeDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }
  export type ArmeeBatailleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    armee?: boolean | ArmeeDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }

  export type $ArmeeBataillePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArmeeBataille"
    objects: {
      armee: Prisma.$ArmeePayload<ExtArgs>
      bataille: Prisma.$BataillePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      armeeId: number
      batailleId: number
      cote: string | null
      pertes: number | null
    }, ExtArgs["result"]["armeeBataille"]>
    composites: {}
  }

  type ArmeeBatailleGetPayload<S extends boolean | null | undefined | ArmeeBatailleDefaultArgs> = $Result.GetResult<Prisma.$ArmeeBataillePayload, S>

  type ArmeeBatailleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArmeeBatailleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArmeeBatailleCountAggregateInputType | true
    }

  export interface ArmeeBatailleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArmeeBataille'], meta: { name: 'ArmeeBataille' } }
    /**
     * Find zero or one ArmeeBataille that matches the filter.
     * @param {ArmeeBatailleFindUniqueArgs} args - Arguments to find a ArmeeBataille
     * @example
     * // Get one ArmeeBataille
     * const armeeBataille = await prisma.armeeBataille.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArmeeBatailleFindUniqueArgs>(args: SelectSubset<T, ArmeeBatailleFindUniqueArgs<ExtArgs>>): Prisma__ArmeeBatailleClient<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ArmeeBataille that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ArmeeBatailleFindUniqueOrThrowArgs} args - Arguments to find a ArmeeBataille
     * @example
     * // Get one ArmeeBataille
     * const armeeBataille = await prisma.armeeBataille.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArmeeBatailleFindUniqueOrThrowArgs>(args: SelectSubset<T, ArmeeBatailleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArmeeBatailleClient<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ArmeeBataille that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeBatailleFindFirstArgs} args - Arguments to find a ArmeeBataille
     * @example
     * // Get one ArmeeBataille
     * const armeeBataille = await prisma.armeeBataille.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArmeeBatailleFindFirstArgs>(args?: SelectSubset<T, ArmeeBatailleFindFirstArgs<ExtArgs>>): Prisma__ArmeeBatailleClient<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ArmeeBataille that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeBatailleFindFirstOrThrowArgs} args - Arguments to find a ArmeeBataille
     * @example
     * // Get one ArmeeBataille
     * const armeeBataille = await prisma.armeeBataille.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArmeeBatailleFindFirstOrThrowArgs>(args?: SelectSubset<T, ArmeeBatailleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArmeeBatailleClient<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ArmeeBatailles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeBatailleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArmeeBatailles
     * const armeeBatailles = await prisma.armeeBataille.findMany()
     * 
     * // Get first 10 ArmeeBatailles
     * const armeeBatailles = await prisma.armeeBataille.findMany({ take: 10 })
     * 
     * // Only select the `armeeId`
     * const armeeBatailleWithArmeeIdOnly = await prisma.armeeBataille.findMany({ select: { armeeId: true } })
     * 
     */
    findMany<T extends ArmeeBatailleFindManyArgs>(args?: SelectSubset<T, ArmeeBatailleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ArmeeBataille.
     * @param {ArmeeBatailleCreateArgs} args - Arguments to create a ArmeeBataille.
     * @example
     * // Create one ArmeeBataille
     * const ArmeeBataille = await prisma.armeeBataille.create({
     *   data: {
     *     // ... data to create a ArmeeBataille
     *   }
     * })
     * 
     */
    create<T extends ArmeeBatailleCreateArgs>(args: SelectSubset<T, ArmeeBatailleCreateArgs<ExtArgs>>): Prisma__ArmeeBatailleClient<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ArmeeBatailles.
     * @param {ArmeeBatailleCreateManyArgs} args - Arguments to create many ArmeeBatailles.
     * @example
     * // Create many ArmeeBatailles
     * const armeeBataille = await prisma.armeeBataille.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArmeeBatailleCreateManyArgs>(args?: SelectSubset<T, ArmeeBatailleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArmeeBatailles and returns the data saved in the database.
     * @param {ArmeeBatailleCreateManyAndReturnArgs} args - Arguments to create many ArmeeBatailles.
     * @example
     * // Create many ArmeeBatailles
     * const armeeBataille = await prisma.armeeBataille.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArmeeBatailles and only return the `armeeId`
     * const armeeBatailleWithArmeeIdOnly = await prisma.armeeBataille.createManyAndReturn({ 
     *   select: { armeeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArmeeBatailleCreateManyAndReturnArgs>(args?: SelectSubset<T, ArmeeBatailleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ArmeeBataille.
     * @param {ArmeeBatailleDeleteArgs} args - Arguments to delete one ArmeeBataille.
     * @example
     * // Delete one ArmeeBataille
     * const ArmeeBataille = await prisma.armeeBataille.delete({
     *   where: {
     *     // ... filter to delete one ArmeeBataille
     *   }
     * })
     * 
     */
    delete<T extends ArmeeBatailleDeleteArgs>(args: SelectSubset<T, ArmeeBatailleDeleteArgs<ExtArgs>>): Prisma__ArmeeBatailleClient<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ArmeeBataille.
     * @param {ArmeeBatailleUpdateArgs} args - Arguments to update one ArmeeBataille.
     * @example
     * // Update one ArmeeBataille
     * const armeeBataille = await prisma.armeeBataille.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArmeeBatailleUpdateArgs>(args: SelectSubset<T, ArmeeBatailleUpdateArgs<ExtArgs>>): Prisma__ArmeeBatailleClient<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ArmeeBatailles.
     * @param {ArmeeBatailleDeleteManyArgs} args - Arguments to filter ArmeeBatailles to delete.
     * @example
     * // Delete a few ArmeeBatailles
     * const { count } = await prisma.armeeBataille.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArmeeBatailleDeleteManyArgs>(args?: SelectSubset<T, ArmeeBatailleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArmeeBatailles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeBatailleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArmeeBatailles
     * const armeeBataille = await prisma.armeeBataille.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArmeeBatailleUpdateManyArgs>(args: SelectSubset<T, ArmeeBatailleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArmeeBataille.
     * @param {ArmeeBatailleUpsertArgs} args - Arguments to update or create a ArmeeBataille.
     * @example
     * // Update or create a ArmeeBataille
     * const armeeBataille = await prisma.armeeBataille.upsert({
     *   create: {
     *     // ... data to create a ArmeeBataille
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArmeeBataille we want to update
     *   }
     * })
     */
    upsert<T extends ArmeeBatailleUpsertArgs>(args: SelectSubset<T, ArmeeBatailleUpsertArgs<ExtArgs>>): Prisma__ArmeeBatailleClient<$Result.GetResult<Prisma.$ArmeeBataillePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ArmeeBatailles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeBatailleCountArgs} args - Arguments to filter ArmeeBatailles to count.
     * @example
     * // Count the number of ArmeeBatailles
     * const count = await prisma.armeeBataille.count({
     *   where: {
     *     // ... the filter for the ArmeeBatailles we want to count
     *   }
     * })
    **/
    count<T extends ArmeeBatailleCountArgs>(
      args?: Subset<T, ArmeeBatailleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArmeeBatailleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArmeeBataille.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeBatailleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArmeeBatailleAggregateArgs>(args: Subset<T, ArmeeBatailleAggregateArgs>): Prisma.PrismaPromise<GetArmeeBatailleAggregateType<T>>

    /**
     * Group by ArmeeBataille.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArmeeBatailleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArmeeBatailleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArmeeBatailleGroupByArgs['orderBy'] }
        : { orderBy?: ArmeeBatailleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArmeeBatailleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArmeeBatailleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArmeeBataille model
   */
  readonly fields: ArmeeBatailleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArmeeBataille.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArmeeBatailleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    armee<T extends ArmeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArmeeDefaultArgs<ExtArgs>>): Prisma__ArmeeClient<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bataille<T extends BatailleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatailleDefaultArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArmeeBataille model
   */ 
  interface ArmeeBatailleFieldRefs {
    readonly armeeId: FieldRef<"ArmeeBataille", 'Int'>
    readonly batailleId: FieldRef<"ArmeeBataille", 'Int'>
    readonly cote: FieldRef<"ArmeeBataille", 'String'>
    readonly pertes: FieldRef<"ArmeeBataille", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ArmeeBataille findUnique
   */
  export type ArmeeBatailleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    /**
     * Filter, which ArmeeBataille to fetch.
     */
    where: ArmeeBatailleWhereUniqueInput
  }

  /**
   * ArmeeBataille findUniqueOrThrow
   */
  export type ArmeeBatailleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    /**
     * Filter, which ArmeeBataille to fetch.
     */
    where: ArmeeBatailleWhereUniqueInput
  }

  /**
   * ArmeeBataille findFirst
   */
  export type ArmeeBatailleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    /**
     * Filter, which ArmeeBataille to fetch.
     */
    where?: ArmeeBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArmeeBatailles to fetch.
     */
    orderBy?: ArmeeBatailleOrderByWithRelationInput | ArmeeBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArmeeBatailles.
     */
    cursor?: ArmeeBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArmeeBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArmeeBatailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArmeeBatailles.
     */
    distinct?: ArmeeBatailleScalarFieldEnum | ArmeeBatailleScalarFieldEnum[]
  }

  /**
   * ArmeeBataille findFirstOrThrow
   */
  export type ArmeeBatailleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    /**
     * Filter, which ArmeeBataille to fetch.
     */
    where?: ArmeeBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArmeeBatailles to fetch.
     */
    orderBy?: ArmeeBatailleOrderByWithRelationInput | ArmeeBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArmeeBatailles.
     */
    cursor?: ArmeeBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArmeeBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArmeeBatailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArmeeBatailles.
     */
    distinct?: ArmeeBatailleScalarFieldEnum | ArmeeBatailleScalarFieldEnum[]
  }

  /**
   * ArmeeBataille findMany
   */
  export type ArmeeBatailleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    /**
     * Filter, which ArmeeBatailles to fetch.
     */
    where?: ArmeeBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArmeeBatailles to fetch.
     */
    orderBy?: ArmeeBatailleOrderByWithRelationInput | ArmeeBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArmeeBatailles.
     */
    cursor?: ArmeeBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArmeeBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArmeeBatailles.
     */
    skip?: number
    distinct?: ArmeeBatailleScalarFieldEnum | ArmeeBatailleScalarFieldEnum[]
  }

  /**
   * ArmeeBataille create
   */
  export type ArmeeBatailleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    /**
     * The data needed to create a ArmeeBataille.
     */
    data: XOR<ArmeeBatailleCreateInput, ArmeeBatailleUncheckedCreateInput>
  }

  /**
   * ArmeeBataille createMany
   */
  export type ArmeeBatailleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArmeeBatailles.
     */
    data: ArmeeBatailleCreateManyInput | ArmeeBatailleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArmeeBataille createManyAndReturn
   */
  export type ArmeeBatailleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ArmeeBatailles.
     */
    data: ArmeeBatailleCreateManyInput | ArmeeBatailleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArmeeBataille update
   */
  export type ArmeeBatailleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    /**
     * The data needed to update a ArmeeBataille.
     */
    data: XOR<ArmeeBatailleUpdateInput, ArmeeBatailleUncheckedUpdateInput>
    /**
     * Choose, which ArmeeBataille to update.
     */
    where: ArmeeBatailleWhereUniqueInput
  }

  /**
   * ArmeeBataille updateMany
   */
  export type ArmeeBatailleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArmeeBatailles.
     */
    data: XOR<ArmeeBatailleUpdateManyMutationInput, ArmeeBatailleUncheckedUpdateManyInput>
    /**
     * Filter which ArmeeBatailles to update
     */
    where?: ArmeeBatailleWhereInput
  }

  /**
   * ArmeeBataille upsert
   */
  export type ArmeeBatailleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    /**
     * The filter to search for the ArmeeBataille to update in case it exists.
     */
    where: ArmeeBatailleWhereUniqueInput
    /**
     * In case the ArmeeBataille found by the `where` argument doesn't exist, create a new ArmeeBataille with this data.
     */
    create: XOR<ArmeeBatailleCreateInput, ArmeeBatailleUncheckedCreateInput>
    /**
     * In case the ArmeeBataille was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArmeeBatailleUpdateInput, ArmeeBatailleUncheckedUpdateInput>
  }

  /**
   * ArmeeBataille delete
   */
  export type ArmeeBatailleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
    /**
     * Filter which ArmeeBataille to delete.
     */
    where: ArmeeBatailleWhereUniqueInput
  }

  /**
   * ArmeeBataille deleteMany
   */
  export type ArmeeBatailleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArmeeBatailles to delete
     */
    where?: ArmeeBatailleWhereInput
  }

  /**
   * ArmeeBataille without action
   */
  export type ArmeeBatailleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArmeeBataille
     */
    select?: ArmeeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeBatailleInclude<ExtArgs> | null
  }


  /**
   * Model GuildeBataille
   */

  export type AggregateGuildeBataille = {
    _count: GuildeBatailleCountAggregateOutputType | null
    _avg: GuildeBatailleAvgAggregateOutputType | null
    _sum: GuildeBatailleSumAggregateOutputType | null
    _min: GuildeBatailleMinAggregateOutputType | null
    _max: GuildeBatailleMaxAggregateOutputType | null
  }

  export type GuildeBatailleAvgAggregateOutputType = {
    guildeId: number | null
    batailleId: number | null
  }

  export type GuildeBatailleSumAggregateOutputType = {
    guildeId: number | null
    batailleId: number | null
  }

  export type GuildeBatailleMinAggregateOutputType = {
    guildeId: number | null
    batailleId: number | null
    role: string | null
  }

  export type GuildeBatailleMaxAggregateOutputType = {
    guildeId: number | null
    batailleId: number | null
    role: string | null
  }

  export type GuildeBatailleCountAggregateOutputType = {
    guildeId: number
    batailleId: number
    role: number
    _all: number
  }


  export type GuildeBatailleAvgAggregateInputType = {
    guildeId?: true
    batailleId?: true
  }

  export type GuildeBatailleSumAggregateInputType = {
    guildeId?: true
    batailleId?: true
  }

  export type GuildeBatailleMinAggregateInputType = {
    guildeId?: true
    batailleId?: true
    role?: true
  }

  export type GuildeBatailleMaxAggregateInputType = {
    guildeId?: true
    batailleId?: true
    role?: true
  }

  export type GuildeBatailleCountAggregateInputType = {
    guildeId?: true
    batailleId?: true
    role?: true
    _all?: true
  }

  export type GuildeBatailleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildeBataille to aggregate.
     */
    where?: GuildeBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildeBatailles to fetch.
     */
    orderBy?: GuildeBatailleOrderByWithRelationInput | GuildeBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildeBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildeBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildeBatailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildeBatailles
    **/
    _count?: true | GuildeBatailleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildeBatailleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildeBatailleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildeBatailleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildeBatailleMaxAggregateInputType
  }

  export type GetGuildeBatailleAggregateType<T extends GuildeBatailleAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildeBataille]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildeBataille[P]>
      : GetScalarType<T[P], AggregateGuildeBataille[P]>
  }




  export type GuildeBatailleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildeBatailleWhereInput
    orderBy?: GuildeBatailleOrderByWithAggregationInput | GuildeBatailleOrderByWithAggregationInput[]
    by: GuildeBatailleScalarFieldEnum[] | GuildeBatailleScalarFieldEnum
    having?: GuildeBatailleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildeBatailleCountAggregateInputType | true
    _avg?: GuildeBatailleAvgAggregateInputType
    _sum?: GuildeBatailleSumAggregateInputType
    _min?: GuildeBatailleMinAggregateInputType
    _max?: GuildeBatailleMaxAggregateInputType
  }

  export type GuildeBatailleGroupByOutputType = {
    guildeId: number
    batailleId: number
    role: string | null
    _count: GuildeBatailleCountAggregateOutputType | null
    _avg: GuildeBatailleAvgAggregateOutputType | null
    _sum: GuildeBatailleSumAggregateOutputType | null
    _min: GuildeBatailleMinAggregateOutputType | null
    _max: GuildeBatailleMaxAggregateOutputType | null
  }

  type GetGuildeBatailleGroupByPayload<T extends GuildeBatailleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildeBatailleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildeBatailleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildeBatailleGroupByOutputType[P]>
            : GetScalarType<T[P], GuildeBatailleGroupByOutputType[P]>
        }
      >
    >


  export type GuildeBatailleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guildeId?: boolean
    batailleId?: boolean
    role?: boolean
    guilde?: boolean | GuildeDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildeBataille"]>

  export type GuildeBatailleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guildeId?: boolean
    batailleId?: boolean
    role?: boolean
    guilde?: boolean | GuildeDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guildeBataille"]>

  export type GuildeBatailleSelectScalar = {
    guildeId?: boolean
    batailleId?: boolean
    role?: boolean
  }

  export type GuildeBatailleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guilde?: boolean | GuildeDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }
  export type GuildeBatailleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guilde?: boolean | GuildeDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }

  export type $GuildeBataillePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildeBataille"
    objects: {
      guilde: Prisma.$GuildePayload<ExtArgs>
      bataille: Prisma.$BataillePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      guildeId: number
      batailleId: number
      role: string | null
    }, ExtArgs["result"]["guildeBataille"]>
    composites: {}
  }

  type GuildeBatailleGetPayload<S extends boolean | null | undefined | GuildeBatailleDefaultArgs> = $Result.GetResult<Prisma.$GuildeBataillePayload, S>

  type GuildeBatailleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuildeBatailleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildeBatailleCountAggregateInputType | true
    }

  export interface GuildeBatailleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildeBataille'], meta: { name: 'GuildeBataille' } }
    /**
     * Find zero or one GuildeBataille that matches the filter.
     * @param {GuildeBatailleFindUniqueArgs} args - Arguments to find a GuildeBataille
     * @example
     * // Get one GuildeBataille
     * const guildeBataille = await prisma.guildeBataille.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildeBatailleFindUniqueArgs>(args: SelectSubset<T, GuildeBatailleFindUniqueArgs<ExtArgs>>): Prisma__GuildeBatailleClient<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GuildeBataille that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GuildeBatailleFindUniqueOrThrowArgs} args - Arguments to find a GuildeBataille
     * @example
     * // Get one GuildeBataille
     * const guildeBataille = await prisma.guildeBataille.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildeBatailleFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildeBatailleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildeBatailleClient<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GuildeBataille that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeBatailleFindFirstArgs} args - Arguments to find a GuildeBataille
     * @example
     * // Get one GuildeBataille
     * const guildeBataille = await prisma.guildeBataille.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildeBatailleFindFirstArgs>(args?: SelectSubset<T, GuildeBatailleFindFirstArgs<ExtArgs>>): Prisma__GuildeBatailleClient<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GuildeBataille that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeBatailleFindFirstOrThrowArgs} args - Arguments to find a GuildeBataille
     * @example
     * // Get one GuildeBataille
     * const guildeBataille = await prisma.guildeBataille.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildeBatailleFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildeBatailleFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildeBatailleClient<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GuildeBatailles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeBatailleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildeBatailles
     * const guildeBatailles = await prisma.guildeBataille.findMany()
     * 
     * // Get first 10 GuildeBatailles
     * const guildeBatailles = await prisma.guildeBataille.findMany({ take: 10 })
     * 
     * // Only select the `guildeId`
     * const guildeBatailleWithGuildeIdOnly = await prisma.guildeBataille.findMany({ select: { guildeId: true } })
     * 
     */
    findMany<T extends GuildeBatailleFindManyArgs>(args?: SelectSubset<T, GuildeBatailleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GuildeBataille.
     * @param {GuildeBatailleCreateArgs} args - Arguments to create a GuildeBataille.
     * @example
     * // Create one GuildeBataille
     * const GuildeBataille = await prisma.guildeBataille.create({
     *   data: {
     *     // ... data to create a GuildeBataille
     *   }
     * })
     * 
     */
    create<T extends GuildeBatailleCreateArgs>(args: SelectSubset<T, GuildeBatailleCreateArgs<ExtArgs>>): Prisma__GuildeBatailleClient<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GuildeBatailles.
     * @param {GuildeBatailleCreateManyArgs} args - Arguments to create many GuildeBatailles.
     * @example
     * // Create many GuildeBatailles
     * const guildeBataille = await prisma.guildeBataille.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildeBatailleCreateManyArgs>(args?: SelectSubset<T, GuildeBatailleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GuildeBatailles and returns the data saved in the database.
     * @param {GuildeBatailleCreateManyAndReturnArgs} args - Arguments to create many GuildeBatailles.
     * @example
     * // Create many GuildeBatailles
     * const guildeBataille = await prisma.guildeBataille.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GuildeBatailles and only return the `guildeId`
     * const guildeBatailleWithGuildeIdOnly = await prisma.guildeBataille.createManyAndReturn({ 
     *   select: { guildeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuildeBatailleCreateManyAndReturnArgs>(args?: SelectSubset<T, GuildeBatailleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GuildeBataille.
     * @param {GuildeBatailleDeleteArgs} args - Arguments to delete one GuildeBataille.
     * @example
     * // Delete one GuildeBataille
     * const GuildeBataille = await prisma.guildeBataille.delete({
     *   where: {
     *     // ... filter to delete one GuildeBataille
     *   }
     * })
     * 
     */
    delete<T extends GuildeBatailleDeleteArgs>(args: SelectSubset<T, GuildeBatailleDeleteArgs<ExtArgs>>): Prisma__GuildeBatailleClient<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GuildeBataille.
     * @param {GuildeBatailleUpdateArgs} args - Arguments to update one GuildeBataille.
     * @example
     * // Update one GuildeBataille
     * const guildeBataille = await prisma.guildeBataille.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildeBatailleUpdateArgs>(args: SelectSubset<T, GuildeBatailleUpdateArgs<ExtArgs>>): Prisma__GuildeBatailleClient<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GuildeBatailles.
     * @param {GuildeBatailleDeleteManyArgs} args - Arguments to filter GuildeBatailles to delete.
     * @example
     * // Delete a few GuildeBatailles
     * const { count } = await prisma.guildeBataille.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildeBatailleDeleteManyArgs>(args?: SelectSubset<T, GuildeBatailleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildeBatailles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeBatailleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildeBatailles
     * const guildeBataille = await prisma.guildeBataille.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildeBatailleUpdateManyArgs>(args: SelectSubset<T, GuildeBatailleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildeBataille.
     * @param {GuildeBatailleUpsertArgs} args - Arguments to update or create a GuildeBataille.
     * @example
     * // Update or create a GuildeBataille
     * const guildeBataille = await prisma.guildeBataille.upsert({
     *   create: {
     *     // ... data to create a GuildeBataille
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildeBataille we want to update
     *   }
     * })
     */
    upsert<T extends GuildeBatailleUpsertArgs>(args: SelectSubset<T, GuildeBatailleUpsertArgs<ExtArgs>>): Prisma__GuildeBatailleClient<$Result.GetResult<Prisma.$GuildeBataillePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GuildeBatailles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeBatailleCountArgs} args - Arguments to filter GuildeBatailles to count.
     * @example
     * // Count the number of GuildeBatailles
     * const count = await prisma.guildeBataille.count({
     *   where: {
     *     // ... the filter for the GuildeBatailles we want to count
     *   }
     * })
    **/
    count<T extends GuildeBatailleCountArgs>(
      args?: Subset<T, GuildeBatailleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildeBatailleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildeBataille.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeBatailleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildeBatailleAggregateArgs>(args: Subset<T, GuildeBatailleAggregateArgs>): Prisma.PrismaPromise<GetGuildeBatailleAggregateType<T>>

    /**
     * Group by GuildeBataille.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildeBatailleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildeBatailleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildeBatailleGroupByArgs['orderBy'] }
        : { orderBy?: GuildeBatailleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildeBatailleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildeBatailleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildeBataille model
   */
  readonly fields: GuildeBatailleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildeBataille.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildeBatailleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guilde<T extends GuildeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuildeDefaultArgs<ExtArgs>>): Prisma__GuildeClient<$Result.GetResult<Prisma.$GuildePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bataille<T extends BatailleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatailleDefaultArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildeBataille model
   */ 
  interface GuildeBatailleFieldRefs {
    readonly guildeId: FieldRef<"GuildeBataille", 'Int'>
    readonly batailleId: FieldRef<"GuildeBataille", 'Int'>
    readonly role: FieldRef<"GuildeBataille", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GuildeBataille findUnique
   */
  export type GuildeBatailleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    /**
     * Filter, which GuildeBataille to fetch.
     */
    where: GuildeBatailleWhereUniqueInput
  }

  /**
   * GuildeBataille findUniqueOrThrow
   */
  export type GuildeBatailleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    /**
     * Filter, which GuildeBataille to fetch.
     */
    where: GuildeBatailleWhereUniqueInput
  }

  /**
   * GuildeBataille findFirst
   */
  export type GuildeBatailleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    /**
     * Filter, which GuildeBataille to fetch.
     */
    where?: GuildeBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildeBatailles to fetch.
     */
    orderBy?: GuildeBatailleOrderByWithRelationInput | GuildeBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildeBatailles.
     */
    cursor?: GuildeBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildeBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildeBatailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildeBatailles.
     */
    distinct?: GuildeBatailleScalarFieldEnum | GuildeBatailleScalarFieldEnum[]
  }

  /**
   * GuildeBataille findFirstOrThrow
   */
  export type GuildeBatailleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    /**
     * Filter, which GuildeBataille to fetch.
     */
    where?: GuildeBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildeBatailles to fetch.
     */
    orderBy?: GuildeBatailleOrderByWithRelationInput | GuildeBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildeBatailles.
     */
    cursor?: GuildeBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildeBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildeBatailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildeBatailles.
     */
    distinct?: GuildeBatailleScalarFieldEnum | GuildeBatailleScalarFieldEnum[]
  }

  /**
   * GuildeBataille findMany
   */
  export type GuildeBatailleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    /**
     * Filter, which GuildeBatailles to fetch.
     */
    where?: GuildeBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildeBatailles to fetch.
     */
    orderBy?: GuildeBatailleOrderByWithRelationInput | GuildeBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildeBatailles.
     */
    cursor?: GuildeBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildeBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildeBatailles.
     */
    skip?: number
    distinct?: GuildeBatailleScalarFieldEnum | GuildeBatailleScalarFieldEnum[]
  }

  /**
   * GuildeBataille create
   */
  export type GuildeBatailleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    /**
     * The data needed to create a GuildeBataille.
     */
    data: XOR<GuildeBatailleCreateInput, GuildeBatailleUncheckedCreateInput>
  }

  /**
   * GuildeBataille createMany
   */
  export type GuildeBatailleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildeBatailles.
     */
    data: GuildeBatailleCreateManyInput | GuildeBatailleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuildeBataille createManyAndReturn
   */
  export type GuildeBatailleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GuildeBatailles.
     */
    data: GuildeBatailleCreateManyInput | GuildeBatailleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GuildeBataille update
   */
  export type GuildeBatailleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    /**
     * The data needed to update a GuildeBataille.
     */
    data: XOR<GuildeBatailleUpdateInput, GuildeBatailleUncheckedUpdateInput>
    /**
     * Choose, which GuildeBataille to update.
     */
    where: GuildeBatailleWhereUniqueInput
  }

  /**
   * GuildeBataille updateMany
   */
  export type GuildeBatailleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildeBatailles.
     */
    data: XOR<GuildeBatailleUpdateManyMutationInput, GuildeBatailleUncheckedUpdateManyInput>
    /**
     * Filter which GuildeBatailles to update
     */
    where?: GuildeBatailleWhereInput
  }

  /**
   * GuildeBataille upsert
   */
  export type GuildeBatailleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    /**
     * The filter to search for the GuildeBataille to update in case it exists.
     */
    where: GuildeBatailleWhereUniqueInput
    /**
     * In case the GuildeBataille found by the `where` argument doesn't exist, create a new GuildeBataille with this data.
     */
    create: XOR<GuildeBatailleCreateInput, GuildeBatailleUncheckedCreateInput>
    /**
     * In case the GuildeBataille was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildeBatailleUpdateInput, GuildeBatailleUncheckedUpdateInput>
  }

  /**
   * GuildeBataille delete
   */
  export type GuildeBatailleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
    /**
     * Filter which GuildeBataille to delete.
     */
    where: GuildeBatailleWhereUniqueInput
  }

  /**
   * GuildeBataille deleteMany
   */
  export type GuildeBatailleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildeBatailles to delete
     */
    where?: GuildeBatailleWhereInput
  }

  /**
   * GuildeBataille without action
   */
  export type GuildeBatailleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildeBataille
     */
    select?: GuildeBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuildeBatailleInclude<ExtArgs> | null
  }


  /**
   * Model CreatureBataille
   */

  export type AggregateCreatureBataille = {
    _count: CreatureBatailleCountAggregateOutputType | null
    _avg: CreatureBatailleAvgAggregateOutputType | null
    _sum: CreatureBatailleSumAggregateOutputType | null
    _min: CreatureBatailleMinAggregateOutputType | null
    _max: CreatureBatailleMaxAggregateOutputType | null
  }

  export type CreatureBatailleAvgAggregateOutputType = {
    creatureId: number | null
    batailleId: number | null
    nombre: number | null
  }

  export type CreatureBatailleSumAggregateOutputType = {
    creatureId: number | null
    batailleId: number | null
    nombre: number | null
  }

  export type CreatureBatailleMinAggregateOutputType = {
    creatureId: number | null
    batailleId: number | null
    nombre: number | null
    role: string | null
  }

  export type CreatureBatailleMaxAggregateOutputType = {
    creatureId: number | null
    batailleId: number | null
    nombre: number | null
    role: string | null
  }

  export type CreatureBatailleCountAggregateOutputType = {
    creatureId: number
    batailleId: number
    nombre: number
    role: number
    _all: number
  }


  export type CreatureBatailleAvgAggregateInputType = {
    creatureId?: true
    batailleId?: true
    nombre?: true
  }

  export type CreatureBatailleSumAggregateInputType = {
    creatureId?: true
    batailleId?: true
    nombre?: true
  }

  export type CreatureBatailleMinAggregateInputType = {
    creatureId?: true
    batailleId?: true
    nombre?: true
    role?: true
  }

  export type CreatureBatailleMaxAggregateInputType = {
    creatureId?: true
    batailleId?: true
    nombre?: true
    role?: true
  }

  export type CreatureBatailleCountAggregateInputType = {
    creatureId?: true
    batailleId?: true
    nombre?: true
    role?: true
    _all?: true
  }

  export type CreatureBatailleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureBataille to aggregate.
     */
    where?: CreatureBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureBatailles to fetch.
     */
    orderBy?: CreatureBatailleOrderByWithRelationInput | CreatureBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureBatailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatureBatailles
    **/
    _count?: true | CreatureBatailleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureBatailleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureBatailleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureBatailleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureBatailleMaxAggregateInputType
  }

  export type GetCreatureBatailleAggregateType<T extends CreatureBatailleAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatureBataille]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatureBataille[P]>
      : GetScalarType<T[P], AggregateCreatureBataille[P]>
  }




  export type CreatureBatailleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureBatailleWhereInput
    orderBy?: CreatureBatailleOrderByWithAggregationInput | CreatureBatailleOrderByWithAggregationInput[]
    by: CreatureBatailleScalarFieldEnum[] | CreatureBatailleScalarFieldEnum
    having?: CreatureBatailleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureBatailleCountAggregateInputType | true
    _avg?: CreatureBatailleAvgAggregateInputType
    _sum?: CreatureBatailleSumAggregateInputType
    _min?: CreatureBatailleMinAggregateInputType
    _max?: CreatureBatailleMaxAggregateInputType
  }

  export type CreatureBatailleGroupByOutputType = {
    creatureId: number
    batailleId: number
    nombre: number | null
    role: string | null
    _count: CreatureBatailleCountAggregateOutputType | null
    _avg: CreatureBatailleAvgAggregateOutputType | null
    _sum: CreatureBatailleSumAggregateOutputType | null
    _min: CreatureBatailleMinAggregateOutputType | null
    _max: CreatureBatailleMaxAggregateOutputType | null
  }

  type GetCreatureBatailleGroupByPayload<T extends CreatureBatailleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureBatailleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureBatailleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureBatailleGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureBatailleGroupByOutputType[P]>
        }
      >
    >


  export type CreatureBatailleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    creatureId?: boolean
    batailleId?: boolean
    nombre?: boolean
    role?: boolean
    creature?: boolean | CreatureDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureBataille"]>

  export type CreatureBatailleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    creatureId?: boolean
    batailleId?: boolean
    nombre?: boolean
    role?: boolean
    creature?: boolean | CreatureDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureBataille"]>

  export type CreatureBatailleSelectScalar = {
    creatureId?: boolean
    batailleId?: boolean
    nombre?: boolean
    role?: boolean
  }

  export type CreatureBatailleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature?: boolean | CreatureDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }
  export type CreatureBatailleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature?: boolean | CreatureDefaultArgs<ExtArgs>
    bataille?: boolean | BatailleDefaultArgs<ExtArgs>
  }

  export type $CreatureBataillePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatureBataille"
    objects: {
      creature: Prisma.$CreaturePayload<ExtArgs>
      bataille: Prisma.$BataillePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      creatureId: number
      batailleId: number
      nombre: number | null
      role: string | null
    }, ExtArgs["result"]["creatureBataille"]>
    composites: {}
  }

  type CreatureBatailleGetPayload<S extends boolean | null | undefined | CreatureBatailleDefaultArgs> = $Result.GetResult<Prisma.$CreatureBataillePayload, S>

  type CreatureBatailleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreatureBatailleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreatureBatailleCountAggregateInputType | true
    }

  export interface CreatureBatailleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatureBataille'], meta: { name: 'CreatureBataille' } }
    /**
     * Find zero or one CreatureBataille that matches the filter.
     * @param {CreatureBatailleFindUniqueArgs} args - Arguments to find a CreatureBataille
     * @example
     * // Get one CreatureBataille
     * const creatureBataille = await prisma.creatureBataille.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureBatailleFindUniqueArgs>(args: SelectSubset<T, CreatureBatailleFindUniqueArgs<ExtArgs>>): Prisma__CreatureBatailleClient<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CreatureBataille that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreatureBatailleFindUniqueOrThrowArgs} args - Arguments to find a CreatureBataille
     * @example
     * // Get one CreatureBataille
     * const creatureBataille = await prisma.creatureBataille.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureBatailleFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureBatailleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureBatailleClient<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CreatureBataille that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureBatailleFindFirstArgs} args - Arguments to find a CreatureBataille
     * @example
     * // Get one CreatureBataille
     * const creatureBataille = await prisma.creatureBataille.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureBatailleFindFirstArgs>(args?: SelectSubset<T, CreatureBatailleFindFirstArgs<ExtArgs>>): Prisma__CreatureBatailleClient<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CreatureBataille that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureBatailleFindFirstOrThrowArgs} args - Arguments to find a CreatureBataille
     * @example
     * // Get one CreatureBataille
     * const creatureBataille = await prisma.creatureBataille.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureBatailleFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureBatailleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureBatailleClient<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CreatureBatailles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureBatailleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatureBatailles
     * const creatureBatailles = await prisma.creatureBataille.findMany()
     * 
     * // Get first 10 CreatureBatailles
     * const creatureBatailles = await prisma.creatureBataille.findMany({ take: 10 })
     * 
     * // Only select the `creatureId`
     * const creatureBatailleWithCreatureIdOnly = await prisma.creatureBataille.findMany({ select: { creatureId: true } })
     * 
     */
    findMany<T extends CreatureBatailleFindManyArgs>(args?: SelectSubset<T, CreatureBatailleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CreatureBataille.
     * @param {CreatureBatailleCreateArgs} args - Arguments to create a CreatureBataille.
     * @example
     * // Create one CreatureBataille
     * const CreatureBataille = await prisma.creatureBataille.create({
     *   data: {
     *     // ... data to create a CreatureBataille
     *   }
     * })
     * 
     */
    create<T extends CreatureBatailleCreateArgs>(args: SelectSubset<T, CreatureBatailleCreateArgs<ExtArgs>>): Prisma__CreatureBatailleClient<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CreatureBatailles.
     * @param {CreatureBatailleCreateManyArgs} args - Arguments to create many CreatureBatailles.
     * @example
     * // Create many CreatureBatailles
     * const creatureBataille = await prisma.creatureBataille.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureBatailleCreateManyArgs>(args?: SelectSubset<T, CreatureBatailleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatureBatailles and returns the data saved in the database.
     * @param {CreatureBatailleCreateManyAndReturnArgs} args - Arguments to create many CreatureBatailles.
     * @example
     * // Create many CreatureBatailles
     * const creatureBataille = await prisma.creatureBataille.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatureBatailles and only return the `creatureId`
     * const creatureBatailleWithCreatureIdOnly = await prisma.creatureBataille.createManyAndReturn({ 
     *   select: { creatureId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureBatailleCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureBatailleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CreatureBataille.
     * @param {CreatureBatailleDeleteArgs} args - Arguments to delete one CreatureBataille.
     * @example
     * // Delete one CreatureBataille
     * const CreatureBataille = await prisma.creatureBataille.delete({
     *   where: {
     *     // ... filter to delete one CreatureBataille
     *   }
     * })
     * 
     */
    delete<T extends CreatureBatailleDeleteArgs>(args: SelectSubset<T, CreatureBatailleDeleteArgs<ExtArgs>>): Prisma__CreatureBatailleClient<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CreatureBataille.
     * @param {CreatureBatailleUpdateArgs} args - Arguments to update one CreatureBataille.
     * @example
     * // Update one CreatureBataille
     * const creatureBataille = await prisma.creatureBataille.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureBatailleUpdateArgs>(args: SelectSubset<T, CreatureBatailleUpdateArgs<ExtArgs>>): Prisma__CreatureBatailleClient<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CreatureBatailles.
     * @param {CreatureBatailleDeleteManyArgs} args - Arguments to filter CreatureBatailles to delete.
     * @example
     * // Delete a few CreatureBatailles
     * const { count } = await prisma.creatureBataille.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureBatailleDeleteManyArgs>(args?: SelectSubset<T, CreatureBatailleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureBatailles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureBatailleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatureBatailles
     * const creatureBataille = await prisma.creatureBataille.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureBatailleUpdateManyArgs>(args: SelectSubset<T, CreatureBatailleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CreatureBataille.
     * @param {CreatureBatailleUpsertArgs} args - Arguments to update or create a CreatureBataille.
     * @example
     * // Update or create a CreatureBataille
     * const creatureBataille = await prisma.creatureBataille.upsert({
     *   create: {
     *     // ... data to create a CreatureBataille
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatureBataille we want to update
     *   }
     * })
     */
    upsert<T extends CreatureBatailleUpsertArgs>(args: SelectSubset<T, CreatureBatailleUpsertArgs<ExtArgs>>): Prisma__CreatureBatailleClient<$Result.GetResult<Prisma.$CreatureBataillePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CreatureBatailles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureBatailleCountArgs} args - Arguments to filter CreatureBatailles to count.
     * @example
     * // Count the number of CreatureBatailles
     * const count = await prisma.creatureBataille.count({
     *   where: {
     *     // ... the filter for the CreatureBatailles we want to count
     *   }
     * })
    **/
    count<T extends CreatureBatailleCountArgs>(
      args?: Subset<T, CreatureBatailleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureBatailleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatureBataille.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureBatailleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureBatailleAggregateArgs>(args: Subset<T, CreatureBatailleAggregateArgs>): Prisma.PrismaPromise<GetCreatureBatailleAggregateType<T>>

    /**
     * Group by CreatureBataille.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureBatailleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureBatailleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureBatailleGroupByArgs['orderBy'] }
        : { orderBy?: CreatureBatailleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureBatailleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureBatailleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatureBataille model
   */
  readonly fields: CreatureBatailleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatureBataille.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureBatailleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature<T extends CreatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureDefaultArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bataille<T extends BatailleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatailleDefaultArgs<ExtArgs>>): Prisma__BatailleClient<$Result.GetResult<Prisma.$BataillePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatureBataille model
   */ 
  interface CreatureBatailleFieldRefs {
    readonly creatureId: FieldRef<"CreatureBataille", 'Int'>
    readonly batailleId: FieldRef<"CreatureBataille", 'Int'>
    readonly nombre: FieldRef<"CreatureBataille", 'Int'>
    readonly role: FieldRef<"CreatureBataille", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreatureBataille findUnique
   */
  export type CreatureBatailleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    /**
     * Filter, which CreatureBataille to fetch.
     */
    where: CreatureBatailleWhereUniqueInput
  }

  /**
   * CreatureBataille findUniqueOrThrow
   */
  export type CreatureBatailleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    /**
     * Filter, which CreatureBataille to fetch.
     */
    where: CreatureBatailleWhereUniqueInput
  }

  /**
   * CreatureBataille findFirst
   */
  export type CreatureBatailleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    /**
     * Filter, which CreatureBataille to fetch.
     */
    where?: CreatureBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureBatailles to fetch.
     */
    orderBy?: CreatureBatailleOrderByWithRelationInput | CreatureBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureBatailles.
     */
    cursor?: CreatureBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureBatailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureBatailles.
     */
    distinct?: CreatureBatailleScalarFieldEnum | CreatureBatailleScalarFieldEnum[]
  }

  /**
   * CreatureBataille findFirstOrThrow
   */
  export type CreatureBatailleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    /**
     * Filter, which CreatureBataille to fetch.
     */
    where?: CreatureBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureBatailles to fetch.
     */
    orderBy?: CreatureBatailleOrderByWithRelationInput | CreatureBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureBatailles.
     */
    cursor?: CreatureBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureBatailles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureBatailles.
     */
    distinct?: CreatureBatailleScalarFieldEnum | CreatureBatailleScalarFieldEnum[]
  }

  /**
   * CreatureBataille findMany
   */
  export type CreatureBatailleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    /**
     * Filter, which CreatureBatailles to fetch.
     */
    where?: CreatureBatailleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureBatailles to fetch.
     */
    orderBy?: CreatureBatailleOrderByWithRelationInput | CreatureBatailleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatureBatailles.
     */
    cursor?: CreatureBatailleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureBatailles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureBatailles.
     */
    skip?: number
    distinct?: CreatureBatailleScalarFieldEnum | CreatureBatailleScalarFieldEnum[]
  }

  /**
   * CreatureBataille create
   */
  export type CreatureBatailleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatureBataille.
     */
    data: XOR<CreatureBatailleCreateInput, CreatureBatailleUncheckedCreateInput>
  }

  /**
   * CreatureBataille createMany
   */
  export type CreatureBatailleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatureBatailles.
     */
    data: CreatureBatailleCreateManyInput | CreatureBatailleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureBataille createManyAndReturn
   */
  export type CreatureBatailleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CreatureBatailles.
     */
    data: CreatureBatailleCreateManyInput | CreatureBatailleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureBataille update
   */
  export type CreatureBatailleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatureBataille.
     */
    data: XOR<CreatureBatailleUpdateInput, CreatureBatailleUncheckedUpdateInput>
    /**
     * Choose, which CreatureBataille to update.
     */
    where: CreatureBatailleWhereUniqueInput
  }

  /**
   * CreatureBataille updateMany
   */
  export type CreatureBatailleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatureBatailles.
     */
    data: XOR<CreatureBatailleUpdateManyMutationInput, CreatureBatailleUncheckedUpdateManyInput>
    /**
     * Filter which CreatureBatailles to update
     */
    where?: CreatureBatailleWhereInput
  }

  /**
   * CreatureBataille upsert
   */
  export type CreatureBatailleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatureBataille to update in case it exists.
     */
    where: CreatureBatailleWhereUniqueInput
    /**
     * In case the CreatureBataille found by the `where` argument doesn't exist, create a new CreatureBataille with this data.
     */
    create: XOR<CreatureBatailleCreateInput, CreatureBatailleUncheckedCreateInput>
    /**
     * In case the CreatureBataille was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureBatailleUpdateInput, CreatureBatailleUncheckedUpdateInput>
  }

  /**
   * CreatureBataille delete
   */
  export type CreatureBatailleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
    /**
     * Filter which CreatureBataille to delete.
     */
    where: CreatureBatailleWhereUniqueInput
  }

  /**
   * CreatureBataille deleteMany
   */
  export type CreatureBatailleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureBatailles to delete
     */
    where?: CreatureBatailleWhereInput
  }

  /**
   * CreatureBataille without action
   */
  export type CreatureBatailleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureBataille
     */
    select?: CreatureBatailleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureBatailleInclude<ExtArgs> | null
  }


  /**
   * Model Equipement
   */

  export type AggregateEquipement = {
    _count: EquipementCountAggregateOutputType | null
    _avg: EquipementAvgAggregateOutputType | null
    _sum: EquipementSumAggregateOutputType | null
    _min: EquipementMinAggregateOutputType | null
    _max: EquipementMaxAggregateOutputType | null
  }

  export type EquipementAvgAggregateOutputType = {
    id: number | null
  }

  export type EquipementSumAggregateOutputType = {
    id: number | null
  }

  export type EquipementMinAggregateOutputType = {
    id: number | null
    nom: string | null
    typeEquipement: string | null
    materiaux: string | null
    rarete: string | null
    enchantements: string | null
    affiniteRequise: string | null
  }

  export type EquipementMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    typeEquipement: string | null
    materiaux: string | null
    rarete: string | null
    enchantements: string | null
    affiniteRequise: string | null
  }

  export type EquipementCountAggregateOutputType = {
    id: number
    nom: number
    typeEquipement: number
    materiaux: number
    rarete: number
    enchantements: number
    affiniteRequise: number
    _all: number
  }


  export type EquipementAvgAggregateInputType = {
    id?: true
  }

  export type EquipementSumAggregateInputType = {
    id?: true
  }

  export type EquipementMinAggregateInputType = {
    id?: true
    nom?: true
    typeEquipement?: true
    materiaux?: true
    rarete?: true
    enchantements?: true
    affiniteRequise?: true
  }

  export type EquipementMaxAggregateInputType = {
    id?: true
    nom?: true
    typeEquipement?: true
    materiaux?: true
    rarete?: true
    enchantements?: true
    affiniteRequise?: true
  }

  export type EquipementCountAggregateInputType = {
    id?: true
    nom?: true
    typeEquipement?: true
    materiaux?: true
    rarete?: true
    enchantements?: true
    affiniteRequise?: true
    _all?: true
  }

  export type EquipementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipement to aggregate.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipements
    **/
    _count?: true | EquipementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipementMaxAggregateInputType
  }

  export type GetEquipementAggregateType<T extends EquipementAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipement[P]>
      : GetScalarType<T[P], AggregateEquipement[P]>
  }




  export type EquipementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipementWhereInput
    orderBy?: EquipementOrderByWithAggregationInput | EquipementOrderByWithAggregationInput[]
    by: EquipementScalarFieldEnum[] | EquipementScalarFieldEnum
    having?: EquipementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipementCountAggregateInputType | true
    _avg?: EquipementAvgAggregateInputType
    _sum?: EquipementSumAggregateInputType
    _min?: EquipementMinAggregateInputType
    _max?: EquipementMaxAggregateInputType
  }

  export type EquipementGroupByOutputType = {
    id: number
    nom: string
    typeEquipement: string | null
    materiaux: string | null
    rarete: string | null
    enchantements: string | null
    affiniteRequise: string | null
    _count: EquipementCountAggregateOutputType | null
    _avg: EquipementAvgAggregateOutputType | null
    _sum: EquipementSumAggregateOutputType | null
    _min: EquipementMinAggregateOutputType | null
    _max: EquipementMaxAggregateOutputType | null
  }

  type GetEquipementGroupByPayload<T extends EquipementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipementGroupByOutputType[P]>
            : GetScalarType<T[P], EquipementGroupByOutputType[P]>
        }
      >
    >


  export type EquipementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    typeEquipement?: boolean
    materiaux?: boolean
    rarete?: boolean
    enchantements?: boolean
    affiniteRequise?: boolean
    possesseurs?: boolean | Equipement$possesseursArgs<ExtArgs>
    _count?: boolean | EquipementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipement"]>

  export type EquipementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    typeEquipement?: boolean
    materiaux?: boolean
    rarete?: boolean
    enchantements?: boolean
    affiniteRequise?: boolean
  }, ExtArgs["result"]["equipement"]>

  export type EquipementSelectScalar = {
    id?: boolean
    nom?: boolean
    typeEquipement?: boolean
    materiaux?: boolean
    rarete?: boolean
    enchantements?: boolean
    affiniteRequise?: boolean
  }

  export type EquipementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    possesseurs?: boolean | Equipement$possesseursArgs<ExtArgs>
    _count?: boolean | EquipementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EquipementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipement"
    objects: {
      possesseurs: Prisma.$PersonnageEquipementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      typeEquipement: string | null
      materiaux: string | null
      rarete: string | null
      enchantements: string | null
      affiniteRequise: string | null
    }, ExtArgs["result"]["equipement"]>
    composites: {}
  }

  type EquipementGetPayload<S extends boolean | null | undefined | EquipementDefaultArgs> = $Result.GetResult<Prisma.$EquipementPayload, S>

  type EquipementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EquipementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EquipementCountAggregateInputType | true
    }

  export interface EquipementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipement'], meta: { name: 'Equipement' } }
    /**
     * Find zero or one Equipement that matches the filter.
     * @param {EquipementFindUniqueArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipementFindUniqueArgs>(args: SelectSubset<T, EquipementFindUniqueArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Equipement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EquipementFindUniqueOrThrowArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipementFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Equipement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementFindFirstArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipementFindFirstArgs>(args?: SelectSubset<T, EquipementFindFirstArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Equipement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementFindFirstOrThrowArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipementFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Equipements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipements
     * const equipements = await prisma.equipement.findMany()
     * 
     * // Get first 10 Equipements
     * const equipements = await prisma.equipement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipementWithIdOnly = await prisma.equipement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipementFindManyArgs>(args?: SelectSubset<T, EquipementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Equipement.
     * @param {EquipementCreateArgs} args - Arguments to create a Equipement.
     * @example
     * // Create one Equipement
     * const Equipement = await prisma.equipement.create({
     *   data: {
     *     // ... data to create a Equipement
     *   }
     * })
     * 
     */
    create<T extends EquipementCreateArgs>(args: SelectSubset<T, EquipementCreateArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Equipements.
     * @param {EquipementCreateManyArgs} args - Arguments to create many Equipements.
     * @example
     * // Create many Equipements
     * const equipement = await prisma.equipement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipementCreateManyArgs>(args?: SelectSubset<T, EquipementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipements and returns the data saved in the database.
     * @param {EquipementCreateManyAndReturnArgs} args - Arguments to create many Equipements.
     * @example
     * // Create many Equipements
     * const equipement = await prisma.equipement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipements and only return the `id`
     * const equipementWithIdOnly = await prisma.equipement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipementCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Equipement.
     * @param {EquipementDeleteArgs} args - Arguments to delete one Equipement.
     * @example
     * // Delete one Equipement
     * const Equipement = await prisma.equipement.delete({
     *   where: {
     *     // ... filter to delete one Equipement
     *   }
     * })
     * 
     */
    delete<T extends EquipementDeleteArgs>(args: SelectSubset<T, EquipementDeleteArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Equipement.
     * @param {EquipementUpdateArgs} args - Arguments to update one Equipement.
     * @example
     * // Update one Equipement
     * const equipement = await prisma.equipement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipementUpdateArgs>(args: SelectSubset<T, EquipementUpdateArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Equipements.
     * @param {EquipementDeleteManyArgs} args - Arguments to filter Equipements to delete.
     * @example
     * // Delete a few Equipements
     * const { count } = await prisma.equipement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipementDeleteManyArgs>(args?: SelectSubset<T, EquipementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipements
     * const equipement = await prisma.equipement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipementUpdateManyArgs>(args: SelectSubset<T, EquipementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipement.
     * @param {EquipementUpsertArgs} args - Arguments to update or create a Equipement.
     * @example
     * // Update or create a Equipement
     * const equipement = await prisma.equipement.upsert({
     *   create: {
     *     // ... data to create a Equipement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipement we want to update
     *   }
     * })
     */
    upsert<T extends EquipementUpsertArgs>(args: SelectSubset<T, EquipementUpsertArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Equipements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementCountArgs} args - Arguments to filter Equipements to count.
     * @example
     * // Count the number of Equipements
     * const count = await prisma.equipement.count({
     *   where: {
     *     // ... the filter for the Equipements we want to count
     *   }
     * })
    **/
    count<T extends EquipementCountArgs>(
      args?: Subset<T, EquipementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipementAggregateArgs>(args: Subset<T, EquipementAggregateArgs>): Prisma.PrismaPromise<GetEquipementAggregateType<T>>

    /**
     * Group by Equipement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipementGroupByArgs['orderBy'] }
        : { orderBy?: EquipementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipement model
   */
  readonly fields: EquipementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    possesseurs<T extends Equipement$possesseursArgs<ExtArgs> = {}>(args?: Subset<T, Equipement$possesseursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipement model
   */ 
  interface EquipementFieldRefs {
    readonly id: FieldRef<"Equipement", 'Int'>
    readonly nom: FieldRef<"Equipement", 'String'>
    readonly typeEquipement: FieldRef<"Equipement", 'String'>
    readonly materiaux: FieldRef<"Equipement", 'String'>
    readonly rarete: FieldRef<"Equipement", 'String'>
    readonly enchantements: FieldRef<"Equipement", 'String'>
    readonly affiniteRequise: FieldRef<"Equipement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Equipement findUnique
   */
  export type EquipementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement findUniqueOrThrow
   */
  export type EquipementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement findFirst
   */
  export type EquipementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipements.
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipements.
     */
    distinct?: EquipementScalarFieldEnum | EquipementScalarFieldEnum[]
  }

  /**
   * Equipement findFirstOrThrow
   */
  export type EquipementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipements.
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipements.
     */
    distinct?: EquipementScalarFieldEnum | EquipementScalarFieldEnum[]
  }

  /**
   * Equipement findMany
   */
  export type EquipementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipements to fetch.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipements.
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    distinct?: EquipementScalarFieldEnum | EquipementScalarFieldEnum[]
  }

  /**
   * Equipement create
   */
  export type EquipementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipement.
     */
    data: XOR<EquipementCreateInput, EquipementUncheckedCreateInput>
  }

  /**
   * Equipement createMany
   */
  export type EquipementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipements.
     */
    data: EquipementCreateManyInput | EquipementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipement createManyAndReturn
   */
  export type EquipementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Equipements.
     */
    data: EquipementCreateManyInput | EquipementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipement update
   */
  export type EquipementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipement.
     */
    data: XOR<EquipementUpdateInput, EquipementUncheckedUpdateInput>
    /**
     * Choose, which Equipement to update.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement updateMany
   */
  export type EquipementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipements.
     */
    data: XOR<EquipementUpdateManyMutationInput, EquipementUncheckedUpdateManyInput>
    /**
     * Filter which Equipements to update
     */
    where?: EquipementWhereInput
  }

  /**
   * Equipement upsert
   */
  export type EquipementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipement to update in case it exists.
     */
    where: EquipementWhereUniqueInput
    /**
     * In case the Equipement found by the `where` argument doesn't exist, create a new Equipement with this data.
     */
    create: XOR<EquipementCreateInput, EquipementUncheckedCreateInput>
    /**
     * In case the Equipement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipementUpdateInput, EquipementUncheckedUpdateInput>
  }

  /**
   * Equipement delete
   */
  export type EquipementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter which Equipement to delete.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement deleteMany
   */
  export type EquipementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipements to delete
     */
    where?: EquipementWhereInput
  }

  /**
   * Equipement.possesseurs
   */
  export type Equipement$possesseursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    where?: PersonnageEquipementWhereInput
    orderBy?: PersonnageEquipementOrderByWithRelationInput | PersonnageEquipementOrderByWithRelationInput[]
    cursor?: PersonnageEquipementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnageEquipementScalarFieldEnum | PersonnageEquipementScalarFieldEnum[]
  }

  /**
   * Equipement without action
   */
  export type EquipementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
  }


  /**
   * Model PersonnageEquipement
   */

  export type AggregatePersonnageEquipement = {
    _count: PersonnageEquipementCountAggregateOutputType | null
    _avg: PersonnageEquipementAvgAggregateOutputType | null
    _sum: PersonnageEquipementSumAggregateOutputType | null
    _min: PersonnageEquipementMinAggregateOutputType | null
    _max: PersonnageEquipementMaxAggregateOutputType | null
  }

  export type PersonnageEquipementAvgAggregateOutputType = {
    personnageId: number | null
    equipementId: number | null
  }

  export type PersonnageEquipementSumAggregateOutputType = {
    personnageId: number | null
    equipementId: number | null
  }

  export type PersonnageEquipementMinAggregateOutputType = {
    personnageId: number | null
    equipementId: number | null
    dateAcquisition: Date | null
    source: string | null
  }

  export type PersonnageEquipementMaxAggregateOutputType = {
    personnageId: number | null
    equipementId: number | null
    dateAcquisition: Date | null
    source: string | null
  }

  export type PersonnageEquipementCountAggregateOutputType = {
    personnageId: number
    equipementId: number
    dateAcquisition: number
    source: number
    _all: number
  }


  export type PersonnageEquipementAvgAggregateInputType = {
    personnageId?: true
    equipementId?: true
  }

  export type PersonnageEquipementSumAggregateInputType = {
    personnageId?: true
    equipementId?: true
  }

  export type PersonnageEquipementMinAggregateInputType = {
    personnageId?: true
    equipementId?: true
    dateAcquisition?: true
    source?: true
  }

  export type PersonnageEquipementMaxAggregateInputType = {
    personnageId?: true
    equipementId?: true
    dateAcquisition?: true
    source?: true
  }

  export type PersonnageEquipementCountAggregateInputType = {
    personnageId?: true
    equipementId?: true
    dateAcquisition?: true
    source?: true
    _all?: true
  }

  export type PersonnageEquipementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnageEquipement to aggregate.
     */
    where?: PersonnageEquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageEquipements to fetch.
     */
    orderBy?: PersonnageEquipementOrderByWithRelationInput | PersonnageEquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnageEquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageEquipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageEquipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonnageEquipements
    **/
    _count?: true | PersonnageEquipementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonnageEquipementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonnageEquipementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnageEquipementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnageEquipementMaxAggregateInputType
  }

  export type GetPersonnageEquipementAggregateType<T extends PersonnageEquipementAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnageEquipement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnageEquipement[P]>
      : GetScalarType<T[P], AggregatePersonnageEquipement[P]>
  }




  export type PersonnageEquipementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnageEquipementWhereInput
    orderBy?: PersonnageEquipementOrderByWithAggregationInput | PersonnageEquipementOrderByWithAggregationInput[]
    by: PersonnageEquipementScalarFieldEnum[] | PersonnageEquipementScalarFieldEnum
    having?: PersonnageEquipementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnageEquipementCountAggregateInputType | true
    _avg?: PersonnageEquipementAvgAggregateInputType
    _sum?: PersonnageEquipementSumAggregateInputType
    _min?: PersonnageEquipementMinAggregateInputType
    _max?: PersonnageEquipementMaxAggregateInputType
  }

  export type PersonnageEquipementGroupByOutputType = {
    personnageId: number
    equipementId: number
    dateAcquisition: Date | null
    source: string | null
    _count: PersonnageEquipementCountAggregateOutputType | null
    _avg: PersonnageEquipementAvgAggregateOutputType | null
    _sum: PersonnageEquipementSumAggregateOutputType | null
    _min: PersonnageEquipementMinAggregateOutputType | null
    _max: PersonnageEquipementMaxAggregateOutputType | null
  }

  type GetPersonnageEquipementGroupByPayload<T extends PersonnageEquipementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnageEquipementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnageEquipementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnageEquipementGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnageEquipementGroupByOutputType[P]>
        }
      >
    >


  export type PersonnageEquipementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnageId?: boolean
    equipementId?: boolean
    dateAcquisition?: boolean
    source?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnageEquipement"]>

  export type PersonnageEquipementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnageId?: boolean
    equipementId?: boolean
    dateAcquisition?: boolean
    source?: boolean
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnageEquipement"]>

  export type PersonnageEquipementSelectScalar = {
    personnageId?: boolean
    equipementId?: boolean
    dateAcquisition?: boolean
    source?: boolean
  }

  export type PersonnageEquipementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }
  export type PersonnageEquipementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnage?: boolean | PersonnageDefaultArgs<ExtArgs>
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }

  export type $PersonnageEquipementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonnageEquipement"
    objects: {
      personnage: Prisma.$PersonnagePayload<ExtArgs>
      equipement: Prisma.$EquipementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      personnageId: number
      equipementId: number
      dateAcquisition: Date | null
      source: string | null
    }, ExtArgs["result"]["personnageEquipement"]>
    composites: {}
  }

  type PersonnageEquipementGetPayload<S extends boolean | null | undefined | PersonnageEquipementDefaultArgs> = $Result.GetResult<Prisma.$PersonnageEquipementPayload, S>

  type PersonnageEquipementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonnageEquipementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonnageEquipementCountAggregateInputType | true
    }

  export interface PersonnageEquipementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonnageEquipement'], meta: { name: 'PersonnageEquipement' } }
    /**
     * Find zero or one PersonnageEquipement that matches the filter.
     * @param {PersonnageEquipementFindUniqueArgs} args - Arguments to find a PersonnageEquipement
     * @example
     * // Get one PersonnageEquipement
     * const personnageEquipement = await prisma.personnageEquipement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnageEquipementFindUniqueArgs>(args: SelectSubset<T, PersonnageEquipementFindUniqueArgs<ExtArgs>>): Prisma__PersonnageEquipementClient<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PersonnageEquipement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonnageEquipementFindUniqueOrThrowArgs} args - Arguments to find a PersonnageEquipement
     * @example
     * // Get one PersonnageEquipement
     * const personnageEquipement = await prisma.personnageEquipement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnageEquipementFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnageEquipementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnageEquipementClient<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PersonnageEquipement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageEquipementFindFirstArgs} args - Arguments to find a PersonnageEquipement
     * @example
     * // Get one PersonnageEquipement
     * const personnageEquipement = await prisma.personnageEquipement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnageEquipementFindFirstArgs>(args?: SelectSubset<T, PersonnageEquipementFindFirstArgs<ExtArgs>>): Prisma__PersonnageEquipementClient<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PersonnageEquipement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageEquipementFindFirstOrThrowArgs} args - Arguments to find a PersonnageEquipement
     * @example
     * // Get one PersonnageEquipement
     * const personnageEquipement = await prisma.personnageEquipement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnageEquipementFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnageEquipementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnageEquipementClient<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PersonnageEquipements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageEquipementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonnageEquipements
     * const personnageEquipements = await prisma.personnageEquipement.findMany()
     * 
     * // Get first 10 PersonnageEquipements
     * const personnageEquipements = await prisma.personnageEquipement.findMany({ take: 10 })
     * 
     * // Only select the `personnageId`
     * const personnageEquipementWithPersonnageIdOnly = await prisma.personnageEquipement.findMany({ select: { personnageId: true } })
     * 
     */
    findMany<T extends PersonnageEquipementFindManyArgs>(args?: SelectSubset<T, PersonnageEquipementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PersonnageEquipement.
     * @param {PersonnageEquipementCreateArgs} args - Arguments to create a PersonnageEquipement.
     * @example
     * // Create one PersonnageEquipement
     * const PersonnageEquipement = await prisma.personnageEquipement.create({
     *   data: {
     *     // ... data to create a PersonnageEquipement
     *   }
     * })
     * 
     */
    create<T extends PersonnageEquipementCreateArgs>(args: SelectSubset<T, PersonnageEquipementCreateArgs<ExtArgs>>): Prisma__PersonnageEquipementClient<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PersonnageEquipements.
     * @param {PersonnageEquipementCreateManyArgs} args - Arguments to create many PersonnageEquipements.
     * @example
     * // Create many PersonnageEquipements
     * const personnageEquipement = await prisma.personnageEquipement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnageEquipementCreateManyArgs>(args?: SelectSubset<T, PersonnageEquipementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonnageEquipements and returns the data saved in the database.
     * @param {PersonnageEquipementCreateManyAndReturnArgs} args - Arguments to create many PersonnageEquipements.
     * @example
     * // Create many PersonnageEquipements
     * const personnageEquipement = await prisma.personnageEquipement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonnageEquipements and only return the `personnageId`
     * const personnageEquipementWithPersonnageIdOnly = await prisma.personnageEquipement.createManyAndReturn({ 
     *   select: { personnageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonnageEquipementCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonnageEquipementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PersonnageEquipement.
     * @param {PersonnageEquipementDeleteArgs} args - Arguments to delete one PersonnageEquipement.
     * @example
     * // Delete one PersonnageEquipement
     * const PersonnageEquipement = await prisma.personnageEquipement.delete({
     *   where: {
     *     // ... filter to delete one PersonnageEquipement
     *   }
     * })
     * 
     */
    delete<T extends PersonnageEquipementDeleteArgs>(args: SelectSubset<T, PersonnageEquipementDeleteArgs<ExtArgs>>): Prisma__PersonnageEquipementClient<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PersonnageEquipement.
     * @param {PersonnageEquipementUpdateArgs} args - Arguments to update one PersonnageEquipement.
     * @example
     * // Update one PersonnageEquipement
     * const personnageEquipement = await prisma.personnageEquipement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnageEquipementUpdateArgs>(args: SelectSubset<T, PersonnageEquipementUpdateArgs<ExtArgs>>): Prisma__PersonnageEquipementClient<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PersonnageEquipements.
     * @param {PersonnageEquipementDeleteManyArgs} args - Arguments to filter PersonnageEquipements to delete.
     * @example
     * // Delete a few PersonnageEquipements
     * const { count } = await prisma.personnageEquipement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnageEquipementDeleteManyArgs>(args?: SelectSubset<T, PersonnageEquipementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonnageEquipements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageEquipementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonnageEquipements
     * const personnageEquipement = await prisma.personnageEquipement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnageEquipementUpdateManyArgs>(args: SelectSubset<T, PersonnageEquipementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonnageEquipement.
     * @param {PersonnageEquipementUpsertArgs} args - Arguments to update or create a PersonnageEquipement.
     * @example
     * // Update or create a PersonnageEquipement
     * const personnageEquipement = await prisma.personnageEquipement.upsert({
     *   create: {
     *     // ... data to create a PersonnageEquipement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonnageEquipement we want to update
     *   }
     * })
     */
    upsert<T extends PersonnageEquipementUpsertArgs>(args: SelectSubset<T, PersonnageEquipementUpsertArgs<ExtArgs>>): Prisma__PersonnageEquipementClient<$Result.GetResult<Prisma.$PersonnageEquipementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PersonnageEquipements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageEquipementCountArgs} args - Arguments to filter PersonnageEquipements to count.
     * @example
     * // Count the number of PersonnageEquipements
     * const count = await prisma.personnageEquipement.count({
     *   where: {
     *     // ... the filter for the PersonnageEquipements we want to count
     *   }
     * })
    **/
    count<T extends PersonnageEquipementCountArgs>(
      args?: Subset<T, PersonnageEquipementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnageEquipementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonnageEquipement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageEquipementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnageEquipementAggregateArgs>(args: Subset<T, PersonnageEquipementAggregateArgs>): Prisma.PrismaPromise<GetPersonnageEquipementAggregateType<T>>

    /**
     * Group by PersonnageEquipement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnageEquipementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnageEquipementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnageEquipementGroupByArgs['orderBy'] }
        : { orderBy?: PersonnageEquipementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnageEquipementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnageEquipementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonnageEquipement model
   */
  readonly fields: PersonnageEquipementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonnageEquipement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnageEquipementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnage<T extends PersonnageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnageDefaultArgs<ExtArgs>>): Prisma__PersonnageClient<$Result.GetResult<Prisma.$PersonnagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    equipement<T extends EquipementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipementDefaultArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonnageEquipement model
   */ 
  interface PersonnageEquipementFieldRefs {
    readonly personnageId: FieldRef<"PersonnageEquipement", 'Int'>
    readonly equipementId: FieldRef<"PersonnageEquipement", 'Int'>
    readonly dateAcquisition: FieldRef<"PersonnageEquipement", 'DateTime'>
    readonly source: FieldRef<"PersonnageEquipement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PersonnageEquipement findUnique
   */
  export type PersonnageEquipementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageEquipement to fetch.
     */
    where: PersonnageEquipementWhereUniqueInput
  }

  /**
   * PersonnageEquipement findUniqueOrThrow
   */
  export type PersonnageEquipementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageEquipement to fetch.
     */
    where: PersonnageEquipementWhereUniqueInput
  }

  /**
   * PersonnageEquipement findFirst
   */
  export type PersonnageEquipementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageEquipement to fetch.
     */
    where?: PersonnageEquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageEquipements to fetch.
     */
    orderBy?: PersonnageEquipementOrderByWithRelationInput | PersonnageEquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnageEquipements.
     */
    cursor?: PersonnageEquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageEquipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageEquipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnageEquipements.
     */
    distinct?: PersonnageEquipementScalarFieldEnum | PersonnageEquipementScalarFieldEnum[]
  }

  /**
   * PersonnageEquipement findFirstOrThrow
   */
  export type PersonnageEquipementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageEquipement to fetch.
     */
    where?: PersonnageEquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageEquipements to fetch.
     */
    orderBy?: PersonnageEquipementOrderByWithRelationInput | PersonnageEquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnageEquipements.
     */
    cursor?: PersonnageEquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageEquipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageEquipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnageEquipements.
     */
    distinct?: PersonnageEquipementScalarFieldEnum | PersonnageEquipementScalarFieldEnum[]
  }

  /**
   * PersonnageEquipement findMany
   */
  export type PersonnageEquipementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    /**
     * Filter, which PersonnageEquipements to fetch.
     */
    where?: PersonnageEquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnageEquipements to fetch.
     */
    orderBy?: PersonnageEquipementOrderByWithRelationInput | PersonnageEquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonnageEquipements.
     */
    cursor?: PersonnageEquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnageEquipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnageEquipements.
     */
    skip?: number
    distinct?: PersonnageEquipementScalarFieldEnum | PersonnageEquipementScalarFieldEnum[]
  }

  /**
   * PersonnageEquipement create
   */
  export type PersonnageEquipementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonnageEquipement.
     */
    data: XOR<PersonnageEquipementCreateInput, PersonnageEquipementUncheckedCreateInput>
  }

  /**
   * PersonnageEquipement createMany
   */
  export type PersonnageEquipementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonnageEquipements.
     */
    data: PersonnageEquipementCreateManyInput | PersonnageEquipementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonnageEquipement createManyAndReturn
   */
  export type PersonnageEquipementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PersonnageEquipements.
     */
    data: PersonnageEquipementCreateManyInput | PersonnageEquipementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonnageEquipement update
   */
  export type PersonnageEquipementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonnageEquipement.
     */
    data: XOR<PersonnageEquipementUpdateInput, PersonnageEquipementUncheckedUpdateInput>
    /**
     * Choose, which PersonnageEquipement to update.
     */
    where: PersonnageEquipementWhereUniqueInput
  }

  /**
   * PersonnageEquipement updateMany
   */
  export type PersonnageEquipementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonnageEquipements.
     */
    data: XOR<PersonnageEquipementUpdateManyMutationInput, PersonnageEquipementUncheckedUpdateManyInput>
    /**
     * Filter which PersonnageEquipements to update
     */
    where?: PersonnageEquipementWhereInput
  }

  /**
   * PersonnageEquipement upsert
   */
  export type PersonnageEquipementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonnageEquipement to update in case it exists.
     */
    where: PersonnageEquipementWhereUniqueInput
    /**
     * In case the PersonnageEquipement found by the `where` argument doesn't exist, create a new PersonnageEquipement with this data.
     */
    create: XOR<PersonnageEquipementCreateInput, PersonnageEquipementUncheckedCreateInput>
    /**
     * In case the PersonnageEquipement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnageEquipementUpdateInput, PersonnageEquipementUncheckedUpdateInput>
  }

  /**
   * PersonnageEquipement delete
   */
  export type PersonnageEquipementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
    /**
     * Filter which PersonnageEquipement to delete.
     */
    where: PersonnageEquipementWhereUniqueInput
  }

  /**
   * PersonnageEquipement deleteMany
   */
  export type PersonnageEquipementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnageEquipements to delete
     */
    where?: PersonnageEquipementWhereInput
  }

  /**
   * PersonnageEquipement without action
   */
  export type PersonnageEquipementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnageEquipement
     */
    select?: PersonnageEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnageEquipementInclude<ExtArgs> | null
  }


  /**
   * Model Marchand
   */

  export type AggregateMarchand = {
    _count: MarchandCountAggregateOutputType | null
    _avg: MarchandAvgAggregateOutputType | null
    _sum: MarchandSumAggregateOutputType | null
    _min: MarchandMinAggregateOutputType | null
    _max: MarchandMaxAggregateOutputType | null
  }

  export type MarchandAvgAggregateOutputType = {
    id: number | null
  }

  export type MarchandSumAggregateOutputType = {
    id: number | null
  }

  export type MarchandMinAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type MarchandMaxAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type MarchandCountAggregateOutputType = {
    id: number
    nom: number
    _all: number
  }


  export type MarchandAvgAggregateInputType = {
    id?: true
  }

  export type MarchandSumAggregateInputType = {
    id?: true
  }

  export type MarchandMinAggregateInputType = {
    id?: true
    nom?: true
  }

  export type MarchandMaxAggregateInputType = {
    id?: true
    nom?: true
  }

  export type MarchandCountAggregateInputType = {
    id?: true
    nom?: true
    _all?: true
  }

  export type MarchandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Marchand to aggregate.
     */
    where?: MarchandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marchands to fetch.
     */
    orderBy?: MarchandOrderByWithRelationInput | MarchandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarchandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marchands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marchands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Marchands
    **/
    _count?: true | MarchandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarchandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarchandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarchandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarchandMaxAggregateInputType
  }

  export type GetMarchandAggregateType<T extends MarchandAggregateArgs> = {
        [P in keyof T & keyof AggregateMarchand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarchand[P]>
      : GetScalarType<T[P], AggregateMarchand[P]>
  }




  export type MarchandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarchandWhereInput
    orderBy?: MarchandOrderByWithAggregationInput | MarchandOrderByWithAggregationInput[]
    by: MarchandScalarFieldEnum[] | MarchandScalarFieldEnum
    having?: MarchandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarchandCountAggregateInputType | true
    _avg?: MarchandAvgAggregateInputType
    _sum?: MarchandSumAggregateInputType
    _min?: MarchandMinAggregateInputType
    _max?: MarchandMaxAggregateInputType
  }

  export type MarchandGroupByOutputType = {
    id: number
    nom: string
    _count: MarchandCountAggregateOutputType | null
    _avg: MarchandAvgAggregateOutputType | null
    _sum: MarchandSumAggregateOutputType | null
    _min: MarchandMinAggregateOutputType | null
    _max: MarchandMaxAggregateOutputType | null
  }

  type GetMarchandGroupByPayload<T extends MarchandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarchandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarchandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarchandGroupByOutputType[P]>
            : GetScalarType<T[P], MarchandGroupByOutputType[P]>
        }
      >
    >


  export type MarchandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    routes?: boolean | Marchand$routesArgs<ExtArgs>
    _count?: boolean | MarchandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marchand"]>

  export type MarchandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
  }, ExtArgs["result"]["marchand"]>

  export type MarchandSelectScalar = {
    id?: boolean
    nom?: boolean
  }

  export type MarchandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routes?: boolean | Marchand$routesArgs<ExtArgs>
    _count?: boolean | MarchandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarchandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MarchandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Marchand"
    objects: {
      routes: Prisma.$MarchandRoutePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
    }, ExtArgs["result"]["marchand"]>
    composites: {}
  }

  type MarchandGetPayload<S extends boolean | null | undefined | MarchandDefaultArgs> = $Result.GetResult<Prisma.$MarchandPayload, S>

  type MarchandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarchandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarchandCountAggregateInputType | true
    }

  export interface MarchandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Marchand'], meta: { name: 'Marchand' } }
    /**
     * Find zero or one Marchand that matches the filter.
     * @param {MarchandFindUniqueArgs} args - Arguments to find a Marchand
     * @example
     * // Get one Marchand
     * const marchand = await prisma.marchand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarchandFindUniqueArgs>(args: SelectSubset<T, MarchandFindUniqueArgs<ExtArgs>>): Prisma__MarchandClient<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Marchand that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarchandFindUniqueOrThrowArgs} args - Arguments to find a Marchand
     * @example
     * // Get one Marchand
     * const marchand = await prisma.marchand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarchandFindUniqueOrThrowArgs>(args: SelectSubset<T, MarchandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarchandClient<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Marchand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandFindFirstArgs} args - Arguments to find a Marchand
     * @example
     * // Get one Marchand
     * const marchand = await prisma.marchand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarchandFindFirstArgs>(args?: SelectSubset<T, MarchandFindFirstArgs<ExtArgs>>): Prisma__MarchandClient<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Marchand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandFindFirstOrThrowArgs} args - Arguments to find a Marchand
     * @example
     * // Get one Marchand
     * const marchand = await prisma.marchand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarchandFindFirstOrThrowArgs>(args?: SelectSubset<T, MarchandFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarchandClient<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Marchands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marchands
     * const marchands = await prisma.marchand.findMany()
     * 
     * // Get first 10 Marchands
     * const marchands = await prisma.marchand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marchandWithIdOnly = await prisma.marchand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarchandFindManyArgs>(args?: SelectSubset<T, MarchandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Marchand.
     * @param {MarchandCreateArgs} args - Arguments to create a Marchand.
     * @example
     * // Create one Marchand
     * const Marchand = await prisma.marchand.create({
     *   data: {
     *     // ... data to create a Marchand
     *   }
     * })
     * 
     */
    create<T extends MarchandCreateArgs>(args: SelectSubset<T, MarchandCreateArgs<ExtArgs>>): Prisma__MarchandClient<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Marchands.
     * @param {MarchandCreateManyArgs} args - Arguments to create many Marchands.
     * @example
     * // Create many Marchands
     * const marchand = await prisma.marchand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarchandCreateManyArgs>(args?: SelectSubset<T, MarchandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Marchands and returns the data saved in the database.
     * @param {MarchandCreateManyAndReturnArgs} args - Arguments to create many Marchands.
     * @example
     * // Create many Marchands
     * const marchand = await prisma.marchand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Marchands and only return the `id`
     * const marchandWithIdOnly = await prisma.marchand.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarchandCreateManyAndReturnArgs>(args?: SelectSubset<T, MarchandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Marchand.
     * @param {MarchandDeleteArgs} args - Arguments to delete one Marchand.
     * @example
     * // Delete one Marchand
     * const Marchand = await prisma.marchand.delete({
     *   where: {
     *     // ... filter to delete one Marchand
     *   }
     * })
     * 
     */
    delete<T extends MarchandDeleteArgs>(args: SelectSubset<T, MarchandDeleteArgs<ExtArgs>>): Prisma__MarchandClient<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Marchand.
     * @param {MarchandUpdateArgs} args - Arguments to update one Marchand.
     * @example
     * // Update one Marchand
     * const marchand = await prisma.marchand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarchandUpdateArgs>(args: SelectSubset<T, MarchandUpdateArgs<ExtArgs>>): Prisma__MarchandClient<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Marchands.
     * @param {MarchandDeleteManyArgs} args - Arguments to filter Marchands to delete.
     * @example
     * // Delete a few Marchands
     * const { count } = await prisma.marchand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarchandDeleteManyArgs>(args?: SelectSubset<T, MarchandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marchands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marchands
     * const marchand = await prisma.marchand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarchandUpdateManyArgs>(args: SelectSubset<T, MarchandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Marchand.
     * @param {MarchandUpsertArgs} args - Arguments to update or create a Marchand.
     * @example
     * // Update or create a Marchand
     * const marchand = await prisma.marchand.upsert({
     *   create: {
     *     // ... data to create a Marchand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marchand we want to update
     *   }
     * })
     */
    upsert<T extends MarchandUpsertArgs>(args: SelectSubset<T, MarchandUpsertArgs<ExtArgs>>): Prisma__MarchandClient<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Marchands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandCountArgs} args - Arguments to filter Marchands to count.
     * @example
     * // Count the number of Marchands
     * const count = await prisma.marchand.count({
     *   where: {
     *     // ... the filter for the Marchands we want to count
     *   }
     * })
    **/
    count<T extends MarchandCountArgs>(
      args?: Subset<T, MarchandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarchandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marchand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarchandAggregateArgs>(args: Subset<T, MarchandAggregateArgs>): Prisma.PrismaPromise<GetMarchandAggregateType<T>>

    /**
     * Group by Marchand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarchandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarchandGroupByArgs['orderBy'] }
        : { orderBy?: MarchandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarchandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarchandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Marchand model
   */
  readonly fields: MarchandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Marchand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarchandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    routes<T extends Marchand$routesArgs<ExtArgs> = {}>(args?: Subset<T, Marchand$routesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Marchand model
   */ 
  interface MarchandFieldRefs {
    readonly id: FieldRef<"Marchand", 'Int'>
    readonly nom: FieldRef<"Marchand", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Marchand findUnique
   */
  export type MarchandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandInclude<ExtArgs> | null
    /**
     * Filter, which Marchand to fetch.
     */
    where: MarchandWhereUniqueInput
  }

  /**
   * Marchand findUniqueOrThrow
   */
  export type MarchandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandInclude<ExtArgs> | null
    /**
     * Filter, which Marchand to fetch.
     */
    where: MarchandWhereUniqueInput
  }

  /**
   * Marchand findFirst
   */
  export type MarchandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandInclude<ExtArgs> | null
    /**
     * Filter, which Marchand to fetch.
     */
    where?: MarchandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marchands to fetch.
     */
    orderBy?: MarchandOrderByWithRelationInput | MarchandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marchands.
     */
    cursor?: MarchandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marchands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marchands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marchands.
     */
    distinct?: MarchandScalarFieldEnum | MarchandScalarFieldEnum[]
  }

  /**
   * Marchand findFirstOrThrow
   */
  export type MarchandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandInclude<ExtArgs> | null
    /**
     * Filter, which Marchand to fetch.
     */
    where?: MarchandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marchands to fetch.
     */
    orderBy?: MarchandOrderByWithRelationInput | MarchandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marchands.
     */
    cursor?: MarchandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marchands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marchands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marchands.
     */
    distinct?: MarchandScalarFieldEnum | MarchandScalarFieldEnum[]
  }

  /**
   * Marchand findMany
   */
  export type MarchandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandInclude<ExtArgs> | null
    /**
     * Filter, which Marchands to fetch.
     */
    where?: MarchandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marchands to fetch.
     */
    orderBy?: MarchandOrderByWithRelationInput | MarchandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Marchands.
     */
    cursor?: MarchandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marchands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marchands.
     */
    skip?: number
    distinct?: MarchandScalarFieldEnum | MarchandScalarFieldEnum[]
  }

  /**
   * Marchand create
   */
  export type MarchandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandInclude<ExtArgs> | null
    /**
     * The data needed to create a Marchand.
     */
    data: XOR<MarchandCreateInput, MarchandUncheckedCreateInput>
  }

  /**
   * Marchand createMany
   */
  export type MarchandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Marchands.
     */
    data: MarchandCreateManyInput | MarchandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Marchand createManyAndReturn
   */
  export type MarchandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Marchands.
     */
    data: MarchandCreateManyInput | MarchandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Marchand update
   */
  export type MarchandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandInclude<ExtArgs> | null
    /**
     * The data needed to update a Marchand.
     */
    data: XOR<MarchandUpdateInput, MarchandUncheckedUpdateInput>
    /**
     * Choose, which Marchand to update.
     */
    where: MarchandWhereUniqueInput
  }

  /**
   * Marchand updateMany
   */
  export type MarchandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Marchands.
     */
    data: XOR<MarchandUpdateManyMutationInput, MarchandUncheckedUpdateManyInput>
    /**
     * Filter which Marchands to update
     */
    where?: MarchandWhereInput
  }

  /**
   * Marchand upsert
   */
  export type MarchandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandInclude<ExtArgs> | null
    /**
     * The filter to search for the Marchand to update in case it exists.
     */
    where: MarchandWhereUniqueInput
    /**
     * In case the Marchand found by the `where` argument doesn't exist, create a new Marchand with this data.
     */
    create: XOR<MarchandCreateInput, MarchandUncheckedCreateInput>
    /**
     * In case the Marchand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarchandUpdateInput, MarchandUncheckedUpdateInput>
  }

  /**
   * Marchand delete
   */
  export type MarchandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandInclude<ExtArgs> | null
    /**
     * Filter which Marchand to delete.
     */
    where: MarchandWhereUniqueInput
  }

  /**
   * Marchand deleteMany
   */
  export type MarchandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Marchands to delete
     */
    where?: MarchandWhereInput
  }

  /**
   * Marchand.routes
   */
  export type Marchand$routesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    where?: MarchandRouteWhereInput
    orderBy?: MarchandRouteOrderByWithRelationInput | MarchandRouteOrderByWithRelationInput[]
    cursor?: MarchandRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarchandRouteScalarFieldEnum | MarchandRouteScalarFieldEnum[]
  }

  /**
   * Marchand without action
   */
  export type MarchandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchand
     */
    select?: MarchandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandInclude<ExtArgs> | null
  }


  /**
   * Model RouteCommerciale
   */

  export type AggregateRouteCommerciale = {
    _count: RouteCommercialeCountAggregateOutputType | null
    _avg: RouteCommercialeAvgAggregateOutputType | null
    _sum: RouteCommercialeSumAggregateOutputType | null
    _min: RouteCommercialeMinAggregateOutputType | null
    _max: RouteCommercialeMaxAggregateOutputType | null
  }

  export type RouteCommercialeAvgAggregateOutputType = {
    id: number | null
  }

  export type RouteCommercialeSumAggregateOutputType = {
    id: number | null
  }

  export type RouteCommercialeMinAggregateOutputType = {
    id: number | null
    nom: string | null
    securite: string | null
    saison: string | null
  }

  export type RouteCommercialeMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    securite: string | null
    saison: string | null
  }

  export type RouteCommercialeCountAggregateOutputType = {
    id: number
    nom: number
    securite: number
    saison: number
    _all: number
  }


  export type RouteCommercialeAvgAggregateInputType = {
    id?: true
  }

  export type RouteCommercialeSumAggregateInputType = {
    id?: true
  }

  export type RouteCommercialeMinAggregateInputType = {
    id?: true
    nom?: true
    securite?: true
    saison?: true
  }

  export type RouteCommercialeMaxAggregateInputType = {
    id?: true
    nom?: true
    securite?: true
    saison?: true
  }

  export type RouteCommercialeCountAggregateInputType = {
    id?: true
    nom?: true
    securite?: true
    saison?: true
    _all?: true
  }

  export type RouteCommercialeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteCommerciale to aggregate.
     */
    where?: RouteCommercialeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteCommerciales to fetch.
     */
    orderBy?: RouteCommercialeOrderByWithRelationInput | RouteCommercialeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteCommercialeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteCommerciales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteCommerciales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteCommerciales
    **/
    _count?: true | RouteCommercialeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteCommercialeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteCommercialeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteCommercialeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteCommercialeMaxAggregateInputType
  }

  export type GetRouteCommercialeAggregateType<T extends RouteCommercialeAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteCommerciale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteCommerciale[P]>
      : GetScalarType<T[P], AggregateRouteCommerciale[P]>
  }




  export type RouteCommercialeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteCommercialeWhereInput
    orderBy?: RouteCommercialeOrderByWithAggregationInput | RouteCommercialeOrderByWithAggregationInput[]
    by: RouteCommercialeScalarFieldEnum[] | RouteCommercialeScalarFieldEnum
    having?: RouteCommercialeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteCommercialeCountAggregateInputType | true
    _avg?: RouteCommercialeAvgAggregateInputType
    _sum?: RouteCommercialeSumAggregateInputType
    _min?: RouteCommercialeMinAggregateInputType
    _max?: RouteCommercialeMaxAggregateInputType
  }

  export type RouteCommercialeGroupByOutputType = {
    id: number
    nom: string
    securite: string | null
    saison: string | null
    _count: RouteCommercialeCountAggregateOutputType | null
    _avg: RouteCommercialeAvgAggregateOutputType | null
    _sum: RouteCommercialeSumAggregateOutputType | null
    _min: RouteCommercialeMinAggregateOutputType | null
    _max: RouteCommercialeMaxAggregateOutputType | null
  }

  type GetRouteCommercialeGroupByPayload<T extends RouteCommercialeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteCommercialeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteCommercialeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteCommercialeGroupByOutputType[P]>
            : GetScalarType<T[P], RouteCommercialeGroupByOutputType[P]>
        }
      >
    >


  export type RouteCommercialeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    securite?: boolean
    saison?: boolean
    segments?: boolean | RouteCommerciale$segmentsArgs<ExtArgs>
    marchands?: boolean | RouteCommerciale$marchandsArgs<ExtArgs>
    _count?: boolean | RouteCommercialeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeCommerciale"]>

  export type RouteCommercialeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    securite?: boolean
    saison?: boolean
  }, ExtArgs["result"]["routeCommerciale"]>

  export type RouteCommercialeSelectScalar = {
    id?: boolean
    nom?: boolean
    securite?: boolean
    saison?: boolean
  }

  export type RouteCommercialeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segments?: boolean | RouteCommerciale$segmentsArgs<ExtArgs>
    marchands?: boolean | RouteCommerciale$marchandsArgs<ExtArgs>
    _count?: boolean | RouteCommercialeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RouteCommercialeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RouteCommercialePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteCommerciale"
    objects: {
      segments: Prisma.$RouteSegmentPayload<ExtArgs>[]
      marchands: Prisma.$MarchandRoutePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      securite: string | null
      saison: string | null
    }, ExtArgs["result"]["routeCommerciale"]>
    composites: {}
  }

  type RouteCommercialeGetPayload<S extends boolean | null | undefined | RouteCommercialeDefaultArgs> = $Result.GetResult<Prisma.$RouteCommercialePayload, S>

  type RouteCommercialeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RouteCommercialeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RouteCommercialeCountAggregateInputType | true
    }

  export interface RouteCommercialeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteCommerciale'], meta: { name: 'RouteCommerciale' } }
    /**
     * Find zero or one RouteCommerciale that matches the filter.
     * @param {RouteCommercialeFindUniqueArgs} args - Arguments to find a RouteCommerciale
     * @example
     * // Get one RouteCommerciale
     * const routeCommerciale = await prisma.routeCommerciale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteCommercialeFindUniqueArgs>(args: SelectSubset<T, RouteCommercialeFindUniqueArgs<ExtArgs>>): Prisma__RouteCommercialeClient<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RouteCommerciale that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RouteCommercialeFindUniqueOrThrowArgs} args - Arguments to find a RouteCommerciale
     * @example
     * // Get one RouteCommerciale
     * const routeCommerciale = await prisma.routeCommerciale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteCommercialeFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteCommercialeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteCommercialeClient<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RouteCommerciale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCommercialeFindFirstArgs} args - Arguments to find a RouteCommerciale
     * @example
     * // Get one RouteCommerciale
     * const routeCommerciale = await prisma.routeCommerciale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteCommercialeFindFirstArgs>(args?: SelectSubset<T, RouteCommercialeFindFirstArgs<ExtArgs>>): Prisma__RouteCommercialeClient<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RouteCommerciale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCommercialeFindFirstOrThrowArgs} args - Arguments to find a RouteCommerciale
     * @example
     * // Get one RouteCommerciale
     * const routeCommerciale = await prisma.routeCommerciale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteCommercialeFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteCommercialeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteCommercialeClient<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RouteCommerciales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCommercialeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteCommerciales
     * const routeCommerciales = await prisma.routeCommerciale.findMany()
     * 
     * // Get first 10 RouteCommerciales
     * const routeCommerciales = await prisma.routeCommerciale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeCommercialeWithIdOnly = await prisma.routeCommerciale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteCommercialeFindManyArgs>(args?: SelectSubset<T, RouteCommercialeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RouteCommerciale.
     * @param {RouteCommercialeCreateArgs} args - Arguments to create a RouteCommerciale.
     * @example
     * // Create one RouteCommerciale
     * const RouteCommerciale = await prisma.routeCommerciale.create({
     *   data: {
     *     // ... data to create a RouteCommerciale
     *   }
     * })
     * 
     */
    create<T extends RouteCommercialeCreateArgs>(args: SelectSubset<T, RouteCommercialeCreateArgs<ExtArgs>>): Prisma__RouteCommercialeClient<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RouteCommerciales.
     * @param {RouteCommercialeCreateManyArgs} args - Arguments to create many RouteCommerciales.
     * @example
     * // Create many RouteCommerciales
     * const routeCommerciale = await prisma.routeCommerciale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteCommercialeCreateManyArgs>(args?: SelectSubset<T, RouteCommercialeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteCommerciales and returns the data saved in the database.
     * @param {RouteCommercialeCreateManyAndReturnArgs} args - Arguments to create many RouteCommerciales.
     * @example
     * // Create many RouteCommerciales
     * const routeCommerciale = await prisma.routeCommerciale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteCommerciales and only return the `id`
     * const routeCommercialeWithIdOnly = await prisma.routeCommerciale.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteCommercialeCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteCommercialeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RouteCommerciale.
     * @param {RouteCommercialeDeleteArgs} args - Arguments to delete one RouteCommerciale.
     * @example
     * // Delete one RouteCommerciale
     * const RouteCommerciale = await prisma.routeCommerciale.delete({
     *   where: {
     *     // ... filter to delete one RouteCommerciale
     *   }
     * })
     * 
     */
    delete<T extends RouteCommercialeDeleteArgs>(args: SelectSubset<T, RouteCommercialeDeleteArgs<ExtArgs>>): Prisma__RouteCommercialeClient<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RouteCommerciale.
     * @param {RouteCommercialeUpdateArgs} args - Arguments to update one RouteCommerciale.
     * @example
     * // Update one RouteCommerciale
     * const routeCommerciale = await prisma.routeCommerciale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteCommercialeUpdateArgs>(args: SelectSubset<T, RouteCommercialeUpdateArgs<ExtArgs>>): Prisma__RouteCommercialeClient<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RouteCommerciales.
     * @param {RouteCommercialeDeleteManyArgs} args - Arguments to filter RouteCommerciales to delete.
     * @example
     * // Delete a few RouteCommerciales
     * const { count } = await prisma.routeCommerciale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteCommercialeDeleteManyArgs>(args?: SelectSubset<T, RouteCommercialeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteCommerciales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCommercialeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteCommerciales
     * const routeCommerciale = await prisma.routeCommerciale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteCommercialeUpdateManyArgs>(args: SelectSubset<T, RouteCommercialeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RouteCommerciale.
     * @param {RouteCommercialeUpsertArgs} args - Arguments to update or create a RouteCommerciale.
     * @example
     * // Update or create a RouteCommerciale
     * const routeCommerciale = await prisma.routeCommerciale.upsert({
     *   create: {
     *     // ... data to create a RouteCommerciale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteCommerciale we want to update
     *   }
     * })
     */
    upsert<T extends RouteCommercialeUpsertArgs>(args: SelectSubset<T, RouteCommercialeUpsertArgs<ExtArgs>>): Prisma__RouteCommercialeClient<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RouteCommerciales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCommercialeCountArgs} args - Arguments to filter RouteCommerciales to count.
     * @example
     * // Count the number of RouteCommerciales
     * const count = await prisma.routeCommerciale.count({
     *   where: {
     *     // ... the filter for the RouteCommerciales we want to count
     *   }
     * })
    **/
    count<T extends RouteCommercialeCountArgs>(
      args?: Subset<T, RouteCommercialeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteCommercialeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteCommerciale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCommercialeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteCommercialeAggregateArgs>(args: Subset<T, RouteCommercialeAggregateArgs>): Prisma.PrismaPromise<GetRouteCommercialeAggregateType<T>>

    /**
     * Group by RouteCommerciale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCommercialeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteCommercialeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteCommercialeGroupByArgs['orderBy'] }
        : { orderBy?: RouteCommercialeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteCommercialeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteCommercialeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteCommerciale model
   */
  readonly fields: RouteCommercialeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteCommerciale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteCommercialeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    segments<T extends RouteCommerciale$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, RouteCommerciale$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "findMany"> | Null>
    marchands<T extends RouteCommerciale$marchandsArgs<ExtArgs> = {}>(args?: Subset<T, RouteCommerciale$marchandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteCommerciale model
   */ 
  interface RouteCommercialeFieldRefs {
    readonly id: FieldRef<"RouteCommerciale", 'Int'>
    readonly nom: FieldRef<"RouteCommerciale", 'String'>
    readonly securite: FieldRef<"RouteCommerciale", 'String'>
    readonly saison: FieldRef<"RouteCommerciale", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RouteCommerciale findUnique
   */
  export type RouteCommercialeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteCommercialeInclude<ExtArgs> | null
    /**
     * Filter, which RouteCommerciale to fetch.
     */
    where: RouteCommercialeWhereUniqueInput
  }

  /**
   * RouteCommerciale findUniqueOrThrow
   */
  export type RouteCommercialeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteCommercialeInclude<ExtArgs> | null
    /**
     * Filter, which RouteCommerciale to fetch.
     */
    where: RouteCommercialeWhereUniqueInput
  }

  /**
   * RouteCommerciale findFirst
   */
  export type RouteCommercialeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteCommercialeInclude<ExtArgs> | null
    /**
     * Filter, which RouteCommerciale to fetch.
     */
    where?: RouteCommercialeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteCommerciales to fetch.
     */
    orderBy?: RouteCommercialeOrderByWithRelationInput | RouteCommercialeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteCommerciales.
     */
    cursor?: RouteCommercialeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteCommerciales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteCommerciales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteCommerciales.
     */
    distinct?: RouteCommercialeScalarFieldEnum | RouteCommercialeScalarFieldEnum[]
  }

  /**
   * RouteCommerciale findFirstOrThrow
   */
  export type RouteCommercialeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteCommercialeInclude<ExtArgs> | null
    /**
     * Filter, which RouteCommerciale to fetch.
     */
    where?: RouteCommercialeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteCommerciales to fetch.
     */
    orderBy?: RouteCommercialeOrderByWithRelationInput | RouteCommercialeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteCommerciales.
     */
    cursor?: RouteCommercialeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteCommerciales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteCommerciales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteCommerciales.
     */
    distinct?: RouteCommercialeScalarFieldEnum | RouteCommercialeScalarFieldEnum[]
  }

  /**
   * RouteCommerciale findMany
   */
  export type RouteCommercialeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteCommercialeInclude<ExtArgs> | null
    /**
     * Filter, which RouteCommerciales to fetch.
     */
    where?: RouteCommercialeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteCommerciales to fetch.
     */
    orderBy?: RouteCommercialeOrderByWithRelationInput | RouteCommercialeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteCommerciales.
     */
    cursor?: RouteCommercialeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteCommerciales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteCommerciales.
     */
    skip?: number
    distinct?: RouteCommercialeScalarFieldEnum | RouteCommercialeScalarFieldEnum[]
  }

  /**
   * RouteCommerciale create
   */
  export type RouteCommercialeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteCommercialeInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteCommerciale.
     */
    data: XOR<RouteCommercialeCreateInput, RouteCommercialeUncheckedCreateInput>
  }

  /**
   * RouteCommerciale createMany
   */
  export type RouteCommercialeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteCommerciales.
     */
    data: RouteCommercialeCreateManyInput | RouteCommercialeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteCommerciale createManyAndReturn
   */
  export type RouteCommercialeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RouteCommerciales.
     */
    data: RouteCommercialeCreateManyInput | RouteCommercialeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteCommerciale update
   */
  export type RouteCommercialeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteCommercialeInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteCommerciale.
     */
    data: XOR<RouteCommercialeUpdateInput, RouteCommercialeUncheckedUpdateInput>
    /**
     * Choose, which RouteCommerciale to update.
     */
    where: RouteCommercialeWhereUniqueInput
  }

  /**
   * RouteCommerciale updateMany
   */
  export type RouteCommercialeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteCommerciales.
     */
    data: XOR<RouteCommercialeUpdateManyMutationInput, RouteCommercialeUncheckedUpdateManyInput>
    /**
     * Filter which RouteCommerciales to update
     */
    where?: RouteCommercialeWhereInput
  }

  /**
   * RouteCommerciale upsert
   */
  export type RouteCommercialeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteCommercialeInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteCommerciale to update in case it exists.
     */
    where: RouteCommercialeWhereUniqueInput
    /**
     * In case the RouteCommerciale found by the `where` argument doesn't exist, create a new RouteCommerciale with this data.
     */
    create: XOR<RouteCommercialeCreateInput, RouteCommercialeUncheckedCreateInput>
    /**
     * In case the RouteCommerciale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteCommercialeUpdateInput, RouteCommercialeUncheckedUpdateInput>
  }

  /**
   * RouteCommerciale delete
   */
  export type RouteCommercialeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteCommercialeInclude<ExtArgs> | null
    /**
     * Filter which RouteCommerciale to delete.
     */
    where: RouteCommercialeWhereUniqueInput
  }

  /**
   * RouteCommerciale deleteMany
   */
  export type RouteCommercialeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteCommerciales to delete
     */
    where?: RouteCommercialeWhereInput
  }

  /**
   * RouteCommerciale.segments
   */
  export type RouteCommerciale$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    where?: RouteSegmentWhereInput
    orderBy?: RouteSegmentOrderByWithRelationInput | RouteSegmentOrderByWithRelationInput[]
    cursor?: RouteSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteSegmentScalarFieldEnum | RouteSegmentScalarFieldEnum[]
  }

  /**
   * RouteCommerciale.marchands
   */
  export type RouteCommerciale$marchandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    where?: MarchandRouteWhereInput
    orderBy?: MarchandRouteOrderByWithRelationInput | MarchandRouteOrderByWithRelationInput[]
    cursor?: MarchandRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarchandRouteScalarFieldEnum | MarchandRouteScalarFieldEnum[]
  }

  /**
   * RouteCommerciale without action
   */
  export type RouteCommercialeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCommerciale
     */
    select?: RouteCommercialeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteCommercialeInclude<ExtArgs> | null
  }


  /**
   * Model Lieu
   */

  export type AggregateLieu = {
    _count: LieuCountAggregateOutputType | null
    _avg: LieuAvgAggregateOutputType | null
    _sum: LieuSumAggregateOutputType | null
    _min: LieuMinAggregateOutputType | null
    _max: LieuMaxAggregateOutputType | null
  }

  export type LieuAvgAggregateOutputType = {
    id: number | null
  }

  export type LieuSumAggregateOutputType = {
    id: number | null
  }

  export type LieuMinAggregateOutputType = {
    id: number | null
    nom: string | null
    typeLieu: string | null
    localisation: string | null
  }

  export type LieuMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    typeLieu: string | null
    localisation: string | null
  }

  export type LieuCountAggregateOutputType = {
    id: number
    nom: number
    typeLieu: number
    localisation: number
    _all: number
  }


  export type LieuAvgAggregateInputType = {
    id?: true
  }

  export type LieuSumAggregateInputType = {
    id?: true
  }

  export type LieuMinAggregateInputType = {
    id?: true
    nom?: true
    typeLieu?: true
    localisation?: true
  }

  export type LieuMaxAggregateInputType = {
    id?: true
    nom?: true
    typeLieu?: true
    localisation?: true
  }

  export type LieuCountAggregateInputType = {
    id?: true
    nom?: true
    typeLieu?: true
    localisation?: true
    _all?: true
  }

  export type LieuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lieu to aggregate.
     */
    where?: LieuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lieus to fetch.
     */
    orderBy?: LieuOrderByWithRelationInput | LieuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LieuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lieus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lieus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lieus
    **/
    _count?: true | LieuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LieuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LieuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LieuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LieuMaxAggregateInputType
  }

  export type GetLieuAggregateType<T extends LieuAggregateArgs> = {
        [P in keyof T & keyof AggregateLieu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLieu[P]>
      : GetScalarType<T[P], AggregateLieu[P]>
  }




  export type LieuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LieuWhereInput
    orderBy?: LieuOrderByWithAggregationInput | LieuOrderByWithAggregationInput[]
    by: LieuScalarFieldEnum[] | LieuScalarFieldEnum
    having?: LieuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LieuCountAggregateInputType | true
    _avg?: LieuAvgAggregateInputType
    _sum?: LieuSumAggregateInputType
    _min?: LieuMinAggregateInputType
    _max?: LieuMaxAggregateInputType
  }

  export type LieuGroupByOutputType = {
    id: number
    nom: string
    typeLieu: string | null
    localisation: string | null
    _count: LieuCountAggregateOutputType | null
    _avg: LieuAvgAggregateOutputType | null
    _sum: LieuSumAggregateOutputType | null
    _min: LieuMinAggregateOutputType | null
    _max: LieuMaxAggregateOutputType | null
  }

  type GetLieuGroupByPayload<T extends LieuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LieuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LieuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LieuGroupByOutputType[P]>
            : GetScalarType<T[P], LieuGroupByOutputType[P]>
        }
      >
    >


  export type LieuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    typeLieu?: boolean
    localisation?: boolean
    segments?: boolean | Lieu$segmentsArgs<ExtArgs>
    inventaires?: boolean | Lieu$inventairesArgs<ExtArgs>
    _count?: boolean | LieuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lieu"]>

  export type LieuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    typeLieu?: boolean
    localisation?: boolean
  }, ExtArgs["result"]["lieu"]>

  export type LieuSelectScalar = {
    id?: boolean
    nom?: boolean
    typeLieu?: boolean
    localisation?: boolean
  }

  export type LieuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segments?: boolean | Lieu$segmentsArgs<ExtArgs>
    inventaires?: boolean | Lieu$inventairesArgs<ExtArgs>
    _count?: boolean | LieuCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LieuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LieuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lieu"
    objects: {
      segments: Prisma.$RouteSegmentPayload<ExtArgs>[]
      inventaires: Prisma.$InventairePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      typeLieu: string | null
      localisation: string | null
    }, ExtArgs["result"]["lieu"]>
    composites: {}
  }

  type LieuGetPayload<S extends boolean | null | undefined | LieuDefaultArgs> = $Result.GetResult<Prisma.$LieuPayload, S>

  type LieuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LieuFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LieuCountAggregateInputType | true
    }

  export interface LieuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lieu'], meta: { name: 'Lieu' } }
    /**
     * Find zero or one Lieu that matches the filter.
     * @param {LieuFindUniqueArgs} args - Arguments to find a Lieu
     * @example
     * // Get one Lieu
     * const lieu = await prisma.lieu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LieuFindUniqueArgs>(args: SelectSubset<T, LieuFindUniqueArgs<ExtArgs>>): Prisma__LieuClient<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lieu that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LieuFindUniqueOrThrowArgs} args - Arguments to find a Lieu
     * @example
     * // Get one Lieu
     * const lieu = await prisma.lieu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LieuFindUniqueOrThrowArgs>(args: SelectSubset<T, LieuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LieuClient<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lieu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuFindFirstArgs} args - Arguments to find a Lieu
     * @example
     * // Get one Lieu
     * const lieu = await prisma.lieu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LieuFindFirstArgs>(args?: SelectSubset<T, LieuFindFirstArgs<ExtArgs>>): Prisma__LieuClient<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lieu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuFindFirstOrThrowArgs} args - Arguments to find a Lieu
     * @example
     * // Get one Lieu
     * const lieu = await prisma.lieu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LieuFindFirstOrThrowArgs>(args?: SelectSubset<T, LieuFindFirstOrThrowArgs<ExtArgs>>): Prisma__LieuClient<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lieus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lieus
     * const lieus = await prisma.lieu.findMany()
     * 
     * // Get first 10 Lieus
     * const lieus = await prisma.lieu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lieuWithIdOnly = await prisma.lieu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LieuFindManyArgs>(args?: SelectSubset<T, LieuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lieu.
     * @param {LieuCreateArgs} args - Arguments to create a Lieu.
     * @example
     * // Create one Lieu
     * const Lieu = await prisma.lieu.create({
     *   data: {
     *     // ... data to create a Lieu
     *   }
     * })
     * 
     */
    create<T extends LieuCreateArgs>(args: SelectSubset<T, LieuCreateArgs<ExtArgs>>): Prisma__LieuClient<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lieus.
     * @param {LieuCreateManyArgs} args - Arguments to create many Lieus.
     * @example
     * // Create many Lieus
     * const lieu = await prisma.lieu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LieuCreateManyArgs>(args?: SelectSubset<T, LieuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lieus and returns the data saved in the database.
     * @param {LieuCreateManyAndReturnArgs} args - Arguments to create many Lieus.
     * @example
     * // Create many Lieus
     * const lieu = await prisma.lieu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lieus and only return the `id`
     * const lieuWithIdOnly = await prisma.lieu.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LieuCreateManyAndReturnArgs>(args?: SelectSubset<T, LieuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lieu.
     * @param {LieuDeleteArgs} args - Arguments to delete one Lieu.
     * @example
     * // Delete one Lieu
     * const Lieu = await prisma.lieu.delete({
     *   where: {
     *     // ... filter to delete one Lieu
     *   }
     * })
     * 
     */
    delete<T extends LieuDeleteArgs>(args: SelectSubset<T, LieuDeleteArgs<ExtArgs>>): Prisma__LieuClient<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lieu.
     * @param {LieuUpdateArgs} args - Arguments to update one Lieu.
     * @example
     * // Update one Lieu
     * const lieu = await prisma.lieu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LieuUpdateArgs>(args: SelectSubset<T, LieuUpdateArgs<ExtArgs>>): Prisma__LieuClient<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lieus.
     * @param {LieuDeleteManyArgs} args - Arguments to filter Lieus to delete.
     * @example
     * // Delete a few Lieus
     * const { count } = await prisma.lieu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LieuDeleteManyArgs>(args?: SelectSubset<T, LieuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lieus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lieus
     * const lieu = await prisma.lieu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LieuUpdateManyArgs>(args: SelectSubset<T, LieuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lieu.
     * @param {LieuUpsertArgs} args - Arguments to update or create a Lieu.
     * @example
     * // Update or create a Lieu
     * const lieu = await prisma.lieu.upsert({
     *   create: {
     *     // ... data to create a Lieu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lieu we want to update
     *   }
     * })
     */
    upsert<T extends LieuUpsertArgs>(args: SelectSubset<T, LieuUpsertArgs<ExtArgs>>): Prisma__LieuClient<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lieus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuCountArgs} args - Arguments to filter Lieus to count.
     * @example
     * // Count the number of Lieus
     * const count = await prisma.lieu.count({
     *   where: {
     *     // ... the filter for the Lieus we want to count
     *   }
     * })
    **/
    count<T extends LieuCountArgs>(
      args?: Subset<T, LieuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LieuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lieu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LieuAggregateArgs>(args: Subset<T, LieuAggregateArgs>): Prisma.PrismaPromise<GetLieuAggregateType<T>>

    /**
     * Group by Lieu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LieuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LieuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LieuGroupByArgs['orderBy'] }
        : { orderBy?: LieuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LieuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLieuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lieu model
   */
  readonly fields: LieuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lieu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LieuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    segments<T extends Lieu$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, Lieu$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "findMany"> | Null>
    inventaires<T extends Lieu$inventairesArgs<ExtArgs> = {}>(args?: Subset<T, Lieu$inventairesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lieu model
   */ 
  interface LieuFieldRefs {
    readonly id: FieldRef<"Lieu", 'Int'>
    readonly nom: FieldRef<"Lieu", 'String'>
    readonly typeLieu: FieldRef<"Lieu", 'String'>
    readonly localisation: FieldRef<"Lieu", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lieu findUnique
   */
  export type LieuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
    /**
     * Filter, which Lieu to fetch.
     */
    where: LieuWhereUniqueInput
  }

  /**
   * Lieu findUniqueOrThrow
   */
  export type LieuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
    /**
     * Filter, which Lieu to fetch.
     */
    where: LieuWhereUniqueInput
  }

  /**
   * Lieu findFirst
   */
  export type LieuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
    /**
     * Filter, which Lieu to fetch.
     */
    where?: LieuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lieus to fetch.
     */
    orderBy?: LieuOrderByWithRelationInput | LieuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lieus.
     */
    cursor?: LieuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lieus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lieus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lieus.
     */
    distinct?: LieuScalarFieldEnum | LieuScalarFieldEnum[]
  }

  /**
   * Lieu findFirstOrThrow
   */
  export type LieuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
    /**
     * Filter, which Lieu to fetch.
     */
    where?: LieuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lieus to fetch.
     */
    orderBy?: LieuOrderByWithRelationInput | LieuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lieus.
     */
    cursor?: LieuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lieus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lieus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lieus.
     */
    distinct?: LieuScalarFieldEnum | LieuScalarFieldEnum[]
  }

  /**
   * Lieu findMany
   */
  export type LieuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
    /**
     * Filter, which Lieus to fetch.
     */
    where?: LieuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lieus to fetch.
     */
    orderBy?: LieuOrderByWithRelationInput | LieuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lieus.
     */
    cursor?: LieuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lieus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lieus.
     */
    skip?: number
    distinct?: LieuScalarFieldEnum | LieuScalarFieldEnum[]
  }

  /**
   * Lieu create
   */
  export type LieuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
    /**
     * The data needed to create a Lieu.
     */
    data: XOR<LieuCreateInput, LieuUncheckedCreateInput>
  }

  /**
   * Lieu createMany
   */
  export type LieuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lieus.
     */
    data: LieuCreateManyInput | LieuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lieu createManyAndReturn
   */
  export type LieuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lieus.
     */
    data: LieuCreateManyInput | LieuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lieu update
   */
  export type LieuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
    /**
     * The data needed to update a Lieu.
     */
    data: XOR<LieuUpdateInput, LieuUncheckedUpdateInput>
    /**
     * Choose, which Lieu to update.
     */
    where: LieuWhereUniqueInput
  }

  /**
   * Lieu updateMany
   */
  export type LieuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lieus.
     */
    data: XOR<LieuUpdateManyMutationInput, LieuUncheckedUpdateManyInput>
    /**
     * Filter which Lieus to update
     */
    where?: LieuWhereInput
  }

  /**
   * Lieu upsert
   */
  export type LieuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
    /**
     * The filter to search for the Lieu to update in case it exists.
     */
    where: LieuWhereUniqueInput
    /**
     * In case the Lieu found by the `where` argument doesn't exist, create a new Lieu with this data.
     */
    create: XOR<LieuCreateInput, LieuUncheckedCreateInput>
    /**
     * In case the Lieu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LieuUpdateInput, LieuUncheckedUpdateInput>
  }

  /**
   * Lieu delete
   */
  export type LieuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
    /**
     * Filter which Lieu to delete.
     */
    where: LieuWhereUniqueInput
  }

  /**
   * Lieu deleteMany
   */
  export type LieuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lieus to delete
     */
    where?: LieuWhereInput
  }

  /**
   * Lieu.segments
   */
  export type Lieu$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    where?: RouteSegmentWhereInput
    orderBy?: RouteSegmentOrderByWithRelationInput | RouteSegmentOrderByWithRelationInput[]
    cursor?: RouteSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteSegmentScalarFieldEnum | RouteSegmentScalarFieldEnum[]
  }

  /**
   * Lieu.inventaires
   */
  export type Lieu$inventairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    where?: InventaireWhereInput
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    cursor?: InventaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventaireScalarFieldEnum | InventaireScalarFieldEnum[]
  }

  /**
   * Lieu without action
   */
  export type LieuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
  }


  /**
   * Model RouteSegment
   */

  export type AggregateRouteSegment = {
    _count: RouteSegmentCountAggregateOutputType | null
    _avg: RouteSegmentAvgAggregateOutputType | null
    _sum: RouteSegmentSumAggregateOutputType | null
    _min: RouteSegmentMinAggregateOutputType | null
    _max: RouteSegmentMaxAggregateOutputType | null
  }

  export type RouteSegmentAvgAggregateOutputType = {
    routeId: number | null
    lieuId: number | null
    ordre: number | null
  }

  export type RouteSegmentSumAggregateOutputType = {
    routeId: number | null
    lieuId: number | null
    ordre: number | null
  }

  export type RouteSegmentMinAggregateOutputType = {
    routeId: number | null
    lieuId: number | null
    ordre: number | null
  }

  export type RouteSegmentMaxAggregateOutputType = {
    routeId: number | null
    lieuId: number | null
    ordre: number | null
  }

  export type RouteSegmentCountAggregateOutputType = {
    routeId: number
    lieuId: number
    ordre: number
    _all: number
  }


  export type RouteSegmentAvgAggregateInputType = {
    routeId?: true
    lieuId?: true
    ordre?: true
  }

  export type RouteSegmentSumAggregateInputType = {
    routeId?: true
    lieuId?: true
    ordre?: true
  }

  export type RouteSegmentMinAggregateInputType = {
    routeId?: true
    lieuId?: true
    ordre?: true
  }

  export type RouteSegmentMaxAggregateInputType = {
    routeId?: true
    lieuId?: true
    ordre?: true
  }

  export type RouteSegmentCountAggregateInputType = {
    routeId?: true
    lieuId?: true
    ordre?: true
    _all?: true
  }

  export type RouteSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteSegment to aggregate.
     */
    where?: RouteSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteSegments to fetch.
     */
    orderBy?: RouteSegmentOrderByWithRelationInput | RouteSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteSegments
    **/
    _count?: true | RouteSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteSegmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteSegmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteSegmentMaxAggregateInputType
  }

  export type GetRouteSegmentAggregateType<T extends RouteSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteSegment[P]>
      : GetScalarType<T[P], AggregateRouteSegment[P]>
  }




  export type RouteSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteSegmentWhereInput
    orderBy?: RouteSegmentOrderByWithAggregationInput | RouteSegmentOrderByWithAggregationInput[]
    by: RouteSegmentScalarFieldEnum[] | RouteSegmentScalarFieldEnum
    having?: RouteSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteSegmentCountAggregateInputType | true
    _avg?: RouteSegmentAvgAggregateInputType
    _sum?: RouteSegmentSumAggregateInputType
    _min?: RouteSegmentMinAggregateInputType
    _max?: RouteSegmentMaxAggregateInputType
  }

  export type RouteSegmentGroupByOutputType = {
    routeId: number
    lieuId: number
    ordre: number
    _count: RouteSegmentCountAggregateOutputType | null
    _avg: RouteSegmentAvgAggregateOutputType | null
    _sum: RouteSegmentSumAggregateOutputType | null
    _min: RouteSegmentMinAggregateOutputType | null
    _max: RouteSegmentMaxAggregateOutputType | null
  }

  type GetRouteSegmentGroupByPayload<T extends RouteSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], RouteSegmentGroupByOutputType[P]>
        }
      >
    >


  export type RouteSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    routeId?: boolean
    lieuId?: boolean
    ordre?: boolean
    route?: boolean | RouteCommercialeDefaultArgs<ExtArgs>
    lieu?: boolean | LieuDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeSegment"]>

  export type RouteSegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    routeId?: boolean
    lieuId?: boolean
    ordre?: boolean
    route?: boolean | RouteCommercialeDefaultArgs<ExtArgs>
    lieu?: boolean | LieuDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeSegment"]>

  export type RouteSegmentSelectScalar = {
    routeId?: boolean
    lieuId?: boolean
    ordre?: boolean
  }

  export type RouteSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteCommercialeDefaultArgs<ExtArgs>
    lieu?: boolean | LieuDefaultArgs<ExtArgs>
  }
  export type RouteSegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteCommercialeDefaultArgs<ExtArgs>
    lieu?: boolean | LieuDefaultArgs<ExtArgs>
  }

  export type $RouteSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteSegment"
    objects: {
      route: Prisma.$RouteCommercialePayload<ExtArgs>
      lieu: Prisma.$LieuPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      routeId: number
      lieuId: number
      ordre: number
    }, ExtArgs["result"]["routeSegment"]>
    composites: {}
  }

  type RouteSegmentGetPayload<S extends boolean | null | undefined | RouteSegmentDefaultArgs> = $Result.GetResult<Prisma.$RouteSegmentPayload, S>

  type RouteSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RouteSegmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RouteSegmentCountAggregateInputType | true
    }

  export interface RouteSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteSegment'], meta: { name: 'RouteSegment' } }
    /**
     * Find zero or one RouteSegment that matches the filter.
     * @param {RouteSegmentFindUniqueArgs} args - Arguments to find a RouteSegment
     * @example
     * // Get one RouteSegment
     * const routeSegment = await prisma.routeSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteSegmentFindUniqueArgs>(args: SelectSubset<T, RouteSegmentFindUniqueArgs<ExtArgs>>): Prisma__RouteSegmentClient<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RouteSegment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RouteSegmentFindUniqueOrThrowArgs} args - Arguments to find a RouteSegment
     * @example
     * // Get one RouteSegment
     * const routeSegment = await prisma.routeSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteSegmentClient<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RouteSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteSegmentFindFirstArgs} args - Arguments to find a RouteSegment
     * @example
     * // Get one RouteSegment
     * const routeSegment = await prisma.routeSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteSegmentFindFirstArgs>(args?: SelectSubset<T, RouteSegmentFindFirstArgs<ExtArgs>>): Prisma__RouteSegmentClient<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RouteSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteSegmentFindFirstOrThrowArgs} args - Arguments to find a RouteSegment
     * @example
     * // Get one RouteSegment
     * const routeSegment = await prisma.routeSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteSegmentClient<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RouteSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteSegments
     * const routeSegments = await prisma.routeSegment.findMany()
     * 
     * // Get first 10 RouteSegments
     * const routeSegments = await prisma.routeSegment.findMany({ take: 10 })
     * 
     * // Only select the `routeId`
     * const routeSegmentWithRouteIdOnly = await prisma.routeSegment.findMany({ select: { routeId: true } })
     * 
     */
    findMany<T extends RouteSegmentFindManyArgs>(args?: SelectSubset<T, RouteSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RouteSegment.
     * @param {RouteSegmentCreateArgs} args - Arguments to create a RouteSegment.
     * @example
     * // Create one RouteSegment
     * const RouteSegment = await prisma.routeSegment.create({
     *   data: {
     *     // ... data to create a RouteSegment
     *   }
     * })
     * 
     */
    create<T extends RouteSegmentCreateArgs>(args: SelectSubset<T, RouteSegmentCreateArgs<ExtArgs>>): Prisma__RouteSegmentClient<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RouteSegments.
     * @param {RouteSegmentCreateManyArgs} args - Arguments to create many RouteSegments.
     * @example
     * // Create many RouteSegments
     * const routeSegment = await prisma.routeSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteSegmentCreateManyArgs>(args?: SelectSubset<T, RouteSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteSegments and returns the data saved in the database.
     * @param {RouteSegmentCreateManyAndReturnArgs} args - Arguments to create many RouteSegments.
     * @example
     * // Create many RouteSegments
     * const routeSegment = await prisma.routeSegment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteSegments and only return the `routeId`
     * const routeSegmentWithRouteIdOnly = await prisma.routeSegment.createManyAndReturn({ 
     *   select: { routeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteSegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteSegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RouteSegment.
     * @param {RouteSegmentDeleteArgs} args - Arguments to delete one RouteSegment.
     * @example
     * // Delete one RouteSegment
     * const RouteSegment = await prisma.routeSegment.delete({
     *   where: {
     *     // ... filter to delete one RouteSegment
     *   }
     * })
     * 
     */
    delete<T extends RouteSegmentDeleteArgs>(args: SelectSubset<T, RouteSegmentDeleteArgs<ExtArgs>>): Prisma__RouteSegmentClient<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RouteSegment.
     * @param {RouteSegmentUpdateArgs} args - Arguments to update one RouteSegment.
     * @example
     * // Update one RouteSegment
     * const routeSegment = await prisma.routeSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteSegmentUpdateArgs>(args: SelectSubset<T, RouteSegmentUpdateArgs<ExtArgs>>): Prisma__RouteSegmentClient<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RouteSegments.
     * @param {RouteSegmentDeleteManyArgs} args - Arguments to filter RouteSegments to delete.
     * @example
     * // Delete a few RouteSegments
     * const { count } = await prisma.routeSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteSegmentDeleteManyArgs>(args?: SelectSubset<T, RouteSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteSegments
     * const routeSegment = await prisma.routeSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteSegmentUpdateManyArgs>(args: SelectSubset<T, RouteSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RouteSegment.
     * @param {RouteSegmentUpsertArgs} args - Arguments to update or create a RouteSegment.
     * @example
     * // Update or create a RouteSegment
     * const routeSegment = await prisma.routeSegment.upsert({
     *   create: {
     *     // ... data to create a RouteSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteSegment we want to update
     *   }
     * })
     */
    upsert<T extends RouteSegmentUpsertArgs>(args: SelectSubset<T, RouteSegmentUpsertArgs<ExtArgs>>): Prisma__RouteSegmentClient<$Result.GetResult<Prisma.$RouteSegmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RouteSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteSegmentCountArgs} args - Arguments to filter RouteSegments to count.
     * @example
     * // Count the number of RouteSegments
     * const count = await prisma.routeSegment.count({
     *   where: {
     *     // ... the filter for the RouteSegments we want to count
     *   }
     * })
    **/
    count<T extends RouteSegmentCountArgs>(
      args?: Subset<T, RouteSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteSegmentAggregateArgs>(args: Subset<T, RouteSegmentAggregateArgs>): Prisma.PrismaPromise<GetRouteSegmentAggregateType<T>>

    /**
     * Group by RouteSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteSegmentGroupByArgs['orderBy'] }
        : { orderBy?: RouteSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteSegment model
   */
  readonly fields: RouteSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends RouteCommercialeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteCommercialeDefaultArgs<ExtArgs>>): Prisma__RouteCommercialeClient<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lieu<T extends LieuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LieuDefaultArgs<ExtArgs>>): Prisma__LieuClient<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteSegment model
   */ 
  interface RouteSegmentFieldRefs {
    readonly routeId: FieldRef<"RouteSegment", 'Int'>
    readonly lieuId: FieldRef<"RouteSegment", 'Int'>
    readonly ordre: FieldRef<"RouteSegment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RouteSegment findUnique
   */
  export type RouteSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    /**
     * Filter, which RouteSegment to fetch.
     */
    where: RouteSegmentWhereUniqueInput
  }

  /**
   * RouteSegment findUniqueOrThrow
   */
  export type RouteSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    /**
     * Filter, which RouteSegment to fetch.
     */
    where: RouteSegmentWhereUniqueInput
  }

  /**
   * RouteSegment findFirst
   */
  export type RouteSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    /**
     * Filter, which RouteSegment to fetch.
     */
    where?: RouteSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteSegments to fetch.
     */
    orderBy?: RouteSegmentOrderByWithRelationInput | RouteSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteSegments.
     */
    cursor?: RouteSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteSegments.
     */
    distinct?: RouteSegmentScalarFieldEnum | RouteSegmentScalarFieldEnum[]
  }

  /**
   * RouteSegment findFirstOrThrow
   */
  export type RouteSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    /**
     * Filter, which RouteSegment to fetch.
     */
    where?: RouteSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteSegments to fetch.
     */
    orderBy?: RouteSegmentOrderByWithRelationInput | RouteSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteSegments.
     */
    cursor?: RouteSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteSegments.
     */
    distinct?: RouteSegmentScalarFieldEnum | RouteSegmentScalarFieldEnum[]
  }

  /**
   * RouteSegment findMany
   */
  export type RouteSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    /**
     * Filter, which RouteSegments to fetch.
     */
    where?: RouteSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteSegments to fetch.
     */
    orderBy?: RouteSegmentOrderByWithRelationInput | RouteSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteSegments.
     */
    cursor?: RouteSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteSegments.
     */
    skip?: number
    distinct?: RouteSegmentScalarFieldEnum | RouteSegmentScalarFieldEnum[]
  }

  /**
   * RouteSegment create
   */
  export type RouteSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteSegment.
     */
    data: XOR<RouteSegmentCreateInput, RouteSegmentUncheckedCreateInput>
  }

  /**
   * RouteSegment createMany
   */
  export type RouteSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteSegments.
     */
    data: RouteSegmentCreateManyInput | RouteSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteSegment createManyAndReturn
   */
  export type RouteSegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RouteSegments.
     */
    data: RouteSegmentCreateManyInput | RouteSegmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteSegment update
   */
  export type RouteSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteSegment.
     */
    data: XOR<RouteSegmentUpdateInput, RouteSegmentUncheckedUpdateInput>
    /**
     * Choose, which RouteSegment to update.
     */
    where: RouteSegmentWhereUniqueInput
  }

  /**
   * RouteSegment updateMany
   */
  export type RouteSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteSegments.
     */
    data: XOR<RouteSegmentUpdateManyMutationInput, RouteSegmentUncheckedUpdateManyInput>
    /**
     * Filter which RouteSegments to update
     */
    where?: RouteSegmentWhereInput
  }

  /**
   * RouteSegment upsert
   */
  export type RouteSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteSegment to update in case it exists.
     */
    where: RouteSegmentWhereUniqueInput
    /**
     * In case the RouteSegment found by the `where` argument doesn't exist, create a new RouteSegment with this data.
     */
    create: XOR<RouteSegmentCreateInput, RouteSegmentUncheckedCreateInput>
    /**
     * In case the RouteSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteSegmentUpdateInput, RouteSegmentUncheckedUpdateInput>
  }

  /**
   * RouteSegment delete
   */
  export type RouteSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
    /**
     * Filter which RouteSegment to delete.
     */
    where: RouteSegmentWhereUniqueInput
  }

  /**
   * RouteSegment deleteMany
   */
  export type RouteSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteSegments to delete
     */
    where?: RouteSegmentWhereInput
  }

  /**
   * RouteSegment without action
   */
  export type RouteSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteSegment
     */
    select?: RouteSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteSegmentInclude<ExtArgs> | null
  }


  /**
   * Model MarchandRoute
   */

  export type AggregateMarchandRoute = {
    _count: MarchandRouteCountAggregateOutputType | null
    _avg: MarchandRouteAvgAggregateOutputType | null
    _sum: MarchandRouteSumAggregateOutputType | null
    _min: MarchandRouteMinAggregateOutputType | null
    _max: MarchandRouteMaxAggregateOutputType | null
  }

  export type MarchandRouteAvgAggregateOutputType = {
    marchandId: number | null
    routeId: number | null
    taxes: number | null
  }

  export type MarchandRouteSumAggregateOutputType = {
    marchandId: number | null
    routeId: number | null
    taxes: number | null
  }

  export type MarchandRouteMinAggregateOutputType = {
    marchandId: number | null
    routeId: number | null
    biens: string | null
    taxes: number | null
  }

  export type MarchandRouteMaxAggregateOutputType = {
    marchandId: number | null
    routeId: number | null
    biens: string | null
    taxes: number | null
  }

  export type MarchandRouteCountAggregateOutputType = {
    marchandId: number
    routeId: number
    biens: number
    taxes: number
    _all: number
  }


  export type MarchandRouteAvgAggregateInputType = {
    marchandId?: true
    routeId?: true
    taxes?: true
  }

  export type MarchandRouteSumAggregateInputType = {
    marchandId?: true
    routeId?: true
    taxes?: true
  }

  export type MarchandRouteMinAggregateInputType = {
    marchandId?: true
    routeId?: true
    biens?: true
    taxes?: true
  }

  export type MarchandRouteMaxAggregateInputType = {
    marchandId?: true
    routeId?: true
    biens?: true
    taxes?: true
  }

  export type MarchandRouteCountAggregateInputType = {
    marchandId?: true
    routeId?: true
    biens?: true
    taxes?: true
    _all?: true
  }

  export type MarchandRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarchandRoute to aggregate.
     */
    where?: MarchandRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarchandRoutes to fetch.
     */
    orderBy?: MarchandRouteOrderByWithRelationInput | MarchandRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarchandRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarchandRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarchandRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarchandRoutes
    **/
    _count?: true | MarchandRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarchandRouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarchandRouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarchandRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarchandRouteMaxAggregateInputType
  }

  export type GetMarchandRouteAggregateType<T extends MarchandRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateMarchandRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarchandRoute[P]>
      : GetScalarType<T[P], AggregateMarchandRoute[P]>
  }




  export type MarchandRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarchandRouteWhereInput
    orderBy?: MarchandRouteOrderByWithAggregationInput | MarchandRouteOrderByWithAggregationInput[]
    by: MarchandRouteScalarFieldEnum[] | MarchandRouteScalarFieldEnum
    having?: MarchandRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarchandRouteCountAggregateInputType | true
    _avg?: MarchandRouteAvgAggregateInputType
    _sum?: MarchandRouteSumAggregateInputType
    _min?: MarchandRouteMinAggregateInputType
    _max?: MarchandRouteMaxAggregateInputType
  }

  export type MarchandRouteGroupByOutputType = {
    marchandId: number
    routeId: number
    biens: string | null
    taxes: number | null
    _count: MarchandRouteCountAggregateOutputType | null
    _avg: MarchandRouteAvgAggregateOutputType | null
    _sum: MarchandRouteSumAggregateOutputType | null
    _min: MarchandRouteMinAggregateOutputType | null
    _max: MarchandRouteMaxAggregateOutputType | null
  }

  type GetMarchandRouteGroupByPayload<T extends MarchandRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarchandRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarchandRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarchandRouteGroupByOutputType[P]>
            : GetScalarType<T[P], MarchandRouteGroupByOutputType[P]>
        }
      >
    >


  export type MarchandRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    marchandId?: boolean
    routeId?: boolean
    biens?: boolean
    taxes?: boolean
    marchand?: boolean | MarchandDefaultArgs<ExtArgs>
    route?: boolean | RouteCommercialeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marchandRoute"]>

  export type MarchandRouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    marchandId?: boolean
    routeId?: boolean
    biens?: boolean
    taxes?: boolean
    marchand?: boolean | MarchandDefaultArgs<ExtArgs>
    route?: boolean | RouteCommercialeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marchandRoute"]>

  export type MarchandRouteSelectScalar = {
    marchandId?: boolean
    routeId?: boolean
    biens?: boolean
    taxes?: boolean
  }

  export type MarchandRouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marchand?: boolean | MarchandDefaultArgs<ExtArgs>
    route?: boolean | RouteCommercialeDefaultArgs<ExtArgs>
  }
  export type MarchandRouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marchand?: boolean | MarchandDefaultArgs<ExtArgs>
    route?: boolean | RouteCommercialeDefaultArgs<ExtArgs>
  }

  export type $MarchandRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarchandRoute"
    objects: {
      marchand: Prisma.$MarchandPayload<ExtArgs>
      route: Prisma.$RouteCommercialePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      marchandId: number
      routeId: number
      biens: string | null
      taxes: number | null
    }, ExtArgs["result"]["marchandRoute"]>
    composites: {}
  }

  type MarchandRouteGetPayload<S extends boolean | null | undefined | MarchandRouteDefaultArgs> = $Result.GetResult<Prisma.$MarchandRoutePayload, S>

  type MarchandRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarchandRouteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarchandRouteCountAggregateInputType | true
    }

  export interface MarchandRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarchandRoute'], meta: { name: 'MarchandRoute' } }
    /**
     * Find zero or one MarchandRoute that matches the filter.
     * @param {MarchandRouteFindUniqueArgs} args - Arguments to find a MarchandRoute
     * @example
     * // Get one MarchandRoute
     * const marchandRoute = await prisma.marchandRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarchandRouteFindUniqueArgs>(args: SelectSubset<T, MarchandRouteFindUniqueArgs<ExtArgs>>): Prisma__MarchandRouteClient<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarchandRoute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarchandRouteFindUniqueOrThrowArgs} args - Arguments to find a MarchandRoute
     * @example
     * // Get one MarchandRoute
     * const marchandRoute = await prisma.marchandRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarchandRouteFindUniqueOrThrowArgs>(args: SelectSubset<T, MarchandRouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarchandRouteClient<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarchandRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandRouteFindFirstArgs} args - Arguments to find a MarchandRoute
     * @example
     * // Get one MarchandRoute
     * const marchandRoute = await prisma.marchandRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarchandRouteFindFirstArgs>(args?: SelectSubset<T, MarchandRouteFindFirstArgs<ExtArgs>>): Prisma__MarchandRouteClient<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarchandRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandRouteFindFirstOrThrowArgs} args - Arguments to find a MarchandRoute
     * @example
     * // Get one MarchandRoute
     * const marchandRoute = await prisma.marchandRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarchandRouteFindFirstOrThrowArgs>(args?: SelectSubset<T, MarchandRouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarchandRouteClient<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarchandRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandRouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarchandRoutes
     * const marchandRoutes = await prisma.marchandRoute.findMany()
     * 
     * // Get first 10 MarchandRoutes
     * const marchandRoutes = await prisma.marchandRoute.findMany({ take: 10 })
     * 
     * // Only select the `marchandId`
     * const marchandRouteWithMarchandIdOnly = await prisma.marchandRoute.findMany({ select: { marchandId: true } })
     * 
     */
    findMany<T extends MarchandRouteFindManyArgs>(args?: SelectSubset<T, MarchandRouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarchandRoute.
     * @param {MarchandRouteCreateArgs} args - Arguments to create a MarchandRoute.
     * @example
     * // Create one MarchandRoute
     * const MarchandRoute = await prisma.marchandRoute.create({
     *   data: {
     *     // ... data to create a MarchandRoute
     *   }
     * })
     * 
     */
    create<T extends MarchandRouteCreateArgs>(args: SelectSubset<T, MarchandRouteCreateArgs<ExtArgs>>): Prisma__MarchandRouteClient<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarchandRoutes.
     * @param {MarchandRouteCreateManyArgs} args - Arguments to create many MarchandRoutes.
     * @example
     * // Create many MarchandRoutes
     * const marchandRoute = await prisma.marchandRoute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarchandRouteCreateManyArgs>(args?: SelectSubset<T, MarchandRouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarchandRoutes and returns the data saved in the database.
     * @param {MarchandRouteCreateManyAndReturnArgs} args - Arguments to create many MarchandRoutes.
     * @example
     * // Create many MarchandRoutes
     * const marchandRoute = await prisma.marchandRoute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarchandRoutes and only return the `marchandId`
     * const marchandRouteWithMarchandIdOnly = await prisma.marchandRoute.createManyAndReturn({ 
     *   select: { marchandId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarchandRouteCreateManyAndReturnArgs>(args?: SelectSubset<T, MarchandRouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarchandRoute.
     * @param {MarchandRouteDeleteArgs} args - Arguments to delete one MarchandRoute.
     * @example
     * // Delete one MarchandRoute
     * const MarchandRoute = await prisma.marchandRoute.delete({
     *   where: {
     *     // ... filter to delete one MarchandRoute
     *   }
     * })
     * 
     */
    delete<T extends MarchandRouteDeleteArgs>(args: SelectSubset<T, MarchandRouteDeleteArgs<ExtArgs>>): Prisma__MarchandRouteClient<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarchandRoute.
     * @param {MarchandRouteUpdateArgs} args - Arguments to update one MarchandRoute.
     * @example
     * // Update one MarchandRoute
     * const marchandRoute = await prisma.marchandRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarchandRouteUpdateArgs>(args: SelectSubset<T, MarchandRouteUpdateArgs<ExtArgs>>): Prisma__MarchandRouteClient<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarchandRoutes.
     * @param {MarchandRouteDeleteManyArgs} args - Arguments to filter MarchandRoutes to delete.
     * @example
     * // Delete a few MarchandRoutes
     * const { count } = await prisma.marchandRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarchandRouteDeleteManyArgs>(args?: SelectSubset<T, MarchandRouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarchandRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarchandRoutes
     * const marchandRoute = await prisma.marchandRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarchandRouteUpdateManyArgs>(args: SelectSubset<T, MarchandRouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarchandRoute.
     * @param {MarchandRouteUpsertArgs} args - Arguments to update or create a MarchandRoute.
     * @example
     * // Update or create a MarchandRoute
     * const marchandRoute = await prisma.marchandRoute.upsert({
     *   create: {
     *     // ... data to create a MarchandRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarchandRoute we want to update
     *   }
     * })
     */
    upsert<T extends MarchandRouteUpsertArgs>(args: SelectSubset<T, MarchandRouteUpsertArgs<ExtArgs>>): Prisma__MarchandRouteClient<$Result.GetResult<Prisma.$MarchandRoutePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarchandRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandRouteCountArgs} args - Arguments to filter MarchandRoutes to count.
     * @example
     * // Count the number of MarchandRoutes
     * const count = await prisma.marchandRoute.count({
     *   where: {
     *     // ... the filter for the MarchandRoutes we want to count
     *   }
     * })
    **/
    count<T extends MarchandRouteCountArgs>(
      args?: Subset<T, MarchandRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarchandRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarchandRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarchandRouteAggregateArgs>(args: Subset<T, MarchandRouteAggregateArgs>): Prisma.PrismaPromise<GetMarchandRouteAggregateType<T>>

    /**
     * Group by MarchandRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarchandRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarchandRouteGroupByArgs['orderBy'] }
        : { orderBy?: MarchandRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarchandRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarchandRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarchandRoute model
   */
  readonly fields: MarchandRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarchandRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarchandRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marchand<T extends MarchandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarchandDefaultArgs<ExtArgs>>): Prisma__MarchandClient<$Result.GetResult<Prisma.$MarchandPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    route<T extends RouteCommercialeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteCommercialeDefaultArgs<ExtArgs>>): Prisma__RouteCommercialeClient<$Result.GetResult<Prisma.$RouteCommercialePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarchandRoute model
   */ 
  interface MarchandRouteFieldRefs {
    readonly marchandId: FieldRef<"MarchandRoute", 'Int'>
    readonly routeId: FieldRef<"MarchandRoute", 'Int'>
    readonly biens: FieldRef<"MarchandRoute", 'String'>
    readonly taxes: FieldRef<"MarchandRoute", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * MarchandRoute findUnique
   */
  export type MarchandRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    /**
     * Filter, which MarchandRoute to fetch.
     */
    where: MarchandRouteWhereUniqueInput
  }

  /**
   * MarchandRoute findUniqueOrThrow
   */
  export type MarchandRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    /**
     * Filter, which MarchandRoute to fetch.
     */
    where: MarchandRouteWhereUniqueInput
  }

  /**
   * MarchandRoute findFirst
   */
  export type MarchandRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    /**
     * Filter, which MarchandRoute to fetch.
     */
    where?: MarchandRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarchandRoutes to fetch.
     */
    orderBy?: MarchandRouteOrderByWithRelationInput | MarchandRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarchandRoutes.
     */
    cursor?: MarchandRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarchandRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarchandRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarchandRoutes.
     */
    distinct?: MarchandRouteScalarFieldEnum | MarchandRouteScalarFieldEnum[]
  }

  /**
   * MarchandRoute findFirstOrThrow
   */
  export type MarchandRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    /**
     * Filter, which MarchandRoute to fetch.
     */
    where?: MarchandRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarchandRoutes to fetch.
     */
    orderBy?: MarchandRouteOrderByWithRelationInput | MarchandRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarchandRoutes.
     */
    cursor?: MarchandRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarchandRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarchandRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarchandRoutes.
     */
    distinct?: MarchandRouteScalarFieldEnum | MarchandRouteScalarFieldEnum[]
  }

  /**
   * MarchandRoute findMany
   */
  export type MarchandRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    /**
     * Filter, which MarchandRoutes to fetch.
     */
    where?: MarchandRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarchandRoutes to fetch.
     */
    orderBy?: MarchandRouteOrderByWithRelationInput | MarchandRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarchandRoutes.
     */
    cursor?: MarchandRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarchandRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarchandRoutes.
     */
    skip?: number
    distinct?: MarchandRouteScalarFieldEnum | MarchandRouteScalarFieldEnum[]
  }

  /**
   * MarchandRoute create
   */
  export type MarchandRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a MarchandRoute.
     */
    data: XOR<MarchandRouteCreateInput, MarchandRouteUncheckedCreateInput>
  }

  /**
   * MarchandRoute createMany
   */
  export type MarchandRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarchandRoutes.
     */
    data: MarchandRouteCreateManyInput | MarchandRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarchandRoute createManyAndReturn
   */
  export type MarchandRouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarchandRoutes.
     */
    data: MarchandRouteCreateManyInput | MarchandRouteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarchandRoute update
   */
  export type MarchandRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a MarchandRoute.
     */
    data: XOR<MarchandRouteUpdateInput, MarchandRouteUncheckedUpdateInput>
    /**
     * Choose, which MarchandRoute to update.
     */
    where: MarchandRouteWhereUniqueInput
  }

  /**
   * MarchandRoute updateMany
   */
  export type MarchandRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarchandRoutes.
     */
    data: XOR<MarchandRouteUpdateManyMutationInput, MarchandRouteUncheckedUpdateManyInput>
    /**
     * Filter which MarchandRoutes to update
     */
    where?: MarchandRouteWhereInput
  }

  /**
   * MarchandRoute upsert
   */
  export type MarchandRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the MarchandRoute to update in case it exists.
     */
    where: MarchandRouteWhereUniqueInput
    /**
     * In case the MarchandRoute found by the `where` argument doesn't exist, create a new MarchandRoute with this data.
     */
    create: XOR<MarchandRouteCreateInput, MarchandRouteUncheckedCreateInput>
    /**
     * In case the MarchandRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarchandRouteUpdateInput, MarchandRouteUncheckedUpdateInput>
  }

  /**
   * MarchandRoute delete
   */
  export type MarchandRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
    /**
     * Filter which MarchandRoute to delete.
     */
    where: MarchandRouteWhereUniqueInput
  }

  /**
   * MarchandRoute deleteMany
   */
  export type MarchandRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarchandRoutes to delete
     */
    where?: MarchandRouteWhereInput
  }

  /**
   * MarchandRoute without action
   */
  export type MarchandRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandRoute
     */
    select?: MarchandRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandRouteInclude<ExtArgs> | null
  }


  /**
   * Model Barde
   */

  export type AggregateBarde = {
    _count: BardeCountAggregateOutputType | null
    _avg: BardeAvgAggregateOutputType | null
    _sum: BardeSumAggregateOutputType | null
    _min: BardeMinAggregateOutputType | null
    _max: BardeMaxAggregateOutputType | null
  }

  export type BardeAvgAggregateOutputType = {
    id: number | null
  }

  export type BardeSumAggregateOutputType = {
    id: number | null
  }

  export type BardeMinAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type BardeMaxAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type BardeCountAggregateOutputType = {
    id: number
    nom: number
    _all: number
  }


  export type BardeAvgAggregateInputType = {
    id?: true
  }

  export type BardeSumAggregateInputType = {
    id?: true
  }

  export type BardeMinAggregateInputType = {
    id?: true
    nom?: true
  }

  export type BardeMaxAggregateInputType = {
    id?: true
    nom?: true
  }

  export type BardeCountAggregateInputType = {
    id?: true
    nom?: true
    _all?: true
  }

  export type BardeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Barde to aggregate.
     */
    where?: BardeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bardes to fetch.
     */
    orderBy?: BardeOrderByWithRelationInput | BardeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BardeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bardes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bardes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bardes
    **/
    _count?: true | BardeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BardeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BardeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BardeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BardeMaxAggregateInputType
  }

  export type GetBardeAggregateType<T extends BardeAggregateArgs> = {
        [P in keyof T & keyof AggregateBarde]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarde[P]>
      : GetScalarType<T[P], AggregateBarde[P]>
  }




  export type BardeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BardeWhereInput
    orderBy?: BardeOrderByWithAggregationInput | BardeOrderByWithAggregationInput[]
    by: BardeScalarFieldEnum[] | BardeScalarFieldEnum
    having?: BardeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BardeCountAggregateInputType | true
    _avg?: BardeAvgAggregateInputType
    _sum?: BardeSumAggregateInputType
    _min?: BardeMinAggregateInputType
    _max?: BardeMaxAggregateInputType
  }

  export type BardeGroupByOutputType = {
    id: number
    nom: string
    _count: BardeCountAggregateOutputType | null
    _avg: BardeAvgAggregateOutputType | null
    _sum: BardeSumAggregateOutputType | null
    _min: BardeMinAggregateOutputType | null
    _max: BardeMaxAggregateOutputType | null
  }

  type GetBardeGroupByPayload<T extends BardeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BardeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BardeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BardeGroupByOutputType[P]>
            : GetScalarType<T[P], BardeGroupByOutputType[P]>
        }
      >
    >


  export type BardeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    histoires?: boolean | Barde$histoiresArgs<ExtArgs>
    _count?: boolean | BardeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barde"]>

  export type BardeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
  }, ExtArgs["result"]["barde"]>

  export type BardeSelectScalar = {
    id?: boolean
    nom?: boolean
  }

  export type BardeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histoires?: boolean | Barde$histoiresArgs<ExtArgs>
    _count?: boolean | BardeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BardeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BardePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Barde"
    objects: {
      histoires: Prisma.$HistoirePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
    }, ExtArgs["result"]["barde"]>
    composites: {}
  }

  type BardeGetPayload<S extends boolean | null | undefined | BardeDefaultArgs> = $Result.GetResult<Prisma.$BardePayload, S>

  type BardeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BardeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BardeCountAggregateInputType | true
    }

  export interface BardeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Barde'], meta: { name: 'Barde' } }
    /**
     * Find zero or one Barde that matches the filter.
     * @param {BardeFindUniqueArgs} args - Arguments to find a Barde
     * @example
     * // Get one Barde
     * const barde = await prisma.barde.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BardeFindUniqueArgs>(args: SelectSubset<T, BardeFindUniqueArgs<ExtArgs>>): Prisma__BardeClient<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Barde that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BardeFindUniqueOrThrowArgs} args - Arguments to find a Barde
     * @example
     * // Get one Barde
     * const barde = await prisma.barde.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BardeFindUniqueOrThrowArgs>(args: SelectSubset<T, BardeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BardeClient<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Barde that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BardeFindFirstArgs} args - Arguments to find a Barde
     * @example
     * // Get one Barde
     * const barde = await prisma.barde.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BardeFindFirstArgs>(args?: SelectSubset<T, BardeFindFirstArgs<ExtArgs>>): Prisma__BardeClient<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Barde that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BardeFindFirstOrThrowArgs} args - Arguments to find a Barde
     * @example
     * // Get one Barde
     * const barde = await prisma.barde.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BardeFindFirstOrThrowArgs>(args?: SelectSubset<T, BardeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BardeClient<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bardes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BardeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bardes
     * const bardes = await prisma.barde.findMany()
     * 
     * // Get first 10 Bardes
     * const bardes = await prisma.barde.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bardeWithIdOnly = await prisma.barde.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BardeFindManyArgs>(args?: SelectSubset<T, BardeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Barde.
     * @param {BardeCreateArgs} args - Arguments to create a Barde.
     * @example
     * // Create one Barde
     * const Barde = await prisma.barde.create({
     *   data: {
     *     // ... data to create a Barde
     *   }
     * })
     * 
     */
    create<T extends BardeCreateArgs>(args: SelectSubset<T, BardeCreateArgs<ExtArgs>>): Prisma__BardeClient<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bardes.
     * @param {BardeCreateManyArgs} args - Arguments to create many Bardes.
     * @example
     * // Create many Bardes
     * const barde = await prisma.barde.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BardeCreateManyArgs>(args?: SelectSubset<T, BardeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bardes and returns the data saved in the database.
     * @param {BardeCreateManyAndReturnArgs} args - Arguments to create many Bardes.
     * @example
     * // Create many Bardes
     * const barde = await prisma.barde.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bardes and only return the `id`
     * const bardeWithIdOnly = await prisma.barde.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BardeCreateManyAndReturnArgs>(args?: SelectSubset<T, BardeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Barde.
     * @param {BardeDeleteArgs} args - Arguments to delete one Barde.
     * @example
     * // Delete one Barde
     * const Barde = await prisma.barde.delete({
     *   where: {
     *     // ... filter to delete one Barde
     *   }
     * })
     * 
     */
    delete<T extends BardeDeleteArgs>(args: SelectSubset<T, BardeDeleteArgs<ExtArgs>>): Prisma__BardeClient<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Barde.
     * @param {BardeUpdateArgs} args - Arguments to update one Barde.
     * @example
     * // Update one Barde
     * const barde = await prisma.barde.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BardeUpdateArgs>(args: SelectSubset<T, BardeUpdateArgs<ExtArgs>>): Prisma__BardeClient<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bardes.
     * @param {BardeDeleteManyArgs} args - Arguments to filter Bardes to delete.
     * @example
     * // Delete a few Bardes
     * const { count } = await prisma.barde.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BardeDeleteManyArgs>(args?: SelectSubset<T, BardeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bardes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BardeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bardes
     * const barde = await prisma.barde.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BardeUpdateManyArgs>(args: SelectSubset<T, BardeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Barde.
     * @param {BardeUpsertArgs} args - Arguments to update or create a Barde.
     * @example
     * // Update or create a Barde
     * const barde = await prisma.barde.upsert({
     *   create: {
     *     // ... data to create a Barde
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Barde we want to update
     *   }
     * })
     */
    upsert<T extends BardeUpsertArgs>(args: SelectSubset<T, BardeUpsertArgs<ExtArgs>>): Prisma__BardeClient<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bardes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BardeCountArgs} args - Arguments to filter Bardes to count.
     * @example
     * // Count the number of Bardes
     * const count = await prisma.barde.count({
     *   where: {
     *     // ... the filter for the Bardes we want to count
     *   }
     * })
    **/
    count<T extends BardeCountArgs>(
      args?: Subset<T, BardeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BardeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Barde.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BardeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BardeAggregateArgs>(args: Subset<T, BardeAggregateArgs>): Prisma.PrismaPromise<GetBardeAggregateType<T>>

    /**
     * Group by Barde.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BardeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BardeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BardeGroupByArgs['orderBy'] }
        : { orderBy?: BardeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BardeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBardeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Barde model
   */
  readonly fields: BardeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Barde.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BardeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    histoires<T extends Barde$histoiresArgs<ExtArgs> = {}>(args?: Subset<T, Barde$histoiresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Barde model
   */ 
  interface BardeFieldRefs {
    readonly id: FieldRef<"Barde", 'Int'>
    readonly nom: FieldRef<"Barde", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Barde findUnique
   */
  export type BardeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
    /**
     * Filter, which Barde to fetch.
     */
    where: BardeWhereUniqueInput
  }

  /**
   * Barde findUniqueOrThrow
   */
  export type BardeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
    /**
     * Filter, which Barde to fetch.
     */
    where: BardeWhereUniqueInput
  }

  /**
   * Barde findFirst
   */
  export type BardeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
    /**
     * Filter, which Barde to fetch.
     */
    where?: BardeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bardes to fetch.
     */
    orderBy?: BardeOrderByWithRelationInput | BardeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bardes.
     */
    cursor?: BardeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bardes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bardes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bardes.
     */
    distinct?: BardeScalarFieldEnum | BardeScalarFieldEnum[]
  }

  /**
   * Barde findFirstOrThrow
   */
  export type BardeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
    /**
     * Filter, which Barde to fetch.
     */
    where?: BardeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bardes to fetch.
     */
    orderBy?: BardeOrderByWithRelationInput | BardeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bardes.
     */
    cursor?: BardeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bardes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bardes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bardes.
     */
    distinct?: BardeScalarFieldEnum | BardeScalarFieldEnum[]
  }

  /**
   * Barde findMany
   */
  export type BardeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
    /**
     * Filter, which Bardes to fetch.
     */
    where?: BardeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bardes to fetch.
     */
    orderBy?: BardeOrderByWithRelationInput | BardeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bardes.
     */
    cursor?: BardeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bardes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bardes.
     */
    skip?: number
    distinct?: BardeScalarFieldEnum | BardeScalarFieldEnum[]
  }

  /**
   * Barde create
   */
  export type BardeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
    /**
     * The data needed to create a Barde.
     */
    data: XOR<BardeCreateInput, BardeUncheckedCreateInput>
  }

  /**
   * Barde createMany
   */
  export type BardeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bardes.
     */
    data: BardeCreateManyInput | BardeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Barde createManyAndReturn
   */
  export type BardeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bardes.
     */
    data: BardeCreateManyInput | BardeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Barde update
   */
  export type BardeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
    /**
     * The data needed to update a Barde.
     */
    data: XOR<BardeUpdateInput, BardeUncheckedUpdateInput>
    /**
     * Choose, which Barde to update.
     */
    where: BardeWhereUniqueInput
  }

  /**
   * Barde updateMany
   */
  export type BardeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bardes.
     */
    data: XOR<BardeUpdateManyMutationInput, BardeUncheckedUpdateManyInput>
    /**
     * Filter which Bardes to update
     */
    where?: BardeWhereInput
  }

  /**
   * Barde upsert
   */
  export type BardeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
    /**
     * The filter to search for the Barde to update in case it exists.
     */
    where: BardeWhereUniqueInput
    /**
     * In case the Barde found by the `where` argument doesn't exist, create a new Barde with this data.
     */
    create: XOR<BardeCreateInput, BardeUncheckedCreateInput>
    /**
     * In case the Barde was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BardeUpdateInput, BardeUncheckedUpdateInput>
  }

  /**
   * Barde delete
   */
  export type BardeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
    /**
     * Filter which Barde to delete.
     */
    where: BardeWhereUniqueInput
  }

  /**
   * Barde deleteMany
   */
  export type BardeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bardes to delete
     */
    where?: BardeWhereInput
  }

  /**
   * Barde.histoires
   */
  export type Barde$histoiresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
    where?: HistoireWhereInput
    orderBy?: HistoireOrderByWithRelationInput | HistoireOrderByWithRelationInput[]
    cursor?: HistoireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoireScalarFieldEnum | HistoireScalarFieldEnum[]
  }

  /**
   * Barde without action
   */
  export type BardeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
  }


  /**
   * Model Histoire
   */

  export type AggregateHistoire = {
    _count: HistoireCountAggregateOutputType | null
    _avg: HistoireAvgAggregateOutputType | null
    _sum: HistoireSumAggregateOutputType | null
    _min: HistoireMinAggregateOutputType | null
    _max: HistoireMaxAggregateOutputType | null
  }

  export type HistoireAvgAggregateOutputType = {
    id: number | null
    bardeId: number | null
  }

  export type HistoireSumAggregateOutputType = {
    id: number | null
    bardeId: number | null
  }

  export type HistoireMinAggregateOutputType = {
    id: number | null
    titre: string | null
    typeEvenement: string | null
    description: string | null
    dateEvenement: Date | null
    bardeId: number | null
  }

  export type HistoireMaxAggregateOutputType = {
    id: number | null
    titre: string | null
    typeEvenement: string | null
    description: string | null
    dateEvenement: Date | null
    bardeId: number | null
  }

  export type HistoireCountAggregateOutputType = {
    id: number
    titre: number
    typeEvenement: number
    description: number
    dateEvenement: number
    bardeId: number
    _all: number
  }


  export type HistoireAvgAggregateInputType = {
    id?: true
    bardeId?: true
  }

  export type HistoireSumAggregateInputType = {
    id?: true
    bardeId?: true
  }

  export type HistoireMinAggregateInputType = {
    id?: true
    titre?: true
    typeEvenement?: true
    description?: true
    dateEvenement?: true
    bardeId?: true
  }

  export type HistoireMaxAggregateInputType = {
    id?: true
    titre?: true
    typeEvenement?: true
    description?: true
    dateEvenement?: true
    bardeId?: true
  }

  export type HistoireCountAggregateInputType = {
    id?: true
    titre?: true
    typeEvenement?: true
    description?: true
    dateEvenement?: true
    bardeId?: true
    _all?: true
  }

  export type HistoireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Histoire to aggregate.
     */
    where?: HistoireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histoires to fetch.
     */
    orderBy?: HistoireOrderByWithRelationInput | HistoireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistoireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Histoires
    **/
    _count?: true | HistoireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoireMaxAggregateInputType
  }

  export type GetHistoireAggregateType<T extends HistoireAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoire[P]>
      : GetScalarType<T[P], AggregateHistoire[P]>
  }




  export type HistoireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoireWhereInput
    orderBy?: HistoireOrderByWithAggregationInput | HistoireOrderByWithAggregationInput[]
    by: HistoireScalarFieldEnum[] | HistoireScalarFieldEnum
    having?: HistoireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoireCountAggregateInputType | true
    _avg?: HistoireAvgAggregateInputType
    _sum?: HistoireSumAggregateInputType
    _min?: HistoireMinAggregateInputType
    _max?: HistoireMaxAggregateInputType
  }

  export type HistoireGroupByOutputType = {
    id: number
    titre: string | null
    typeEvenement: string | null
    description: string | null
    dateEvenement: Date | null
    bardeId: number | null
    _count: HistoireCountAggregateOutputType | null
    _avg: HistoireAvgAggregateOutputType | null
    _sum: HistoireSumAggregateOutputType | null
    _min: HistoireMinAggregateOutputType | null
    _max: HistoireMaxAggregateOutputType | null
  }

  type GetHistoireGroupByPayload<T extends HistoireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoireGroupByOutputType[P]>
            : GetScalarType<T[P], HistoireGroupByOutputType[P]>
        }
      >
    >


  export type HistoireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    typeEvenement?: boolean
    description?: boolean
    dateEvenement?: boolean
    bardeId?: boolean
    barde?: boolean | Histoire$bardeArgs<ExtArgs>
  }, ExtArgs["result"]["histoire"]>

  export type HistoireSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    typeEvenement?: boolean
    description?: boolean
    dateEvenement?: boolean
    bardeId?: boolean
    barde?: boolean | Histoire$bardeArgs<ExtArgs>
  }, ExtArgs["result"]["histoire"]>

  export type HistoireSelectScalar = {
    id?: boolean
    titre?: boolean
    typeEvenement?: boolean
    description?: boolean
    dateEvenement?: boolean
    bardeId?: boolean
  }

  export type HistoireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barde?: boolean | Histoire$bardeArgs<ExtArgs>
  }
  export type HistoireIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barde?: boolean | Histoire$bardeArgs<ExtArgs>
  }

  export type $HistoirePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Histoire"
    objects: {
      barde: Prisma.$BardePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titre: string | null
      typeEvenement: string | null
      description: string | null
      dateEvenement: Date | null
      bardeId: number | null
    }, ExtArgs["result"]["histoire"]>
    composites: {}
  }

  type HistoireGetPayload<S extends boolean | null | undefined | HistoireDefaultArgs> = $Result.GetResult<Prisma.$HistoirePayload, S>

  type HistoireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HistoireFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistoireCountAggregateInputType | true
    }

  export interface HistoireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Histoire'], meta: { name: 'Histoire' } }
    /**
     * Find zero or one Histoire that matches the filter.
     * @param {HistoireFindUniqueArgs} args - Arguments to find a Histoire
     * @example
     * // Get one Histoire
     * const histoire = await prisma.histoire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistoireFindUniqueArgs>(args: SelectSubset<T, HistoireFindUniqueArgs<ExtArgs>>): Prisma__HistoireClient<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Histoire that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HistoireFindUniqueOrThrowArgs} args - Arguments to find a Histoire
     * @example
     * // Get one Histoire
     * const histoire = await prisma.histoire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistoireFindUniqueOrThrowArgs>(args: SelectSubset<T, HistoireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistoireClient<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Histoire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoireFindFirstArgs} args - Arguments to find a Histoire
     * @example
     * // Get one Histoire
     * const histoire = await prisma.histoire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistoireFindFirstArgs>(args?: SelectSubset<T, HistoireFindFirstArgs<ExtArgs>>): Prisma__HistoireClient<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Histoire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoireFindFirstOrThrowArgs} args - Arguments to find a Histoire
     * @example
     * // Get one Histoire
     * const histoire = await prisma.histoire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistoireFindFirstOrThrowArgs>(args?: SelectSubset<T, HistoireFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistoireClient<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Histoires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Histoires
     * const histoires = await prisma.histoire.findMany()
     * 
     * // Get first 10 Histoires
     * const histoires = await prisma.histoire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const histoireWithIdOnly = await prisma.histoire.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HistoireFindManyArgs>(args?: SelectSubset<T, HistoireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Histoire.
     * @param {HistoireCreateArgs} args - Arguments to create a Histoire.
     * @example
     * // Create one Histoire
     * const Histoire = await prisma.histoire.create({
     *   data: {
     *     // ... data to create a Histoire
     *   }
     * })
     * 
     */
    create<T extends HistoireCreateArgs>(args: SelectSubset<T, HistoireCreateArgs<ExtArgs>>): Prisma__HistoireClient<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Histoires.
     * @param {HistoireCreateManyArgs} args - Arguments to create many Histoires.
     * @example
     * // Create many Histoires
     * const histoire = await prisma.histoire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistoireCreateManyArgs>(args?: SelectSubset<T, HistoireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Histoires and returns the data saved in the database.
     * @param {HistoireCreateManyAndReturnArgs} args - Arguments to create many Histoires.
     * @example
     * // Create many Histoires
     * const histoire = await prisma.histoire.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Histoires and only return the `id`
     * const histoireWithIdOnly = await prisma.histoire.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HistoireCreateManyAndReturnArgs>(args?: SelectSubset<T, HistoireCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Histoire.
     * @param {HistoireDeleteArgs} args - Arguments to delete one Histoire.
     * @example
     * // Delete one Histoire
     * const Histoire = await prisma.histoire.delete({
     *   where: {
     *     // ... filter to delete one Histoire
     *   }
     * })
     * 
     */
    delete<T extends HistoireDeleteArgs>(args: SelectSubset<T, HistoireDeleteArgs<ExtArgs>>): Prisma__HistoireClient<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Histoire.
     * @param {HistoireUpdateArgs} args - Arguments to update one Histoire.
     * @example
     * // Update one Histoire
     * const histoire = await prisma.histoire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistoireUpdateArgs>(args: SelectSubset<T, HistoireUpdateArgs<ExtArgs>>): Prisma__HistoireClient<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Histoires.
     * @param {HistoireDeleteManyArgs} args - Arguments to filter Histoires to delete.
     * @example
     * // Delete a few Histoires
     * const { count } = await prisma.histoire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistoireDeleteManyArgs>(args?: SelectSubset<T, HistoireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Histoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Histoires
     * const histoire = await prisma.histoire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistoireUpdateManyArgs>(args: SelectSubset<T, HistoireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Histoire.
     * @param {HistoireUpsertArgs} args - Arguments to update or create a Histoire.
     * @example
     * // Update or create a Histoire
     * const histoire = await prisma.histoire.upsert({
     *   create: {
     *     // ... data to create a Histoire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Histoire we want to update
     *   }
     * })
     */
    upsert<T extends HistoireUpsertArgs>(args: SelectSubset<T, HistoireUpsertArgs<ExtArgs>>): Prisma__HistoireClient<$Result.GetResult<Prisma.$HistoirePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Histoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoireCountArgs} args - Arguments to filter Histoires to count.
     * @example
     * // Count the number of Histoires
     * const count = await prisma.histoire.count({
     *   where: {
     *     // ... the filter for the Histoires we want to count
     *   }
     * })
    **/
    count<T extends HistoireCountArgs>(
      args?: Subset<T, HistoireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Histoire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoireAggregateArgs>(args: Subset<T, HistoireAggregateArgs>): Prisma.PrismaPromise<GetHistoireAggregateType<T>>

    /**
     * Group by Histoire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoireGroupByArgs['orderBy'] }
        : { orderBy?: HistoireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Histoire model
   */
  readonly fields: HistoireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Histoire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistoireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barde<T extends Histoire$bardeArgs<ExtArgs> = {}>(args?: Subset<T, Histoire$bardeArgs<ExtArgs>>): Prisma__BardeClient<$Result.GetResult<Prisma.$BardePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Histoire model
   */ 
  interface HistoireFieldRefs {
    readonly id: FieldRef<"Histoire", 'Int'>
    readonly titre: FieldRef<"Histoire", 'String'>
    readonly typeEvenement: FieldRef<"Histoire", 'String'>
    readonly description: FieldRef<"Histoire", 'String'>
    readonly dateEvenement: FieldRef<"Histoire", 'DateTime'>
    readonly bardeId: FieldRef<"Histoire", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Histoire findUnique
   */
  export type HistoireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
    /**
     * Filter, which Histoire to fetch.
     */
    where: HistoireWhereUniqueInput
  }

  /**
   * Histoire findUniqueOrThrow
   */
  export type HistoireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
    /**
     * Filter, which Histoire to fetch.
     */
    where: HistoireWhereUniqueInput
  }

  /**
   * Histoire findFirst
   */
  export type HistoireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
    /**
     * Filter, which Histoire to fetch.
     */
    where?: HistoireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histoires to fetch.
     */
    orderBy?: HistoireOrderByWithRelationInput | HistoireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Histoires.
     */
    cursor?: HistoireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Histoires.
     */
    distinct?: HistoireScalarFieldEnum | HistoireScalarFieldEnum[]
  }

  /**
   * Histoire findFirstOrThrow
   */
  export type HistoireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
    /**
     * Filter, which Histoire to fetch.
     */
    where?: HistoireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histoires to fetch.
     */
    orderBy?: HistoireOrderByWithRelationInput | HistoireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Histoires.
     */
    cursor?: HistoireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Histoires.
     */
    distinct?: HistoireScalarFieldEnum | HistoireScalarFieldEnum[]
  }

  /**
   * Histoire findMany
   */
  export type HistoireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
    /**
     * Filter, which Histoires to fetch.
     */
    where?: HistoireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Histoires to fetch.
     */
    orderBy?: HistoireOrderByWithRelationInput | HistoireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Histoires.
     */
    cursor?: HistoireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Histoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Histoires.
     */
    skip?: number
    distinct?: HistoireScalarFieldEnum | HistoireScalarFieldEnum[]
  }

  /**
   * Histoire create
   */
  export type HistoireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
    /**
     * The data needed to create a Histoire.
     */
    data?: XOR<HistoireCreateInput, HistoireUncheckedCreateInput>
  }

  /**
   * Histoire createMany
   */
  export type HistoireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Histoires.
     */
    data: HistoireCreateManyInput | HistoireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Histoire createManyAndReturn
   */
  export type HistoireCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Histoires.
     */
    data: HistoireCreateManyInput | HistoireCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Histoire update
   */
  export type HistoireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
    /**
     * The data needed to update a Histoire.
     */
    data: XOR<HistoireUpdateInput, HistoireUncheckedUpdateInput>
    /**
     * Choose, which Histoire to update.
     */
    where: HistoireWhereUniqueInput
  }

  /**
   * Histoire updateMany
   */
  export type HistoireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Histoires.
     */
    data: XOR<HistoireUpdateManyMutationInput, HistoireUncheckedUpdateManyInput>
    /**
     * Filter which Histoires to update
     */
    where?: HistoireWhereInput
  }

  /**
   * Histoire upsert
   */
  export type HistoireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
    /**
     * The filter to search for the Histoire to update in case it exists.
     */
    where: HistoireWhereUniqueInput
    /**
     * In case the Histoire found by the `where` argument doesn't exist, create a new Histoire with this data.
     */
    create: XOR<HistoireCreateInput, HistoireUncheckedCreateInput>
    /**
     * In case the Histoire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistoireUpdateInput, HistoireUncheckedUpdateInput>
  }

  /**
   * Histoire delete
   */
  export type HistoireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
    /**
     * Filter which Histoire to delete.
     */
    where: HistoireWhereUniqueInput
  }

  /**
   * Histoire deleteMany
   */
  export type HistoireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Histoires to delete
     */
    where?: HistoireWhereInput
  }

  /**
   * Histoire.barde
   */
  export type Histoire$bardeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Barde
     */
    select?: BardeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BardeInclude<ExtArgs> | null
    where?: BardeWhereInput
  }

  /**
   * Histoire without action
   */
  export type HistoireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Histoire
     */
    select?: HistoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoireInclude<ExtArgs> | null
  }


  /**
   * Model Inventaire
   */

  export type AggregateInventaire = {
    _count: InventaireCountAggregateOutputType | null
    _avg: InventaireAvgAggregateOutputType | null
    _sum: InventaireSumAggregateOutputType | null
    _min: InventaireMinAggregateOutputType | null
    _max: InventaireMaxAggregateOutputType | null
  }

  export type InventaireAvgAggregateOutputType = {
    id: number | null
    stock: number | null
    seuilAlerte: number | null
    lieuId: number | null
    armeeId: number | null
    villageId: number | null
  }

  export type InventaireSumAggregateOutputType = {
    id: number | null
    stock: number | null
    seuilAlerte: number | null
    lieuId: number | null
    armeeId: number | null
    villageId: number | null
  }

  export type InventaireMinAggregateOutputType = {
    id: number | null
    typeRessource: string | null
    stock: number | null
    seuilAlerte: number | null
    dateMesure: Date | null
    lieuId: number | null
    armeeId: number | null
    villageId: number | null
  }

  export type InventaireMaxAggregateOutputType = {
    id: number | null
    typeRessource: string | null
    stock: number | null
    seuilAlerte: number | null
    dateMesure: Date | null
    lieuId: number | null
    armeeId: number | null
    villageId: number | null
  }

  export type InventaireCountAggregateOutputType = {
    id: number
    typeRessource: number
    stock: number
    seuilAlerte: number
    dateMesure: number
    lieuId: number
    armeeId: number
    villageId: number
    _all: number
  }


  export type InventaireAvgAggregateInputType = {
    id?: true
    stock?: true
    seuilAlerte?: true
    lieuId?: true
    armeeId?: true
    villageId?: true
  }

  export type InventaireSumAggregateInputType = {
    id?: true
    stock?: true
    seuilAlerte?: true
    lieuId?: true
    armeeId?: true
    villageId?: true
  }

  export type InventaireMinAggregateInputType = {
    id?: true
    typeRessource?: true
    stock?: true
    seuilAlerte?: true
    dateMesure?: true
    lieuId?: true
    armeeId?: true
    villageId?: true
  }

  export type InventaireMaxAggregateInputType = {
    id?: true
    typeRessource?: true
    stock?: true
    seuilAlerte?: true
    dateMesure?: true
    lieuId?: true
    armeeId?: true
    villageId?: true
  }

  export type InventaireCountAggregateInputType = {
    id?: true
    typeRessource?: true
    stock?: true
    seuilAlerte?: true
    dateMesure?: true
    lieuId?: true
    armeeId?: true
    villageId?: true
    _all?: true
  }

  export type InventaireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventaire to aggregate.
     */
    where?: InventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventaires to fetch.
     */
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventaires
    **/
    _count?: true | InventaireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventaireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventaireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventaireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventaireMaxAggregateInputType
  }

  export type GetInventaireAggregateType<T extends InventaireAggregateArgs> = {
        [P in keyof T & keyof AggregateInventaire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventaire[P]>
      : GetScalarType<T[P], AggregateInventaire[P]>
  }




  export type InventaireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventaireWhereInput
    orderBy?: InventaireOrderByWithAggregationInput | InventaireOrderByWithAggregationInput[]
    by: InventaireScalarFieldEnum[] | InventaireScalarFieldEnum
    having?: InventaireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventaireCountAggregateInputType | true
    _avg?: InventaireAvgAggregateInputType
    _sum?: InventaireSumAggregateInputType
    _min?: InventaireMinAggregateInputType
    _max?: InventaireMaxAggregateInputType
  }

  export type InventaireGroupByOutputType = {
    id: number
    typeRessource: string | null
    stock: number | null
    seuilAlerte: number | null
    dateMesure: Date | null
    lieuId: number | null
    armeeId: number | null
    villageId: number | null
    _count: InventaireCountAggregateOutputType | null
    _avg: InventaireAvgAggregateOutputType | null
    _sum: InventaireSumAggregateOutputType | null
    _min: InventaireMinAggregateOutputType | null
    _max: InventaireMaxAggregateOutputType | null
  }

  type GetInventaireGroupByPayload<T extends InventaireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventaireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventaireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventaireGroupByOutputType[P]>
            : GetScalarType<T[P], InventaireGroupByOutputType[P]>
        }
      >
    >


  export type InventaireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeRessource?: boolean
    stock?: boolean
    seuilAlerte?: boolean
    dateMesure?: boolean
    lieuId?: boolean
    armeeId?: boolean
    villageId?: boolean
    lieu?: boolean | Inventaire$lieuArgs<ExtArgs>
    armee?: boolean | Inventaire$armeeArgs<ExtArgs>
    Village?: boolean | Inventaire$VillageArgs<ExtArgs>
  }, ExtArgs["result"]["inventaire"]>

  export type InventaireSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeRessource?: boolean
    stock?: boolean
    seuilAlerte?: boolean
    dateMesure?: boolean
    lieuId?: boolean
    armeeId?: boolean
    villageId?: boolean
    lieu?: boolean | Inventaire$lieuArgs<ExtArgs>
    armee?: boolean | Inventaire$armeeArgs<ExtArgs>
    Village?: boolean | Inventaire$VillageArgs<ExtArgs>
  }, ExtArgs["result"]["inventaire"]>

  export type InventaireSelectScalar = {
    id?: boolean
    typeRessource?: boolean
    stock?: boolean
    seuilAlerte?: boolean
    dateMesure?: boolean
    lieuId?: boolean
    armeeId?: boolean
    villageId?: boolean
  }

  export type InventaireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lieu?: boolean | Inventaire$lieuArgs<ExtArgs>
    armee?: boolean | Inventaire$armeeArgs<ExtArgs>
    Village?: boolean | Inventaire$VillageArgs<ExtArgs>
  }
  export type InventaireIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lieu?: boolean | Inventaire$lieuArgs<ExtArgs>
    armee?: boolean | Inventaire$armeeArgs<ExtArgs>
    Village?: boolean | Inventaire$VillageArgs<ExtArgs>
  }

  export type $InventairePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventaire"
    objects: {
      lieu: Prisma.$LieuPayload<ExtArgs> | null
      armee: Prisma.$ArmeePayload<ExtArgs> | null
      Village: Prisma.$VillagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      typeRessource: string | null
      stock: number | null
      seuilAlerte: number | null
      dateMesure: Date | null
      lieuId: number | null
      armeeId: number | null
      villageId: number | null
    }, ExtArgs["result"]["inventaire"]>
    composites: {}
  }

  type InventaireGetPayload<S extends boolean | null | undefined | InventaireDefaultArgs> = $Result.GetResult<Prisma.$InventairePayload, S>

  type InventaireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventaireFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventaireCountAggregateInputType | true
    }

  export interface InventaireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventaire'], meta: { name: 'Inventaire' } }
    /**
     * Find zero or one Inventaire that matches the filter.
     * @param {InventaireFindUniqueArgs} args - Arguments to find a Inventaire
     * @example
     * // Get one Inventaire
     * const inventaire = await prisma.inventaire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventaireFindUniqueArgs>(args: SelectSubset<T, InventaireFindUniqueArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inventaire that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventaireFindUniqueOrThrowArgs} args - Arguments to find a Inventaire
     * @example
     * // Get one Inventaire
     * const inventaire = await prisma.inventaire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventaireFindUniqueOrThrowArgs>(args: SelectSubset<T, InventaireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inventaire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireFindFirstArgs} args - Arguments to find a Inventaire
     * @example
     * // Get one Inventaire
     * const inventaire = await prisma.inventaire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventaireFindFirstArgs>(args?: SelectSubset<T, InventaireFindFirstArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inventaire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireFindFirstOrThrowArgs} args - Arguments to find a Inventaire
     * @example
     * // Get one Inventaire
     * const inventaire = await prisma.inventaire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventaireFindFirstOrThrowArgs>(args?: SelectSubset<T, InventaireFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inventaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventaires
     * const inventaires = await prisma.inventaire.findMany()
     * 
     * // Get first 10 Inventaires
     * const inventaires = await prisma.inventaire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventaireWithIdOnly = await prisma.inventaire.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventaireFindManyArgs>(args?: SelectSubset<T, InventaireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inventaire.
     * @param {InventaireCreateArgs} args - Arguments to create a Inventaire.
     * @example
     * // Create one Inventaire
     * const Inventaire = await prisma.inventaire.create({
     *   data: {
     *     // ... data to create a Inventaire
     *   }
     * })
     * 
     */
    create<T extends InventaireCreateArgs>(args: SelectSubset<T, InventaireCreateArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inventaires.
     * @param {InventaireCreateManyArgs} args - Arguments to create many Inventaires.
     * @example
     * // Create many Inventaires
     * const inventaire = await prisma.inventaire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventaireCreateManyArgs>(args?: SelectSubset<T, InventaireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventaires and returns the data saved in the database.
     * @param {InventaireCreateManyAndReturnArgs} args - Arguments to create many Inventaires.
     * @example
     * // Create many Inventaires
     * const inventaire = await prisma.inventaire.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventaires and only return the `id`
     * const inventaireWithIdOnly = await prisma.inventaire.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventaireCreateManyAndReturnArgs>(args?: SelectSubset<T, InventaireCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inventaire.
     * @param {InventaireDeleteArgs} args - Arguments to delete one Inventaire.
     * @example
     * // Delete one Inventaire
     * const Inventaire = await prisma.inventaire.delete({
     *   where: {
     *     // ... filter to delete one Inventaire
     *   }
     * })
     * 
     */
    delete<T extends InventaireDeleteArgs>(args: SelectSubset<T, InventaireDeleteArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inventaire.
     * @param {InventaireUpdateArgs} args - Arguments to update one Inventaire.
     * @example
     * // Update one Inventaire
     * const inventaire = await prisma.inventaire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventaireUpdateArgs>(args: SelectSubset<T, InventaireUpdateArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inventaires.
     * @param {InventaireDeleteManyArgs} args - Arguments to filter Inventaires to delete.
     * @example
     * // Delete a few Inventaires
     * const { count } = await prisma.inventaire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventaireDeleteManyArgs>(args?: SelectSubset<T, InventaireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventaires
     * const inventaire = await prisma.inventaire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventaireUpdateManyArgs>(args: SelectSubset<T, InventaireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventaire.
     * @param {InventaireUpsertArgs} args - Arguments to update or create a Inventaire.
     * @example
     * // Update or create a Inventaire
     * const inventaire = await prisma.inventaire.upsert({
     *   create: {
     *     // ... data to create a Inventaire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventaire we want to update
     *   }
     * })
     */
    upsert<T extends InventaireUpsertArgs>(args: SelectSubset<T, InventaireUpsertArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inventaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireCountArgs} args - Arguments to filter Inventaires to count.
     * @example
     * // Count the number of Inventaires
     * const count = await prisma.inventaire.count({
     *   where: {
     *     // ... the filter for the Inventaires we want to count
     *   }
     * })
    **/
    count<T extends InventaireCountArgs>(
      args?: Subset<T, InventaireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventaireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventaireAggregateArgs>(args: Subset<T, InventaireAggregateArgs>): Prisma.PrismaPromise<GetInventaireAggregateType<T>>

    /**
     * Group by Inventaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventaireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventaireGroupByArgs['orderBy'] }
        : { orderBy?: InventaireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventaireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventaireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventaire model
   */
  readonly fields: InventaireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventaire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventaireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lieu<T extends Inventaire$lieuArgs<ExtArgs> = {}>(args?: Subset<T, Inventaire$lieuArgs<ExtArgs>>): Prisma__LieuClient<$Result.GetResult<Prisma.$LieuPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    armee<T extends Inventaire$armeeArgs<ExtArgs> = {}>(args?: Subset<T, Inventaire$armeeArgs<ExtArgs>>): Prisma__ArmeeClient<$Result.GetResult<Prisma.$ArmeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Village<T extends Inventaire$VillageArgs<ExtArgs> = {}>(args?: Subset<T, Inventaire$VillageArgs<ExtArgs>>): Prisma__VillageClient<$Result.GetResult<Prisma.$VillagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventaire model
   */ 
  interface InventaireFieldRefs {
    readonly id: FieldRef<"Inventaire", 'Int'>
    readonly typeRessource: FieldRef<"Inventaire", 'String'>
    readonly stock: FieldRef<"Inventaire", 'Int'>
    readonly seuilAlerte: FieldRef<"Inventaire", 'Int'>
    readonly dateMesure: FieldRef<"Inventaire", 'DateTime'>
    readonly lieuId: FieldRef<"Inventaire", 'Int'>
    readonly armeeId: FieldRef<"Inventaire", 'Int'>
    readonly villageId: FieldRef<"Inventaire", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Inventaire findUnique
   */
  export type InventaireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter, which Inventaire to fetch.
     */
    where: InventaireWhereUniqueInput
  }

  /**
   * Inventaire findUniqueOrThrow
   */
  export type InventaireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter, which Inventaire to fetch.
     */
    where: InventaireWhereUniqueInput
  }

  /**
   * Inventaire findFirst
   */
  export type InventaireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter, which Inventaire to fetch.
     */
    where?: InventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventaires to fetch.
     */
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventaires.
     */
    cursor?: InventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventaires.
     */
    distinct?: InventaireScalarFieldEnum | InventaireScalarFieldEnum[]
  }

  /**
   * Inventaire findFirstOrThrow
   */
  export type InventaireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter, which Inventaire to fetch.
     */
    where?: InventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventaires to fetch.
     */
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventaires.
     */
    cursor?: InventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventaires.
     */
    distinct?: InventaireScalarFieldEnum | InventaireScalarFieldEnum[]
  }

  /**
   * Inventaire findMany
   */
  export type InventaireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter, which Inventaires to fetch.
     */
    where?: InventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventaires to fetch.
     */
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventaires.
     */
    cursor?: InventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventaires.
     */
    skip?: number
    distinct?: InventaireScalarFieldEnum | InventaireScalarFieldEnum[]
  }

  /**
   * Inventaire create
   */
  export type InventaireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventaire.
     */
    data?: XOR<InventaireCreateInput, InventaireUncheckedCreateInput>
  }

  /**
   * Inventaire createMany
   */
  export type InventaireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventaires.
     */
    data: InventaireCreateManyInput | InventaireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventaire createManyAndReturn
   */
  export type InventaireCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Inventaires.
     */
    data: InventaireCreateManyInput | InventaireCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventaire update
   */
  export type InventaireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventaire.
     */
    data: XOR<InventaireUpdateInput, InventaireUncheckedUpdateInput>
    /**
     * Choose, which Inventaire to update.
     */
    where: InventaireWhereUniqueInput
  }

  /**
   * Inventaire updateMany
   */
  export type InventaireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventaires.
     */
    data: XOR<InventaireUpdateManyMutationInput, InventaireUncheckedUpdateManyInput>
    /**
     * Filter which Inventaires to update
     */
    where?: InventaireWhereInput
  }

  /**
   * Inventaire upsert
   */
  export type InventaireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventaire to update in case it exists.
     */
    where: InventaireWhereUniqueInput
    /**
     * In case the Inventaire found by the `where` argument doesn't exist, create a new Inventaire with this data.
     */
    create: XOR<InventaireCreateInput, InventaireUncheckedCreateInput>
    /**
     * In case the Inventaire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventaireUpdateInput, InventaireUncheckedUpdateInput>
  }

  /**
   * Inventaire delete
   */
  export type InventaireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter which Inventaire to delete.
     */
    where: InventaireWhereUniqueInput
  }

  /**
   * Inventaire deleteMany
   */
  export type InventaireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventaires to delete
     */
    where?: InventaireWhereInput
  }

  /**
   * Inventaire.lieu
   */
  export type Inventaire$lieuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lieu
     */
    select?: LieuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LieuInclude<ExtArgs> | null
    where?: LieuWhereInput
  }

  /**
   * Inventaire.armee
   */
  export type Inventaire$armeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Armee
     */
    select?: ArmeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArmeeInclude<ExtArgs> | null
    where?: ArmeeWhereInput
  }

  /**
   * Inventaire.Village
   */
  export type Inventaire$VillageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Village
     */
    select?: VillageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VillageInclude<ExtArgs> | null
    where?: VillageWhereInput
  }

  /**
   * Inventaire without action
   */
  export type InventaireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
  }


  /**
   * Model RelationDiplomatique
   */

  export type AggregateRelationDiplomatique = {
    _count: RelationDiplomatiqueCountAggregateOutputType | null
    _avg: RelationDiplomatiqueAvgAggregateOutputType | null
    _sum: RelationDiplomatiqueSumAggregateOutputType | null
    _min: RelationDiplomatiqueMinAggregateOutputType | null
    _max: RelationDiplomatiqueMaxAggregateOutputType | null
  }

  export type RelationDiplomatiqueAvgAggregateOutputType = {
    id: number | null
    domaineSourceId: number | null
    domaineCibleId: number | null
  }

  export type RelationDiplomatiqueSumAggregateOutputType = {
    id: number | null
    domaineSourceId: number | null
    domaineCibleId: number | null
  }

  export type RelationDiplomatiqueMinAggregateOutputType = {
    id: number | null
    typeRelation: string | null
    conditions: string | null
    dateSignature: Date | null
    echeance: string | null
    domaineSourceId: number | null
    domaineCibleId: number | null
  }

  export type RelationDiplomatiqueMaxAggregateOutputType = {
    id: number | null
    typeRelation: string | null
    conditions: string | null
    dateSignature: Date | null
    echeance: string | null
    domaineSourceId: number | null
    domaineCibleId: number | null
  }

  export type RelationDiplomatiqueCountAggregateOutputType = {
    id: number
    typeRelation: number
    conditions: number
    dateSignature: number
    echeance: number
    domaineSourceId: number
    domaineCibleId: number
    _all: number
  }


  export type RelationDiplomatiqueAvgAggregateInputType = {
    id?: true
    domaineSourceId?: true
    domaineCibleId?: true
  }

  export type RelationDiplomatiqueSumAggregateInputType = {
    id?: true
    domaineSourceId?: true
    domaineCibleId?: true
  }

  export type RelationDiplomatiqueMinAggregateInputType = {
    id?: true
    typeRelation?: true
    conditions?: true
    dateSignature?: true
    echeance?: true
    domaineSourceId?: true
    domaineCibleId?: true
  }

  export type RelationDiplomatiqueMaxAggregateInputType = {
    id?: true
    typeRelation?: true
    conditions?: true
    dateSignature?: true
    echeance?: true
    domaineSourceId?: true
    domaineCibleId?: true
  }

  export type RelationDiplomatiqueCountAggregateInputType = {
    id?: true
    typeRelation?: true
    conditions?: true
    dateSignature?: true
    echeance?: true
    domaineSourceId?: true
    domaineCibleId?: true
    _all?: true
  }

  export type RelationDiplomatiqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelationDiplomatique to aggregate.
     */
    where?: RelationDiplomatiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationDiplomatiques to fetch.
     */
    orderBy?: RelationDiplomatiqueOrderByWithRelationInput | RelationDiplomatiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelationDiplomatiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationDiplomatiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationDiplomatiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelationDiplomatiques
    **/
    _count?: true | RelationDiplomatiqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelationDiplomatiqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelationDiplomatiqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationDiplomatiqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationDiplomatiqueMaxAggregateInputType
  }

  export type GetRelationDiplomatiqueAggregateType<T extends RelationDiplomatiqueAggregateArgs> = {
        [P in keyof T & keyof AggregateRelationDiplomatique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelationDiplomatique[P]>
      : GetScalarType<T[P], AggregateRelationDiplomatique[P]>
  }




  export type RelationDiplomatiqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationDiplomatiqueWhereInput
    orderBy?: RelationDiplomatiqueOrderByWithAggregationInput | RelationDiplomatiqueOrderByWithAggregationInput[]
    by: RelationDiplomatiqueScalarFieldEnum[] | RelationDiplomatiqueScalarFieldEnum
    having?: RelationDiplomatiqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationDiplomatiqueCountAggregateInputType | true
    _avg?: RelationDiplomatiqueAvgAggregateInputType
    _sum?: RelationDiplomatiqueSumAggregateInputType
    _min?: RelationDiplomatiqueMinAggregateInputType
    _max?: RelationDiplomatiqueMaxAggregateInputType
  }

  export type RelationDiplomatiqueGroupByOutputType = {
    id: number
    typeRelation: string | null
    conditions: string | null
    dateSignature: Date | null
    echeance: string | null
    domaineSourceId: number
    domaineCibleId: number
    _count: RelationDiplomatiqueCountAggregateOutputType | null
    _avg: RelationDiplomatiqueAvgAggregateOutputType | null
    _sum: RelationDiplomatiqueSumAggregateOutputType | null
    _min: RelationDiplomatiqueMinAggregateOutputType | null
    _max: RelationDiplomatiqueMaxAggregateOutputType | null
  }

  type GetRelationDiplomatiqueGroupByPayload<T extends RelationDiplomatiqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationDiplomatiqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationDiplomatiqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationDiplomatiqueGroupByOutputType[P]>
            : GetScalarType<T[P], RelationDiplomatiqueGroupByOutputType[P]>
        }
      >
    >


  export type RelationDiplomatiqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeRelation?: boolean
    conditions?: boolean
    dateSignature?: boolean
    echeance?: boolean
    domaineSourceId?: boolean
    domaineCibleId?: boolean
    domaineSource?: boolean | DomaineDefaultArgs<ExtArgs>
    domaineCible?: boolean | DomaineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relationDiplomatique"]>

  export type RelationDiplomatiqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeRelation?: boolean
    conditions?: boolean
    dateSignature?: boolean
    echeance?: boolean
    domaineSourceId?: boolean
    domaineCibleId?: boolean
    domaineSource?: boolean | DomaineDefaultArgs<ExtArgs>
    domaineCible?: boolean | DomaineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relationDiplomatique"]>

  export type RelationDiplomatiqueSelectScalar = {
    id?: boolean
    typeRelation?: boolean
    conditions?: boolean
    dateSignature?: boolean
    echeance?: boolean
    domaineSourceId?: boolean
    domaineCibleId?: boolean
  }

  export type RelationDiplomatiqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domaineSource?: boolean | DomaineDefaultArgs<ExtArgs>
    domaineCible?: boolean | DomaineDefaultArgs<ExtArgs>
  }
  export type RelationDiplomatiqueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domaineSource?: boolean | DomaineDefaultArgs<ExtArgs>
    domaineCible?: boolean | DomaineDefaultArgs<ExtArgs>
  }

  export type $RelationDiplomatiquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelationDiplomatique"
    objects: {
      domaineSource: Prisma.$DomainePayload<ExtArgs>
      domaineCible: Prisma.$DomainePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      typeRelation: string | null
      conditions: string | null
      dateSignature: Date | null
      echeance: string | null
      domaineSourceId: number
      domaineCibleId: number
    }, ExtArgs["result"]["relationDiplomatique"]>
    composites: {}
  }

  type RelationDiplomatiqueGetPayload<S extends boolean | null | undefined | RelationDiplomatiqueDefaultArgs> = $Result.GetResult<Prisma.$RelationDiplomatiquePayload, S>

  type RelationDiplomatiqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelationDiplomatiqueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelationDiplomatiqueCountAggregateInputType | true
    }

  export interface RelationDiplomatiqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelationDiplomatique'], meta: { name: 'RelationDiplomatique' } }
    /**
     * Find zero or one RelationDiplomatique that matches the filter.
     * @param {RelationDiplomatiqueFindUniqueArgs} args - Arguments to find a RelationDiplomatique
     * @example
     * // Get one RelationDiplomatique
     * const relationDiplomatique = await prisma.relationDiplomatique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelationDiplomatiqueFindUniqueArgs>(args: SelectSubset<T, RelationDiplomatiqueFindUniqueArgs<ExtArgs>>): Prisma__RelationDiplomatiqueClient<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RelationDiplomatique that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RelationDiplomatiqueFindUniqueOrThrowArgs} args - Arguments to find a RelationDiplomatique
     * @example
     * // Get one RelationDiplomatique
     * const relationDiplomatique = await prisma.relationDiplomatique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelationDiplomatiqueFindUniqueOrThrowArgs>(args: SelectSubset<T, RelationDiplomatiqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelationDiplomatiqueClient<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RelationDiplomatique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationDiplomatiqueFindFirstArgs} args - Arguments to find a RelationDiplomatique
     * @example
     * // Get one RelationDiplomatique
     * const relationDiplomatique = await prisma.relationDiplomatique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelationDiplomatiqueFindFirstArgs>(args?: SelectSubset<T, RelationDiplomatiqueFindFirstArgs<ExtArgs>>): Prisma__RelationDiplomatiqueClient<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RelationDiplomatique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationDiplomatiqueFindFirstOrThrowArgs} args - Arguments to find a RelationDiplomatique
     * @example
     * // Get one RelationDiplomatique
     * const relationDiplomatique = await prisma.relationDiplomatique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelationDiplomatiqueFindFirstOrThrowArgs>(args?: SelectSubset<T, RelationDiplomatiqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelationDiplomatiqueClient<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RelationDiplomatiques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationDiplomatiqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelationDiplomatiques
     * const relationDiplomatiques = await prisma.relationDiplomatique.findMany()
     * 
     * // Get first 10 RelationDiplomatiques
     * const relationDiplomatiques = await prisma.relationDiplomatique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relationDiplomatiqueWithIdOnly = await prisma.relationDiplomatique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelationDiplomatiqueFindManyArgs>(args?: SelectSubset<T, RelationDiplomatiqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RelationDiplomatique.
     * @param {RelationDiplomatiqueCreateArgs} args - Arguments to create a RelationDiplomatique.
     * @example
     * // Create one RelationDiplomatique
     * const RelationDiplomatique = await prisma.relationDiplomatique.create({
     *   data: {
     *     // ... data to create a RelationDiplomatique
     *   }
     * })
     * 
     */
    create<T extends RelationDiplomatiqueCreateArgs>(args: SelectSubset<T, RelationDiplomatiqueCreateArgs<ExtArgs>>): Prisma__RelationDiplomatiqueClient<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RelationDiplomatiques.
     * @param {RelationDiplomatiqueCreateManyArgs} args - Arguments to create many RelationDiplomatiques.
     * @example
     * // Create many RelationDiplomatiques
     * const relationDiplomatique = await prisma.relationDiplomatique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelationDiplomatiqueCreateManyArgs>(args?: SelectSubset<T, RelationDiplomatiqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelationDiplomatiques and returns the data saved in the database.
     * @param {RelationDiplomatiqueCreateManyAndReturnArgs} args - Arguments to create many RelationDiplomatiques.
     * @example
     * // Create many RelationDiplomatiques
     * const relationDiplomatique = await prisma.relationDiplomatique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelationDiplomatiques and only return the `id`
     * const relationDiplomatiqueWithIdOnly = await prisma.relationDiplomatique.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelationDiplomatiqueCreateManyAndReturnArgs>(args?: SelectSubset<T, RelationDiplomatiqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RelationDiplomatique.
     * @param {RelationDiplomatiqueDeleteArgs} args - Arguments to delete one RelationDiplomatique.
     * @example
     * // Delete one RelationDiplomatique
     * const RelationDiplomatique = await prisma.relationDiplomatique.delete({
     *   where: {
     *     // ... filter to delete one RelationDiplomatique
     *   }
     * })
     * 
     */
    delete<T extends RelationDiplomatiqueDeleteArgs>(args: SelectSubset<T, RelationDiplomatiqueDeleteArgs<ExtArgs>>): Prisma__RelationDiplomatiqueClient<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RelationDiplomatique.
     * @param {RelationDiplomatiqueUpdateArgs} args - Arguments to update one RelationDiplomatique.
     * @example
     * // Update one RelationDiplomatique
     * const relationDiplomatique = await prisma.relationDiplomatique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelationDiplomatiqueUpdateArgs>(args: SelectSubset<T, RelationDiplomatiqueUpdateArgs<ExtArgs>>): Prisma__RelationDiplomatiqueClient<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RelationDiplomatiques.
     * @param {RelationDiplomatiqueDeleteManyArgs} args - Arguments to filter RelationDiplomatiques to delete.
     * @example
     * // Delete a few RelationDiplomatiques
     * const { count } = await prisma.relationDiplomatique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelationDiplomatiqueDeleteManyArgs>(args?: SelectSubset<T, RelationDiplomatiqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelationDiplomatiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationDiplomatiqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelationDiplomatiques
     * const relationDiplomatique = await prisma.relationDiplomatique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelationDiplomatiqueUpdateManyArgs>(args: SelectSubset<T, RelationDiplomatiqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RelationDiplomatique.
     * @param {RelationDiplomatiqueUpsertArgs} args - Arguments to update or create a RelationDiplomatique.
     * @example
     * // Update or create a RelationDiplomatique
     * const relationDiplomatique = await prisma.relationDiplomatique.upsert({
     *   create: {
     *     // ... data to create a RelationDiplomatique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelationDiplomatique we want to update
     *   }
     * })
     */
    upsert<T extends RelationDiplomatiqueUpsertArgs>(args: SelectSubset<T, RelationDiplomatiqueUpsertArgs<ExtArgs>>): Prisma__RelationDiplomatiqueClient<$Result.GetResult<Prisma.$RelationDiplomatiquePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RelationDiplomatiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationDiplomatiqueCountArgs} args - Arguments to filter RelationDiplomatiques to count.
     * @example
     * // Count the number of RelationDiplomatiques
     * const count = await prisma.relationDiplomatique.count({
     *   where: {
     *     // ... the filter for the RelationDiplomatiques we want to count
     *   }
     * })
    **/
    count<T extends RelationDiplomatiqueCountArgs>(
      args?: Subset<T, RelationDiplomatiqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationDiplomatiqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelationDiplomatique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationDiplomatiqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationDiplomatiqueAggregateArgs>(args: Subset<T, RelationDiplomatiqueAggregateArgs>): Prisma.PrismaPromise<GetRelationDiplomatiqueAggregateType<T>>

    /**
     * Group by RelationDiplomatique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationDiplomatiqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelationDiplomatiqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelationDiplomatiqueGroupByArgs['orderBy'] }
        : { orderBy?: RelationDiplomatiqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelationDiplomatiqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationDiplomatiqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelationDiplomatique model
   */
  readonly fields: RelationDiplomatiqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelationDiplomatique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelationDiplomatiqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domaineSource<T extends DomaineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomaineDefaultArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    domaineCible<T extends DomaineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomaineDefaultArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelationDiplomatique model
   */ 
  interface RelationDiplomatiqueFieldRefs {
    readonly id: FieldRef<"RelationDiplomatique", 'Int'>
    readonly typeRelation: FieldRef<"RelationDiplomatique", 'String'>
    readonly conditions: FieldRef<"RelationDiplomatique", 'String'>
    readonly dateSignature: FieldRef<"RelationDiplomatique", 'DateTime'>
    readonly echeance: FieldRef<"RelationDiplomatique", 'String'>
    readonly domaineSourceId: FieldRef<"RelationDiplomatique", 'Int'>
    readonly domaineCibleId: FieldRef<"RelationDiplomatique", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RelationDiplomatique findUnique
   */
  export type RelationDiplomatiqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    /**
     * Filter, which RelationDiplomatique to fetch.
     */
    where: RelationDiplomatiqueWhereUniqueInput
  }

  /**
   * RelationDiplomatique findUniqueOrThrow
   */
  export type RelationDiplomatiqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    /**
     * Filter, which RelationDiplomatique to fetch.
     */
    where: RelationDiplomatiqueWhereUniqueInput
  }

  /**
   * RelationDiplomatique findFirst
   */
  export type RelationDiplomatiqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    /**
     * Filter, which RelationDiplomatique to fetch.
     */
    where?: RelationDiplomatiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationDiplomatiques to fetch.
     */
    orderBy?: RelationDiplomatiqueOrderByWithRelationInput | RelationDiplomatiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelationDiplomatiques.
     */
    cursor?: RelationDiplomatiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationDiplomatiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationDiplomatiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelationDiplomatiques.
     */
    distinct?: RelationDiplomatiqueScalarFieldEnum | RelationDiplomatiqueScalarFieldEnum[]
  }

  /**
   * RelationDiplomatique findFirstOrThrow
   */
  export type RelationDiplomatiqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    /**
     * Filter, which RelationDiplomatique to fetch.
     */
    where?: RelationDiplomatiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationDiplomatiques to fetch.
     */
    orderBy?: RelationDiplomatiqueOrderByWithRelationInput | RelationDiplomatiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelationDiplomatiques.
     */
    cursor?: RelationDiplomatiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationDiplomatiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationDiplomatiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelationDiplomatiques.
     */
    distinct?: RelationDiplomatiqueScalarFieldEnum | RelationDiplomatiqueScalarFieldEnum[]
  }

  /**
   * RelationDiplomatique findMany
   */
  export type RelationDiplomatiqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    /**
     * Filter, which RelationDiplomatiques to fetch.
     */
    where?: RelationDiplomatiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationDiplomatiques to fetch.
     */
    orderBy?: RelationDiplomatiqueOrderByWithRelationInput | RelationDiplomatiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelationDiplomatiques.
     */
    cursor?: RelationDiplomatiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationDiplomatiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationDiplomatiques.
     */
    skip?: number
    distinct?: RelationDiplomatiqueScalarFieldEnum | RelationDiplomatiqueScalarFieldEnum[]
  }

  /**
   * RelationDiplomatique create
   */
  export type RelationDiplomatiqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    /**
     * The data needed to create a RelationDiplomatique.
     */
    data: XOR<RelationDiplomatiqueCreateInput, RelationDiplomatiqueUncheckedCreateInput>
  }

  /**
   * RelationDiplomatique createMany
   */
  export type RelationDiplomatiqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelationDiplomatiques.
     */
    data: RelationDiplomatiqueCreateManyInput | RelationDiplomatiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelationDiplomatique createManyAndReturn
   */
  export type RelationDiplomatiqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RelationDiplomatiques.
     */
    data: RelationDiplomatiqueCreateManyInput | RelationDiplomatiqueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RelationDiplomatique update
   */
  export type RelationDiplomatiqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    /**
     * The data needed to update a RelationDiplomatique.
     */
    data: XOR<RelationDiplomatiqueUpdateInput, RelationDiplomatiqueUncheckedUpdateInput>
    /**
     * Choose, which RelationDiplomatique to update.
     */
    where: RelationDiplomatiqueWhereUniqueInput
  }

  /**
   * RelationDiplomatique updateMany
   */
  export type RelationDiplomatiqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelationDiplomatiques.
     */
    data: XOR<RelationDiplomatiqueUpdateManyMutationInput, RelationDiplomatiqueUncheckedUpdateManyInput>
    /**
     * Filter which RelationDiplomatiques to update
     */
    where?: RelationDiplomatiqueWhereInput
  }

  /**
   * RelationDiplomatique upsert
   */
  export type RelationDiplomatiqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    /**
     * The filter to search for the RelationDiplomatique to update in case it exists.
     */
    where: RelationDiplomatiqueWhereUniqueInput
    /**
     * In case the RelationDiplomatique found by the `where` argument doesn't exist, create a new RelationDiplomatique with this data.
     */
    create: XOR<RelationDiplomatiqueCreateInput, RelationDiplomatiqueUncheckedCreateInput>
    /**
     * In case the RelationDiplomatique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelationDiplomatiqueUpdateInput, RelationDiplomatiqueUncheckedUpdateInput>
  }

  /**
   * RelationDiplomatique delete
   */
  export type RelationDiplomatiqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
    /**
     * Filter which RelationDiplomatique to delete.
     */
    where: RelationDiplomatiqueWhereUniqueInput
  }

  /**
   * RelationDiplomatique deleteMany
   */
  export type RelationDiplomatiqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelationDiplomatiques to delete
     */
    where?: RelationDiplomatiqueWhereInput
  }

  /**
   * RelationDiplomatique without action
   */
  export type RelationDiplomatiqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationDiplomatique
     */
    select?: RelationDiplomatiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationDiplomatiqueInclude<ExtArgs> | null
  }


  /**
   * Model Loi
   */

  export type AggregateLoi = {
    _count: LoiCountAggregateOutputType | null
    _avg: LoiAvgAggregateOutputType | null
    _sum: LoiSumAggregateOutputType | null
    _min: LoiMinAggregateOutputType | null
    _max: LoiMaxAggregateOutputType | null
  }

  export type LoiAvgAggregateOutputType = {
    id: number | null
  }

  export type LoiSumAggregateOutputType = {
    id: number | null
  }

  export type LoiMinAggregateOutputType = {
    id: number | null
    libelle: string | null
    effet: string | null
  }

  export type LoiMaxAggregateOutputType = {
    id: number | null
    libelle: string | null
    effet: string | null
  }

  export type LoiCountAggregateOutputType = {
    id: number
    libelle: number
    effet: number
    _all: number
  }


  export type LoiAvgAggregateInputType = {
    id?: true
  }

  export type LoiSumAggregateInputType = {
    id?: true
  }

  export type LoiMinAggregateInputType = {
    id?: true
    libelle?: true
    effet?: true
  }

  export type LoiMaxAggregateInputType = {
    id?: true
    libelle?: true
    effet?: true
  }

  export type LoiCountAggregateInputType = {
    id?: true
    libelle?: true
    effet?: true
    _all?: true
  }

  export type LoiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loi to aggregate.
     */
    where?: LoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lois to fetch.
     */
    orderBy?: LoiOrderByWithRelationInput | LoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lois
    **/
    _count?: true | LoiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoiMaxAggregateInputType
  }

  export type GetLoiAggregateType<T extends LoiAggregateArgs> = {
        [P in keyof T & keyof AggregateLoi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoi[P]>
      : GetScalarType<T[P], AggregateLoi[P]>
  }




  export type LoiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoiWhereInput
    orderBy?: LoiOrderByWithAggregationInput | LoiOrderByWithAggregationInput[]
    by: LoiScalarFieldEnum[] | LoiScalarFieldEnum
    having?: LoiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoiCountAggregateInputType | true
    _avg?: LoiAvgAggregateInputType
    _sum?: LoiSumAggregateInputType
    _min?: LoiMinAggregateInputType
    _max?: LoiMaxAggregateInputType
  }

  export type LoiGroupByOutputType = {
    id: number
    libelle: string
    effet: string | null
    _count: LoiCountAggregateOutputType | null
    _avg: LoiAvgAggregateOutputType | null
    _sum: LoiSumAggregateOutputType | null
    _min: LoiMinAggregateOutputType | null
    _max: LoiMaxAggregateOutputType | null
  }

  type GetLoiGroupByPayload<T extends LoiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoiGroupByOutputType[P]>
            : GetScalarType<T[P], LoiGroupByOutputType[P]>
        }
      >
    >


  export type LoiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    effet?: boolean
    domaines?: boolean | Loi$domainesArgs<ExtArgs>
    _count?: boolean | LoiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loi"]>

  export type LoiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    effet?: boolean
  }, ExtArgs["result"]["loi"]>

  export type LoiSelectScalar = {
    id?: boolean
    libelle?: boolean
    effet?: boolean
  }

  export type LoiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domaines?: boolean | Loi$domainesArgs<ExtArgs>
    _count?: boolean | LoiCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LoiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Loi"
    objects: {
      domaines: Prisma.$LoiTerritoirePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      libelle: string
      effet: string | null
    }, ExtArgs["result"]["loi"]>
    composites: {}
  }

  type LoiGetPayload<S extends boolean | null | undefined | LoiDefaultArgs> = $Result.GetResult<Prisma.$LoiPayload, S>

  type LoiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoiCountAggregateInputType | true
    }

  export interface LoiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Loi'], meta: { name: 'Loi' } }
    /**
     * Find zero or one Loi that matches the filter.
     * @param {LoiFindUniqueArgs} args - Arguments to find a Loi
     * @example
     * // Get one Loi
     * const loi = await prisma.loi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoiFindUniqueArgs>(args: SelectSubset<T, LoiFindUniqueArgs<ExtArgs>>): Prisma__LoiClient<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Loi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoiFindUniqueOrThrowArgs} args - Arguments to find a Loi
     * @example
     * // Get one Loi
     * const loi = await prisma.loi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoiFindUniqueOrThrowArgs>(args: SelectSubset<T, LoiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoiClient<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Loi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiFindFirstArgs} args - Arguments to find a Loi
     * @example
     * // Get one Loi
     * const loi = await prisma.loi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoiFindFirstArgs>(args?: SelectSubset<T, LoiFindFirstArgs<ExtArgs>>): Prisma__LoiClient<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Loi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiFindFirstOrThrowArgs} args - Arguments to find a Loi
     * @example
     * // Get one Loi
     * const loi = await prisma.loi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoiFindFirstOrThrowArgs>(args?: SelectSubset<T, LoiFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoiClient<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lois
     * const lois = await prisma.loi.findMany()
     * 
     * // Get first 10 Lois
     * const lois = await prisma.loi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loiWithIdOnly = await prisma.loi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoiFindManyArgs>(args?: SelectSubset<T, LoiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Loi.
     * @param {LoiCreateArgs} args - Arguments to create a Loi.
     * @example
     * // Create one Loi
     * const Loi = await prisma.loi.create({
     *   data: {
     *     // ... data to create a Loi
     *   }
     * })
     * 
     */
    create<T extends LoiCreateArgs>(args: SelectSubset<T, LoiCreateArgs<ExtArgs>>): Prisma__LoiClient<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lois.
     * @param {LoiCreateManyArgs} args - Arguments to create many Lois.
     * @example
     * // Create many Lois
     * const loi = await prisma.loi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoiCreateManyArgs>(args?: SelectSubset<T, LoiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lois and returns the data saved in the database.
     * @param {LoiCreateManyAndReturnArgs} args - Arguments to create many Lois.
     * @example
     * // Create many Lois
     * const loi = await prisma.loi.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lois and only return the `id`
     * const loiWithIdOnly = await prisma.loi.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoiCreateManyAndReturnArgs>(args?: SelectSubset<T, LoiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Loi.
     * @param {LoiDeleteArgs} args - Arguments to delete one Loi.
     * @example
     * // Delete one Loi
     * const Loi = await prisma.loi.delete({
     *   where: {
     *     // ... filter to delete one Loi
     *   }
     * })
     * 
     */
    delete<T extends LoiDeleteArgs>(args: SelectSubset<T, LoiDeleteArgs<ExtArgs>>): Prisma__LoiClient<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Loi.
     * @param {LoiUpdateArgs} args - Arguments to update one Loi.
     * @example
     * // Update one Loi
     * const loi = await prisma.loi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoiUpdateArgs>(args: SelectSubset<T, LoiUpdateArgs<ExtArgs>>): Prisma__LoiClient<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lois.
     * @param {LoiDeleteManyArgs} args - Arguments to filter Lois to delete.
     * @example
     * // Delete a few Lois
     * const { count } = await prisma.loi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoiDeleteManyArgs>(args?: SelectSubset<T, LoiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lois
     * const loi = await prisma.loi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoiUpdateManyArgs>(args: SelectSubset<T, LoiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Loi.
     * @param {LoiUpsertArgs} args - Arguments to update or create a Loi.
     * @example
     * // Update or create a Loi
     * const loi = await prisma.loi.upsert({
     *   create: {
     *     // ... data to create a Loi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loi we want to update
     *   }
     * })
     */
    upsert<T extends LoiUpsertArgs>(args: SelectSubset<T, LoiUpsertArgs<ExtArgs>>): Prisma__LoiClient<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiCountArgs} args - Arguments to filter Lois to count.
     * @example
     * // Count the number of Lois
     * const count = await prisma.loi.count({
     *   where: {
     *     // ... the filter for the Lois we want to count
     *   }
     * })
    **/
    count<T extends LoiCountArgs>(
      args?: Subset<T, LoiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoiAggregateArgs>(args: Subset<T, LoiAggregateArgs>): Prisma.PrismaPromise<GetLoiAggregateType<T>>

    /**
     * Group by Loi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoiGroupByArgs['orderBy'] }
        : { orderBy?: LoiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Loi model
   */
  readonly fields: LoiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domaines<T extends Loi$domainesArgs<ExtArgs> = {}>(args?: Subset<T, Loi$domainesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Loi model
   */ 
  interface LoiFieldRefs {
    readonly id: FieldRef<"Loi", 'Int'>
    readonly libelle: FieldRef<"Loi", 'String'>
    readonly effet: FieldRef<"Loi", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Loi findUnique
   */
  export type LoiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiInclude<ExtArgs> | null
    /**
     * Filter, which Loi to fetch.
     */
    where: LoiWhereUniqueInput
  }

  /**
   * Loi findUniqueOrThrow
   */
  export type LoiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiInclude<ExtArgs> | null
    /**
     * Filter, which Loi to fetch.
     */
    where: LoiWhereUniqueInput
  }

  /**
   * Loi findFirst
   */
  export type LoiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiInclude<ExtArgs> | null
    /**
     * Filter, which Loi to fetch.
     */
    where?: LoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lois to fetch.
     */
    orderBy?: LoiOrderByWithRelationInput | LoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lois.
     */
    cursor?: LoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lois.
     */
    distinct?: LoiScalarFieldEnum | LoiScalarFieldEnum[]
  }

  /**
   * Loi findFirstOrThrow
   */
  export type LoiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiInclude<ExtArgs> | null
    /**
     * Filter, which Loi to fetch.
     */
    where?: LoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lois to fetch.
     */
    orderBy?: LoiOrderByWithRelationInput | LoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lois.
     */
    cursor?: LoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lois.
     */
    distinct?: LoiScalarFieldEnum | LoiScalarFieldEnum[]
  }

  /**
   * Loi findMany
   */
  export type LoiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiInclude<ExtArgs> | null
    /**
     * Filter, which Lois to fetch.
     */
    where?: LoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lois to fetch.
     */
    orderBy?: LoiOrderByWithRelationInput | LoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lois.
     */
    cursor?: LoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lois.
     */
    skip?: number
    distinct?: LoiScalarFieldEnum | LoiScalarFieldEnum[]
  }

  /**
   * Loi create
   */
  export type LoiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiInclude<ExtArgs> | null
    /**
     * The data needed to create a Loi.
     */
    data: XOR<LoiCreateInput, LoiUncheckedCreateInput>
  }

  /**
   * Loi createMany
   */
  export type LoiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lois.
     */
    data: LoiCreateManyInput | LoiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Loi createManyAndReturn
   */
  export type LoiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lois.
     */
    data: LoiCreateManyInput | LoiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Loi update
   */
  export type LoiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiInclude<ExtArgs> | null
    /**
     * The data needed to update a Loi.
     */
    data: XOR<LoiUpdateInput, LoiUncheckedUpdateInput>
    /**
     * Choose, which Loi to update.
     */
    where: LoiWhereUniqueInput
  }

  /**
   * Loi updateMany
   */
  export type LoiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lois.
     */
    data: XOR<LoiUpdateManyMutationInput, LoiUncheckedUpdateManyInput>
    /**
     * Filter which Lois to update
     */
    where?: LoiWhereInput
  }

  /**
   * Loi upsert
   */
  export type LoiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiInclude<ExtArgs> | null
    /**
     * The filter to search for the Loi to update in case it exists.
     */
    where: LoiWhereUniqueInput
    /**
     * In case the Loi found by the `where` argument doesn't exist, create a new Loi with this data.
     */
    create: XOR<LoiCreateInput, LoiUncheckedCreateInput>
    /**
     * In case the Loi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoiUpdateInput, LoiUncheckedUpdateInput>
  }

  /**
   * Loi delete
   */
  export type LoiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiInclude<ExtArgs> | null
    /**
     * Filter which Loi to delete.
     */
    where: LoiWhereUniqueInput
  }

  /**
   * Loi deleteMany
   */
  export type LoiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lois to delete
     */
    where?: LoiWhereInput
  }

  /**
   * Loi.domaines
   */
  export type Loi$domainesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    where?: LoiTerritoireWhereInput
    orderBy?: LoiTerritoireOrderByWithRelationInput | LoiTerritoireOrderByWithRelationInput[]
    cursor?: LoiTerritoireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoiTerritoireScalarFieldEnum | LoiTerritoireScalarFieldEnum[]
  }

  /**
   * Loi without action
   */
  export type LoiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loi
     */
    select?: LoiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiInclude<ExtArgs> | null
  }


  /**
   * Model LoiTerritoire
   */

  export type AggregateLoiTerritoire = {
    _count: LoiTerritoireCountAggregateOutputType | null
    _avg: LoiTerritoireAvgAggregateOutputType | null
    _sum: LoiTerritoireSumAggregateOutputType | null
    _min: LoiTerritoireMinAggregateOutputType | null
    _max: LoiTerritoireMaxAggregateOutputType | null
  }

  export type LoiTerritoireAvgAggregateOutputType = {
    loiId: number | null
    domaineId: number | null
  }

  export type LoiTerritoireSumAggregateOutputType = {
    loiId: number | null
    domaineId: number | null
  }

  export type LoiTerritoireMinAggregateOutputType = {
    loiId: number | null
    domaineId: number | null
  }

  export type LoiTerritoireMaxAggregateOutputType = {
    loiId: number | null
    domaineId: number | null
  }

  export type LoiTerritoireCountAggregateOutputType = {
    loiId: number
    domaineId: number
    _all: number
  }


  export type LoiTerritoireAvgAggregateInputType = {
    loiId?: true
    domaineId?: true
  }

  export type LoiTerritoireSumAggregateInputType = {
    loiId?: true
    domaineId?: true
  }

  export type LoiTerritoireMinAggregateInputType = {
    loiId?: true
    domaineId?: true
  }

  export type LoiTerritoireMaxAggregateInputType = {
    loiId?: true
    domaineId?: true
  }

  export type LoiTerritoireCountAggregateInputType = {
    loiId?: true
    domaineId?: true
    _all?: true
  }

  export type LoiTerritoireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoiTerritoire to aggregate.
     */
    where?: LoiTerritoireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoiTerritoires to fetch.
     */
    orderBy?: LoiTerritoireOrderByWithRelationInput | LoiTerritoireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoiTerritoireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoiTerritoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoiTerritoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoiTerritoires
    **/
    _count?: true | LoiTerritoireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoiTerritoireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoiTerritoireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoiTerritoireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoiTerritoireMaxAggregateInputType
  }

  export type GetLoiTerritoireAggregateType<T extends LoiTerritoireAggregateArgs> = {
        [P in keyof T & keyof AggregateLoiTerritoire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoiTerritoire[P]>
      : GetScalarType<T[P], AggregateLoiTerritoire[P]>
  }




  export type LoiTerritoireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoiTerritoireWhereInput
    orderBy?: LoiTerritoireOrderByWithAggregationInput | LoiTerritoireOrderByWithAggregationInput[]
    by: LoiTerritoireScalarFieldEnum[] | LoiTerritoireScalarFieldEnum
    having?: LoiTerritoireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoiTerritoireCountAggregateInputType | true
    _avg?: LoiTerritoireAvgAggregateInputType
    _sum?: LoiTerritoireSumAggregateInputType
    _min?: LoiTerritoireMinAggregateInputType
    _max?: LoiTerritoireMaxAggregateInputType
  }

  export type LoiTerritoireGroupByOutputType = {
    loiId: number
    domaineId: number
    _count: LoiTerritoireCountAggregateOutputType | null
    _avg: LoiTerritoireAvgAggregateOutputType | null
    _sum: LoiTerritoireSumAggregateOutputType | null
    _min: LoiTerritoireMinAggregateOutputType | null
    _max: LoiTerritoireMaxAggregateOutputType | null
  }

  type GetLoiTerritoireGroupByPayload<T extends LoiTerritoireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoiTerritoireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoiTerritoireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoiTerritoireGroupByOutputType[P]>
            : GetScalarType<T[P], LoiTerritoireGroupByOutputType[P]>
        }
      >
    >


  export type LoiTerritoireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    loiId?: boolean
    domaineId?: boolean
    loi?: boolean | LoiDefaultArgs<ExtArgs>
    domaine?: boolean | DomaineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loiTerritoire"]>

  export type LoiTerritoireSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    loiId?: boolean
    domaineId?: boolean
    loi?: boolean | LoiDefaultArgs<ExtArgs>
    domaine?: boolean | DomaineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loiTerritoire"]>

  export type LoiTerritoireSelectScalar = {
    loiId?: boolean
    domaineId?: boolean
  }

  export type LoiTerritoireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loi?: boolean | LoiDefaultArgs<ExtArgs>
    domaine?: boolean | DomaineDefaultArgs<ExtArgs>
  }
  export type LoiTerritoireIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loi?: boolean | LoiDefaultArgs<ExtArgs>
    domaine?: boolean | DomaineDefaultArgs<ExtArgs>
  }

  export type $LoiTerritoirePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoiTerritoire"
    objects: {
      loi: Prisma.$LoiPayload<ExtArgs>
      domaine: Prisma.$DomainePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      loiId: number
      domaineId: number
    }, ExtArgs["result"]["loiTerritoire"]>
    composites: {}
  }

  type LoiTerritoireGetPayload<S extends boolean | null | undefined | LoiTerritoireDefaultArgs> = $Result.GetResult<Prisma.$LoiTerritoirePayload, S>

  type LoiTerritoireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoiTerritoireFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoiTerritoireCountAggregateInputType | true
    }

  export interface LoiTerritoireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoiTerritoire'], meta: { name: 'LoiTerritoire' } }
    /**
     * Find zero or one LoiTerritoire that matches the filter.
     * @param {LoiTerritoireFindUniqueArgs} args - Arguments to find a LoiTerritoire
     * @example
     * // Get one LoiTerritoire
     * const loiTerritoire = await prisma.loiTerritoire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoiTerritoireFindUniqueArgs>(args: SelectSubset<T, LoiTerritoireFindUniqueArgs<ExtArgs>>): Prisma__LoiTerritoireClient<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LoiTerritoire that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoiTerritoireFindUniqueOrThrowArgs} args - Arguments to find a LoiTerritoire
     * @example
     * // Get one LoiTerritoire
     * const loiTerritoire = await prisma.loiTerritoire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoiTerritoireFindUniqueOrThrowArgs>(args: SelectSubset<T, LoiTerritoireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoiTerritoireClient<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LoiTerritoire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiTerritoireFindFirstArgs} args - Arguments to find a LoiTerritoire
     * @example
     * // Get one LoiTerritoire
     * const loiTerritoire = await prisma.loiTerritoire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoiTerritoireFindFirstArgs>(args?: SelectSubset<T, LoiTerritoireFindFirstArgs<ExtArgs>>): Prisma__LoiTerritoireClient<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LoiTerritoire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiTerritoireFindFirstOrThrowArgs} args - Arguments to find a LoiTerritoire
     * @example
     * // Get one LoiTerritoire
     * const loiTerritoire = await prisma.loiTerritoire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoiTerritoireFindFirstOrThrowArgs>(args?: SelectSubset<T, LoiTerritoireFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoiTerritoireClient<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LoiTerritoires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiTerritoireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoiTerritoires
     * const loiTerritoires = await prisma.loiTerritoire.findMany()
     * 
     * // Get first 10 LoiTerritoires
     * const loiTerritoires = await prisma.loiTerritoire.findMany({ take: 10 })
     * 
     * // Only select the `loiId`
     * const loiTerritoireWithLoiIdOnly = await prisma.loiTerritoire.findMany({ select: { loiId: true } })
     * 
     */
    findMany<T extends LoiTerritoireFindManyArgs>(args?: SelectSubset<T, LoiTerritoireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LoiTerritoire.
     * @param {LoiTerritoireCreateArgs} args - Arguments to create a LoiTerritoire.
     * @example
     * // Create one LoiTerritoire
     * const LoiTerritoire = await prisma.loiTerritoire.create({
     *   data: {
     *     // ... data to create a LoiTerritoire
     *   }
     * })
     * 
     */
    create<T extends LoiTerritoireCreateArgs>(args: SelectSubset<T, LoiTerritoireCreateArgs<ExtArgs>>): Prisma__LoiTerritoireClient<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LoiTerritoires.
     * @param {LoiTerritoireCreateManyArgs} args - Arguments to create many LoiTerritoires.
     * @example
     * // Create many LoiTerritoires
     * const loiTerritoire = await prisma.loiTerritoire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoiTerritoireCreateManyArgs>(args?: SelectSubset<T, LoiTerritoireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoiTerritoires and returns the data saved in the database.
     * @param {LoiTerritoireCreateManyAndReturnArgs} args - Arguments to create many LoiTerritoires.
     * @example
     * // Create many LoiTerritoires
     * const loiTerritoire = await prisma.loiTerritoire.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoiTerritoires and only return the `loiId`
     * const loiTerritoireWithLoiIdOnly = await prisma.loiTerritoire.createManyAndReturn({ 
     *   select: { loiId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoiTerritoireCreateManyAndReturnArgs>(args?: SelectSubset<T, LoiTerritoireCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LoiTerritoire.
     * @param {LoiTerritoireDeleteArgs} args - Arguments to delete one LoiTerritoire.
     * @example
     * // Delete one LoiTerritoire
     * const LoiTerritoire = await prisma.loiTerritoire.delete({
     *   where: {
     *     // ... filter to delete one LoiTerritoire
     *   }
     * })
     * 
     */
    delete<T extends LoiTerritoireDeleteArgs>(args: SelectSubset<T, LoiTerritoireDeleteArgs<ExtArgs>>): Prisma__LoiTerritoireClient<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LoiTerritoire.
     * @param {LoiTerritoireUpdateArgs} args - Arguments to update one LoiTerritoire.
     * @example
     * // Update one LoiTerritoire
     * const loiTerritoire = await prisma.loiTerritoire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoiTerritoireUpdateArgs>(args: SelectSubset<T, LoiTerritoireUpdateArgs<ExtArgs>>): Prisma__LoiTerritoireClient<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LoiTerritoires.
     * @param {LoiTerritoireDeleteManyArgs} args - Arguments to filter LoiTerritoires to delete.
     * @example
     * // Delete a few LoiTerritoires
     * const { count } = await prisma.loiTerritoire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoiTerritoireDeleteManyArgs>(args?: SelectSubset<T, LoiTerritoireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoiTerritoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiTerritoireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoiTerritoires
     * const loiTerritoire = await prisma.loiTerritoire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoiTerritoireUpdateManyArgs>(args: SelectSubset<T, LoiTerritoireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoiTerritoire.
     * @param {LoiTerritoireUpsertArgs} args - Arguments to update or create a LoiTerritoire.
     * @example
     * // Update or create a LoiTerritoire
     * const loiTerritoire = await prisma.loiTerritoire.upsert({
     *   create: {
     *     // ... data to create a LoiTerritoire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoiTerritoire we want to update
     *   }
     * })
     */
    upsert<T extends LoiTerritoireUpsertArgs>(args: SelectSubset<T, LoiTerritoireUpsertArgs<ExtArgs>>): Prisma__LoiTerritoireClient<$Result.GetResult<Prisma.$LoiTerritoirePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LoiTerritoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiTerritoireCountArgs} args - Arguments to filter LoiTerritoires to count.
     * @example
     * // Count the number of LoiTerritoires
     * const count = await prisma.loiTerritoire.count({
     *   where: {
     *     // ... the filter for the LoiTerritoires we want to count
     *   }
     * })
    **/
    count<T extends LoiTerritoireCountArgs>(
      args?: Subset<T, LoiTerritoireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoiTerritoireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoiTerritoire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiTerritoireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoiTerritoireAggregateArgs>(args: Subset<T, LoiTerritoireAggregateArgs>): Prisma.PrismaPromise<GetLoiTerritoireAggregateType<T>>

    /**
     * Group by LoiTerritoire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoiTerritoireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoiTerritoireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoiTerritoireGroupByArgs['orderBy'] }
        : { orderBy?: LoiTerritoireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoiTerritoireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoiTerritoireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoiTerritoire model
   */
  readonly fields: LoiTerritoireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoiTerritoire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoiTerritoireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loi<T extends LoiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoiDefaultArgs<ExtArgs>>): Prisma__LoiClient<$Result.GetResult<Prisma.$LoiPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    domaine<T extends DomaineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomaineDefaultArgs<ExtArgs>>): Prisma__DomaineClient<$Result.GetResult<Prisma.$DomainePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoiTerritoire model
   */ 
  interface LoiTerritoireFieldRefs {
    readonly loiId: FieldRef<"LoiTerritoire", 'Int'>
    readonly domaineId: FieldRef<"LoiTerritoire", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LoiTerritoire findUnique
   */
  export type LoiTerritoireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    /**
     * Filter, which LoiTerritoire to fetch.
     */
    where: LoiTerritoireWhereUniqueInput
  }

  /**
   * LoiTerritoire findUniqueOrThrow
   */
  export type LoiTerritoireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    /**
     * Filter, which LoiTerritoire to fetch.
     */
    where: LoiTerritoireWhereUniqueInput
  }

  /**
   * LoiTerritoire findFirst
   */
  export type LoiTerritoireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    /**
     * Filter, which LoiTerritoire to fetch.
     */
    where?: LoiTerritoireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoiTerritoires to fetch.
     */
    orderBy?: LoiTerritoireOrderByWithRelationInput | LoiTerritoireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoiTerritoires.
     */
    cursor?: LoiTerritoireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoiTerritoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoiTerritoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoiTerritoires.
     */
    distinct?: LoiTerritoireScalarFieldEnum | LoiTerritoireScalarFieldEnum[]
  }

  /**
   * LoiTerritoire findFirstOrThrow
   */
  export type LoiTerritoireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    /**
     * Filter, which LoiTerritoire to fetch.
     */
    where?: LoiTerritoireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoiTerritoires to fetch.
     */
    orderBy?: LoiTerritoireOrderByWithRelationInput | LoiTerritoireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoiTerritoires.
     */
    cursor?: LoiTerritoireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoiTerritoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoiTerritoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoiTerritoires.
     */
    distinct?: LoiTerritoireScalarFieldEnum | LoiTerritoireScalarFieldEnum[]
  }

  /**
   * LoiTerritoire findMany
   */
  export type LoiTerritoireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    /**
     * Filter, which LoiTerritoires to fetch.
     */
    where?: LoiTerritoireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoiTerritoires to fetch.
     */
    orderBy?: LoiTerritoireOrderByWithRelationInput | LoiTerritoireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoiTerritoires.
     */
    cursor?: LoiTerritoireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoiTerritoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoiTerritoires.
     */
    skip?: number
    distinct?: LoiTerritoireScalarFieldEnum | LoiTerritoireScalarFieldEnum[]
  }

  /**
   * LoiTerritoire create
   */
  export type LoiTerritoireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    /**
     * The data needed to create a LoiTerritoire.
     */
    data: XOR<LoiTerritoireCreateInput, LoiTerritoireUncheckedCreateInput>
  }

  /**
   * LoiTerritoire createMany
   */
  export type LoiTerritoireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoiTerritoires.
     */
    data: LoiTerritoireCreateManyInput | LoiTerritoireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoiTerritoire createManyAndReturn
   */
  export type LoiTerritoireCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LoiTerritoires.
     */
    data: LoiTerritoireCreateManyInput | LoiTerritoireCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoiTerritoire update
   */
  export type LoiTerritoireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    /**
     * The data needed to update a LoiTerritoire.
     */
    data: XOR<LoiTerritoireUpdateInput, LoiTerritoireUncheckedUpdateInput>
    /**
     * Choose, which LoiTerritoire to update.
     */
    where: LoiTerritoireWhereUniqueInput
  }

  /**
   * LoiTerritoire updateMany
   */
  export type LoiTerritoireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoiTerritoires.
     */
    data: XOR<LoiTerritoireUpdateManyMutationInput, LoiTerritoireUncheckedUpdateManyInput>
    /**
     * Filter which LoiTerritoires to update
     */
    where?: LoiTerritoireWhereInput
  }

  /**
   * LoiTerritoire upsert
   */
  export type LoiTerritoireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    /**
     * The filter to search for the LoiTerritoire to update in case it exists.
     */
    where: LoiTerritoireWhereUniqueInput
    /**
     * In case the LoiTerritoire found by the `where` argument doesn't exist, create a new LoiTerritoire with this data.
     */
    create: XOR<LoiTerritoireCreateInput, LoiTerritoireUncheckedCreateInput>
    /**
     * In case the LoiTerritoire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoiTerritoireUpdateInput, LoiTerritoireUncheckedUpdateInput>
  }

  /**
   * LoiTerritoire delete
   */
  export type LoiTerritoireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
    /**
     * Filter which LoiTerritoire to delete.
     */
    where: LoiTerritoireWhereUniqueInput
  }

  /**
   * LoiTerritoire deleteMany
   */
  export type LoiTerritoireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoiTerritoires to delete
     */
    where?: LoiTerritoireWhereInput
  }

  /**
   * LoiTerritoire without action
   */
  export type LoiTerritoireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoiTerritoire
     */
    select?: LoiTerritoireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoiTerritoireInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RaceScalarFieldEnum: {
    id: 'id',
    libelle: 'libelle'
  };

  export type RaceScalarFieldEnum = (typeof RaceScalarFieldEnum)[keyof typeof RaceScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    libelle: 'libelle'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const LigneeScalarFieldEnum: {
    id: 'id',
    nom: 'nom'
  };

  export type LigneeScalarFieldEnum = (typeof LigneeScalarFieldEnum)[keyof typeof LigneeScalarFieldEnum]


  export const PersonnageScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    dateNaissance: 'dateNaissance',
    statutVie: 'statutVie',
    dateDeces: 'dateDeces',
    causeDeces: 'causeDeces',
    raceId: 'raceId',
    ligneeId: 'ligneeId'
  };

  export type PersonnageScalarFieldEnum = (typeof PersonnageScalarFieldEnum)[keyof typeof PersonnageScalarFieldEnum]


  export const PersonnageRoleScalarFieldEnum: {
    personnageId: 'personnageId',
    roleId: 'roleId'
  };

  export type PersonnageRoleScalarFieldEnum = (typeof PersonnageRoleScalarFieldEnum)[keyof typeof PersonnageRoleScalarFieldEnum]


  export const CompetenceScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    exigenceFormation: 'exigenceFormation',
    exigenceRaceId: 'exigenceRaceId'
  };

  export type CompetenceScalarFieldEnum = (typeof CompetenceScalarFieldEnum)[keyof typeof CompetenceScalarFieldEnum]


  export const PersonnageCompetenceScalarFieldEnum: {
    personnageId: 'personnageId',
    competenceId: 'competenceId',
    niveau: 'niveau'
  };

  export type PersonnageCompetenceScalarFieldEnum = (typeof PersonnageCompetenceScalarFieldEnum)[keyof typeof PersonnageCompetenceScalarFieldEnum]


  export const DomaineScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    frontieres: 'frontieres',
    richessesOr: 'richessesOr',
    ressources: 'ressources'
  };

  export type DomaineScalarFieldEnum = (typeof DomaineScalarFieldEnum)[keyof typeof DomaineScalarFieldEnum]


  export const TitreScalarFieldEnum: {
    id: 'id',
    libelle: 'libelle'
  };

  export type TitreScalarFieldEnum = (typeof TitreScalarFieldEnum)[keyof typeof TitreScalarFieldEnum]


  export const PersonnageTitreScalarFieldEnum: {
    id: 'id',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    estActif: 'estActif',
    personnageId: 'personnageId',
    titreId: 'titreId',
    domaineId: 'domaineId',
    ligneeId: 'ligneeId'
  };

  export type PersonnageTitreScalarFieldEnum = (typeof PersonnageTitreScalarFieldEnum)[keyof typeof PersonnageTitreScalarFieldEnum]


  export const VillageScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    localisation: 'localisation',
    population: 'population',
    ressourcePrincipale: 'ressourcePrincipale',
    domaineId: 'domaineId'
  };

  export type VillageScalarFieldEnum = (typeof VillageScalarFieldEnum)[keyof typeof VillageScalarFieldEnum]


  export const GuildeScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    specialite: 'specialite',
    reputation: 'reputation'
  };

  export type GuildeScalarFieldEnum = (typeof GuildeScalarFieldEnum)[keyof typeof GuildeScalarFieldEnum]


  export const GuildeMembreScalarFieldEnum: {
    personnageId: 'personnageId',
    guildeId: 'guildeId',
    dateEntree: 'dateEntree',
    dateSortie: 'dateSortie'
  };

  export type GuildeMembreScalarFieldEnum = (typeof GuildeMembreScalarFieldEnum)[keyof typeof GuildeMembreScalarFieldEnum]


  export const CreatureScalarFieldEnum: {
    id: 'id',
    espece: 'espece',
    forces: 'forces',
    faiblesses: 'faiblesses',
    dangerosite: 'dangerosite'
  };

  export type CreatureScalarFieldEnum = (typeof CreatureScalarFieldEnum)[keyof typeof CreatureScalarFieldEnum]


  export const EcoleMagieScalarFieldEnum: {
    id: 'id',
    nom: 'nom'
  };

  export type EcoleMagieScalarFieldEnum = (typeof EcoleMagieScalarFieldEnum)[keyof typeof EcoleMagieScalarFieldEnum]


  export const SortScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    element: 'element',
    coutMana: 'coutMana',
    niveauRequis: 'niveauRequis',
    estInterdit: 'estInterdit',
    estRituel: 'estRituel',
    ecoleId: 'ecoleId'
  };

  export type SortScalarFieldEnum = (typeof SortScalarFieldEnum)[keyof typeof SortScalarFieldEnum]


  export const MaladieScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    effets: 'effets',
    contagion: 'contagion',
    remede: 'remede',
    tauxMortalite: 'tauxMortalite'
  };

  export type MaladieScalarFieldEnum = (typeof MaladieScalarFieldEnum)[keyof typeof MaladieScalarFieldEnum]


  export const PersonnageMaladieScalarFieldEnum: {
    personnageId: 'personnageId',
    maladieId: 'maladieId',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    issue: 'issue'
  };

  export type PersonnageMaladieScalarFieldEnum = (typeof PersonnageMaladieScalarFieldEnum)[keyof typeof PersonnageMaladieScalarFieldEnum]


  export const ArmeeScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    effectif: 'effectif',
    composition: 'composition',
    moral: 'moral',
    etatApprovisionnement: 'etatApprovisionnement',
    domaineId: 'domaineId',
    commandantId: 'commandantId'
  };

  export type ArmeeScalarFieldEnum = (typeof ArmeeScalarFieldEnum)[keyof typeof ArmeeScalarFieldEnum]


  export const BatailleScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    dateBataille: 'dateBataille',
    lieu: 'lieu',
    pertesA: 'pertesA',
    pertesB: 'pertesB',
    vainqueurTexte: 'vainqueurTexte'
  };

  export type BatailleScalarFieldEnum = (typeof BatailleScalarFieldEnum)[keyof typeof BatailleScalarFieldEnum]


  export const ArmeeBatailleScalarFieldEnum: {
    armeeId: 'armeeId',
    batailleId: 'batailleId',
    cote: 'cote',
    pertes: 'pertes'
  };

  export type ArmeeBatailleScalarFieldEnum = (typeof ArmeeBatailleScalarFieldEnum)[keyof typeof ArmeeBatailleScalarFieldEnum]


  export const GuildeBatailleScalarFieldEnum: {
    guildeId: 'guildeId',
    batailleId: 'batailleId',
    role: 'role'
  };

  export type GuildeBatailleScalarFieldEnum = (typeof GuildeBatailleScalarFieldEnum)[keyof typeof GuildeBatailleScalarFieldEnum]


  export const CreatureBatailleScalarFieldEnum: {
    creatureId: 'creatureId',
    batailleId: 'batailleId',
    nombre: 'nombre',
    role: 'role'
  };

  export type CreatureBatailleScalarFieldEnum = (typeof CreatureBatailleScalarFieldEnum)[keyof typeof CreatureBatailleScalarFieldEnum]


  export const EquipementScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    typeEquipement: 'typeEquipement',
    materiaux: 'materiaux',
    rarete: 'rarete',
    enchantements: 'enchantements',
    affiniteRequise: 'affiniteRequise'
  };

  export type EquipementScalarFieldEnum = (typeof EquipementScalarFieldEnum)[keyof typeof EquipementScalarFieldEnum]


  export const PersonnageEquipementScalarFieldEnum: {
    personnageId: 'personnageId',
    equipementId: 'equipementId',
    dateAcquisition: 'dateAcquisition',
    source: 'source'
  };

  export type PersonnageEquipementScalarFieldEnum = (typeof PersonnageEquipementScalarFieldEnum)[keyof typeof PersonnageEquipementScalarFieldEnum]


  export const MarchandScalarFieldEnum: {
    id: 'id',
    nom: 'nom'
  };

  export type MarchandScalarFieldEnum = (typeof MarchandScalarFieldEnum)[keyof typeof MarchandScalarFieldEnum]


  export const RouteCommercialeScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    securite: 'securite',
    saison: 'saison'
  };

  export type RouteCommercialeScalarFieldEnum = (typeof RouteCommercialeScalarFieldEnum)[keyof typeof RouteCommercialeScalarFieldEnum]


  export const LieuScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    typeLieu: 'typeLieu',
    localisation: 'localisation'
  };

  export type LieuScalarFieldEnum = (typeof LieuScalarFieldEnum)[keyof typeof LieuScalarFieldEnum]


  export const RouteSegmentScalarFieldEnum: {
    routeId: 'routeId',
    lieuId: 'lieuId',
    ordre: 'ordre'
  };

  export type RouteSegmentScalarFieldEnum = (typeof RouteSegmentScalarFieldEnum)[keyof typeof RouteSegmentScalarFieldEnum]


  export const MarchandRouteScalarFieldEnum: {
    marchandId: 'marchandId',
    routeId: 'routeId',
    biens: 'biens',
    taxes: 'taxes'
  };

  export type MarchandRouteScalarFieldEnum = (typeof MarchandRouteScalarFieldEnum)[keyof typeof MarchandRouteScalarFieldEnum]


  export const BardeScalarFieldEnum: {
    id: 'id',
    nom: 'nom'
  };

  export type BardeScalarFieldEnum = (typeof BardeScalarFieldEnum)[keyof typeof BardeScalarFieldEnum]


  export const HistoireScalarFieldEnum: {
    id: 'id',
    titre: 'titre',
    typeEvenement: 'typeEvenement',
    description: 'description',
    dateEvenement: 'dateEvenement',
    bardeId: 'bardeId'
  };

  export type HistoireScalarFieldEnum = (typeof HistoireScalarFieldEnum)[keyof typeof HistoireScalarFieldEnum]


  export const InventaireScalarFieldEnum: {
    id: 'id',
    typeRessource: 'typeRessource',
    stock: 'stock',
    seuilAlerte: 'seuilAlerte',
    dateMesure: 'dateMesure',
    lieuId: 'lieuId',
    armeeId: 'armeeId',
    villageId: 'villageId'
  };

  export type InventaireScalarFieldEnum = (typeof InventaireScalarFieldEnum)[keyof typeof InventaireScalarFieldEnum]


  export const RelationDiplomatiqueScalarFieldEnum: {
    id: 'id',
    typeRelation: 'typeRelation',
    conditions: 'conditions',
    dateSignature: 'dateSignature',
    echeance: 'echeance',
    domaineSourceId: 'domaineSourceId',
    domaineCibleId: 'domaineCibleId'
  };

  export type RelationDiplomatiqueScalarFieldEnum = (typeof RelationDiplomatiqueScalarFieldEnum)[keyof typeof RelationDiplomatiqueScalarFieldEnum]


  export const LoiScalarFieldEnum: {
    id: 'id',
    libelle: 'libelle',
    effet: 'effet'
  };

  export type LoiScalarFieldEnum = (typeof LoiScalarFieldEnum)[keyof typeof LoiScalarFieldEnum]


  export const LoiTerritoireScalarFieldEnum: {
    loiId: 'loiId',
    domaineId: 'domaineId'
  };

  export type LoiTerritoireScalarFieldEnum = (typeof LoiTerritoireScalarFieldEnum)[keyof typeof LoiTerritoireScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type RaceWhereInput = {
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    id?: IntFilter<"Race"> | number
    libelle?: StringFilter<"Race"> | string
    personnages?: PersonnageListRelationFilter
    competences?: CompetenceListRelationFilter
  }

  export type RaceOrderByWithRelationInput = {
    id?: SortOrder
    libelle?: SortOrder
    personnages?: PersonnageOrderByRelationAggregateInput
    competences?: CompetenceOrderByRelationAggregateInput
  }

  export type RaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    libelle?: string
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    personnages?: PersonnageListRelationFilter
    competences?: CompetenceListRelationFilter
  }, "id" | "libelle">

  export type RaceOrderByWithAggregationInput = {
    id?: SortOrder
    libelle?: SortOrder
    _count?: RaceCountOrderByAggregateInput
    _avg?: RaceAvgOrderByAggregateInput
    _max?: RaceMaxOrderByAggregateInput
    _min?: RaceMinOrderByAggregateInput
    _sum?: RaceSumOrderByAggregateInput
  }

  export type RaceScalarWhereWithAggregatesInput = {
    AND?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    OR?: RaceScalarWhereWithAggregatesInput[]
    NOT?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Race"> | number
    libelle?: StringWithAggregatesFilter<"Race"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    libelle?: StringFilter<"Role"> | string
    personnages?: PersonnageRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    libelle?: SortOrder
    personnages?: PersonnageRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    libelle?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    personnages?: PersonnageRoleListRelationFilter
  }, "id" | "libelle">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    libelle?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    libelle?: StringWithAggregatesFilter<"Role"> | string
  }

  export type LigneeWhereInput = {
    AND?: LigneeWhereInput | LigneeWhereInput[]
    OR?: LigneeWhereInput[]
    NOT?: LigneeWhereInput | LigneeWhereInput[]
    id?: IntFilter<"Lignee"> | number
    nom?: StringFilter<"Lignee"> | string
    personnages?: PersonnageListRelationFilter
    titres?: PersonnageTitreListRelationFilter
  }

  export type LigneeOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    personnages?: PersonnageOrderByRelationAggregateInput
    titres?: PersonnageTitreOrderByRelationAggregateInput
  }

  export type LigneeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: LigneeWhereInput | LigneeWhereInput[]
    OR?: LigneeWhereInput[]
    NOT?: LigneeWhereInput | LigneeWhereInput[]
    personnages?: PersonnageListRelationFilter
    titres?: PersonnageTitreListRelationFilter
  }, "id" | "nom">

  export type LigneeOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    _count?: LigneeCountOrderByAggregateInput
    _avg?: LigneeAvgOrderByAggregateInput
    _max?: LigneeMaxOrderByAggregateInput
    _min?: LigneeMinOrderByAggregateInput
    _sum?: LigneeSumOrderByAggregateInput
  }

  export type LigneeScalarWhereWithAggregatesInput = {
    AND?: LigneeScalarWhereWithAggregatesInput | LigneeScalarWhereWithAggregatesInput[]
    OR?: LigneeScalarWhereWithAggregatesInput[]
    NOT?: LigneeScalarWhereWithAggregatesInput | LigneeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lignee"> | number
    nom?: StringWithAggregatesFilter<"Lignee"> | string
  }

  export type PersonnageWhereInput = {
    AND?: PersonnageWhereInput | PersonnageWhereInput[]
    OR?: PersonnageWhereInput[]
    NOT?: PersonnageWhereInput | PersonnageWhereInput[]
    id?: IntFilter<"Personnage"> | number
    nom?: StringFilter<"Personnage"> | string
    dateNaissance?: DateTimeNullableFilter<"Personnage"> | Date | string | null
    statutVie?: StringNullableFilter<"Personnage"> | string | null
    dateDeces?: DateTimeNullableFilter<"Personnage"> | Date | string | null
    causeDeces?: StringNullableFilter<"Personnage"> | string | null
    raceId?: IntNullableFilter<"Personnage"> | number | null
    ligneeId?: IntNullableFilter<"Personnage"> | number | null
    race?: XOR<RaceNullableRelationFilter, RaceWhereInput> | null
    lignee?: XOR<LigneeNullableRelationFilter, LigneeWhereInput> | null
    roles?: PersonnageRoleListRelationFilter
    competences?: PersonnageCompetenceListRelationFilter
    titres?: PersonnageTitreListRelationFilter
    maladies?: PersonnageMaladieListRelationFilter
    commandements?: ArmeeListRelationFilter
    equipements?: PersonnageEquipementListRelationFilter
    guildes?: GuildeMembreListRelationFilter
  }

  export type PersonnageOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    dateNaissance?: SortOrderInput | SortOrder
    statutVie?: SortOrderInput | SortOrder
    dateDeces?: SortOrderInput | SortOrder
    causeDeces?: SortOrderInput | SortOrder
    raceId?: SortOrderInput | SortOrder
    ligneeId?: SortOrderInput | SortOrder
    race?: RaceOrderByWithRelationInput
    lignee?: LigneeOrderByWithRelationInput
    roles?: PersonnageRoleOrderByRelationAggregateInput
    competences?: PersonnageCompetenceOrderByRelationAggregateInput
    titres?: PersonnageTitreOrderByRelationAggregateInput
    maladies?: PersonnageMaladieOrderByRelationAggregateInput
    commandements?: ArmeeOrderByRelationAggregateInput
    equipements?: PersonnageEquipementOrderByRelationAggregateInput
    guildes?: GuildeMembreOrderByRelationAggregateInput
  }

  export type PersonnageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PersonnageWhereInput | PersonnageWhereInput[]
    OR?: PersonnageWhereInput[]
    NOT?: PersonnageWhereInput | PersonnageWhereInput[]
    nom?: StringFilter<"Personnage"> | string
    dateNaissance?: DateTimeNullableFilter<"Personnage"> | Date | string | null
    statutVie?: StringNullableFilter<"Personnage"> | string | null
    dateDeces?: DateTimeNullableFilter<"Personnage"> | Date | string | null
    causeDeces?: StringNullableFilter<"Personnage"> | string | null
    raceId?: IntNullableFilter<"Personnage"> | number | null
    ligneeId?: IntNullableFilter<"Personnage"> | number | null
    race?: XOR<RaceNullableRelationFilter, RaceWhereInput> | null
    lignee?: XOR<LigneeNullableRelationFilter, LigneeWhereInput> | null
    roles?: PersonnageRoleListRelationFilter
    competences?: PersonnageCompetenceListRelationFilter
    titres?: PersonnageTitreListRelationFilter
    maladies?: PersonnageMaladieListRelationFilter
    commandements?: ArmeeListRelationFilter
    equipements?: PersonnageEquipementListRelationFilter
    guildes?: GuildeMembreListRelationFilter
  }, "id">

  export type PersonnageOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    dateNaissance?: SortOrderInput | SortOrder
    statutVie?: SortOrderInput | SortOrder
    dateDeces?: SortOrderInput | SortOrder
    causeDeces?: SortOrderInput | SortOrder
    raceId?: SortOrderInput | SortOrder
    ligneeId?: SortOrderInput | SortOrder
    _count?: PersonnageCountOrderByAggregateInput
    _avg?: PersonnageAvgOrderByAggregateInput
    _max?: PersonnageMaxOrderByAggregateInput
    _min?: PersonnageMinOrderByAggregateInput
    _sum?: PersonnageSumOrderByAggregateInput
  }

  export type PersonnageScalarWhereWithAggregatesInput = {
    AND?: PersonnageScalarWhereWithAggregatesInput | PersonnageScalarWhereWithAggregatesInput[]
    OR?: PersonnageScalarWhereWithAggregatesInput[]
    NOT?: PersonnageScalarWhereWithAggregatesInput | PersonnageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Personnage"> | number
    nom?: StringWithAggregatesFilter<"Personnage"> | string
    dateNaissance?: DateTimeNullableWithAggregatesFilter<"Personnage"> | Date | string | null
    statutVie?: StringNullableWithAggregatesFilter<"Personnage"> | string | null
    dateDeces?: DateTimeNullableWithAggregatesFilter<"Personnage"> | Date | string | null
    causeDeces?: StringNullableWithAggregatesFilter<"Personnage"> | string | null
    raceId?: IntNullableWithAggregatesFilter<"Personnage"> | number | null
    ligneeId?: IntNullableWithAggregatesFilter<"Personnage"> | number | null
  }

  export type PersonnageRoleWhereInput = {
    AND?: PersonnageRoleWhereInput | PersonnageRoleWhereInput[]
    OR?: PersonnageRoleWhereInput[]
    NOT?: PersonnageRoleWhereInput | PersonnageRoleWhereInput[]
    personnageId?: IntFilter<"PersonnageRole"> | number
    roleId?: IntFilter<"PersonnageRole"> | number
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type PersonnageRoleOrderByWithRelationInput = {
    personnageId?: SortOrder
    roleId?: SortOrder
    personnage?: PersonnageOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type PersonnageRoleWhereUniqueInput = Prisma.AtLeast<{
    personnageId_roleId?: PersonnageRolePersonnageIdRoleIdCompoundUniqueInput
    AND?: PersonnageRoleWhereInput | PersonnageRoleWhereInput[]
    OR?: PersonnageRoleWhereInput[]
    NOT?: PersonnageRoleWhereInput | PersonnageRoleWhereInput[]
    personnageId?: IntFilter<"PersonnageRole"> | number
    roleId?: IntFilter<"PersonnageRole"> | number
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "personnageId_roleId">

  export type PersonnageRoleOrderByWithAggregationInput = {
    personnageId?: SortOrder
    roleId?: SortOrder
    _count?: PersonnageRoleCountOrderByAggregateInput
    _avg?: PersonnageRoleAvgOrderByAggregateInput
    _max?: PersonnageRoleMaxOrderByAggregateInput
    _min?: PersonnageRoleMinOrderByAggregateInput
    _sum?: PersonnageRoleSumOrderByAggregateInput
  }

  export type PersonnageRoleScalarWhereWithAggregatesInput = {
    AND?: PersonnageRoleScalarWhereWithAggregatesInput | PersonnageRoleScalarWhereWithAggregatesInput[]
    OR?: PersonnageRoleScalarWhereWithAggregatesInput[]
    NOT?: PersonnageRoleScalarWhereWithAggregatesInput | PersonnageRoleScalarWhereWithAggregatesInput[]
    personnageId?: IntWithAggregatesFilter<"PersonnageRole"> | number
    roleId?: IntWithAggregatesFilter<"PersonnageRole"> | number
  }

  export type CompetenceWhereInput = {
    AND?: CompetenceWhereInput | CompetenceWhereInput[]
    OR?: CompetenceWhereInput[]
    NOT?: CompetenceWhereInput | CompetenceWhereInput[]
    id?: IntFilter<"Competence"> | number
    nom?: StringFilter<"Competence"> | string
    exigenceFormation?: StringNullableFilter<"Competence"> | string | null
    exigenceRaceId?: IntNullableFilter<"Competence"> | number | null
    exigenceRace?: XOR<RaceNullableRelationFilter, RaceWhereInput> | null
    personnages?: PersonnageCompetenceListRelationFilter
  }

  export type CompetenceOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    exigenceFormation?: SortOrderInput | SortOrder
    exigenceRaceId?: SortOrderInput | SortOrder
    exigenceRace?: RaceOrderByWithRelationInput
    personnages?: PersonnageCompetenceOrderByRelationAggregateInput
  }

  export type CompetenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: CompetenceWhereInput | CompetenceWhereInput[]
    OR?: CompetenceWhereInput[]
    NOT?: CompetenceWhereInput | CompetenceWhereInput[]
    exigenceFormation?: StringNullableFilter<"Competence"> | string | null
    exigenceRaceId?: IntNullableFilter<"Competence"> | number | null
    exigenceRace?: XOR<RaceNullableRelationFilter, RaceWhereInput> | null
    personnages?: PersonnageCompetenceListRelationFilter
  }, "id" | "nom">

  export type CompetenceOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    exigenceFormation?: SortOrderInput | SortOrder
    exigenceRaceId?: SortOrderInput | SortOrder
    _count?: CompetenceCountOrderByAggregateInput
    _avg?: CompetenceAvgOrderByAggregateInput
    _max?: CompetenceMaxOrderByAggregateInput
    _min?: CompetenceMinOrderByAggregateInput
    _sum?: CompetenceSumOrderByAggregateInput
  }

  export type CompetenceScalarWhereWithAggregatesInput = {
    AND?: CompetenceScalarWhereWithAggregatesInput | CompetenceScalarWhereWithAggregatesInput[]
    OR?: CompetenceScalarWhereWithAggregatesInput[]
    NOT?: CompetenceScalarWhereWithAggregatesInput | CompetenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Competence"> | number
    nom?: StringWithAggregatesFilter<"Competence"> | string
    exigenceFormation?: StringNullableWithAggregatesFilter<"Competence"> | string | null
    exigenceRaceId?: IntNullableWithAggregatesFilter<"Competence"> | number | null
  }

  export type PersonnageCompetenceWhereInput = {
    AND?: PersonnageCompetenceWhereInput | PersonnageCompetenceWhereInput[]
    OR?: PersonnageCompetenceWhereInput[]
    NOT?: PersonnageCompetenceWhereInput | PersonnageCompetenceWhereInput[]
    personnageId?: IntFilter<"PersonnageCompetence"> | number
    competenceId?: IntFilter<"PersonnageCompetence"> | number
    niveau?: IntFilter<"PersonnageCompetence"> | number
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    competence?: XOR<CompetenceRelationFilter, CompetenceWhereInput>
  }

  export type PersonnageCompetenceOrderByWithRelationInput = {
    personnageId?: SortOrder
    competenceId?: SortOrder
    niveau?: SortOrder
    personnage?: PersonnageOrderByWithRelationInput
    competence?: CompetenceOrderByWithRelationInput
  }

  export type PersonnageCompetenceWhereUniqueInput = Prisma.AtLeast<{
    personnageId_competenceId?: PersonnageCompetencePersonnageIdCompetenceIdCompoundUniqueInput
    AND?: PersonnageCompetenceWhereInput | PersonnageCompetenceWhereInput[]
    OR?: PersonnageCompetenceWhereInput[]
    NOT?: PersonnageCompetenceWhereInput | PersonnageCompetenceWhereInput[]
    personnageId?: IntFilter<"PersonnageCompetence"> | number
    competenceId?: IntFilter<"PersonnageCompetence"> | number
    niveau?: IntFilter<"PersonnageCompetence"> | number
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    competence?: XOR<CompetenceRelationFilter, CompetenceWhereInput>
  }, "personnageId_competenceId">

  export type PersonnageCompetenceOrderByWithAggregationInput = {
    personnageId?: SortOrder
    competenceId?: SortOrder
    niveau?: SortOrder
    _count?: PersonnageCompetenceCountOrderByAggregateInput
    _avg?: PersonnageCompetenceAvgOrderByAggregateInput
    _max?: PersonnageCompetenceMaxOrderByAggregateInput
    _min?: PersonnageCompetenceMinOrderByAggregateInput
    _sum?: PersonnageCompetenceSumOrderByAggregateInput
  }

  export type PersonnageCompetenceScalarWhereWithAggregatesInput = {
    AND?: PersonnageCompetenceScalarWhereWithAggregatesInput | PersonnageCompetenceScalarWhereWithAggregatesInput[]
    OR?: PersonnageCompetenceScalarWhereWithAggregatesInput[]
    NOT?: PersonnageCompetenceScalarWhereWithAggregatesInput | PersonnageCompetenceScalarWhereWithAggregatesInput[]
    personnageId?: IntWithAggregatesFilter<"PersonnageCompetence"> | number
    competenceId?: IntWithAggregatesFilter<"PersonnageCompetence"> | number
    niveau?: IntWithAggregatesFilter<"PersonnageCompetence"> | number
  }

  export type DomaineWhereInput = {
    AND?: DomaineWhereInput | DomaineWhereInput[]
    OR?: DomaineWhereInput[]
    NOT?: DomaineWhereInput | DomaineWhereInput[]
    id?: IntFilter<"Domaine"> | number
    nom?: StringFilter<"Domaine"> | string
    frontieres?: StringNullableFilter<"Domaine"> | string | null
    richessesOr?: DecimalNullableFilter<"Domaine"> | Decimal | DecimalJsLike | number | string | null
    ressources?: StringNullableFilter<"Domaine"> | string | null
    villages?: VillageListRelationFilter
    titres?: PersonnageTitreListRelationFilter
    armees?: ArmeeListRelationFilter
    relationsSource?: RelationDiplomatiqueListRelationFilter
    relationsCible?: RelationDiplomatiqueListRelationFilter
    lois?: LoiTerritoireListRelationFilter
  }

  export type DomaineOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    frontieres?: SortOrderInput | SortOrder
    richessesOr?: SortOrderInput | SortOrder
    ressources?: SortOrderInput | SortOrder
    villages?: VillageOrderByRelationAggregateInput
    titres?: PersonnageTitreOrderByRelationAggregateInput
    armees?: ArmeeOrderByRelationAggregateInput
    relationsSource?: RelationDiplomatiqueOrderByRelationAggregateInput
    relationsCible?: RelationDiplomatiqueOrderByRelationAggregateInput
    lois?: LoiTerritoireOrderByRelationAggregateInput
  }

  export type DomaineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: DomaineWhereInput | DomaineWhereInput[]
    OR?: DomaineWhereInput[]
    NOT?: DomaineWhereInput | DomaineWhereInput[]
    frontieres?: StringNullableFilter<"Domaine"> | string | null
    richessesOr?: DecimalNullableFilter<"Domaine"> | Decimal | DecimalJsLike | number | string | null
    ressources?: StringNullableFilter<"Domaine"> | string | null
    villages?: VillageListRelationFilter
    titres?: PersonnageTitreListRelationFilter
    armees?: ArmeeListRelationFilter
    relationsSource?: RelationDiplomatiqueListRelationFilter
    relationsCible?: RelationDiplomatiqueListRelationFilter
    lois?: LoiTerritoireListRelationFilter
  }, "id" | "nom">

  export type DomaineOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    frontieres?: SortOrderInput | SortOrder
    richessesOr?: SortOrderInput | SortOrder
    ressources?: SortOrderInput | SortOrder
    _count?: DomaineCountOrderByAggregateInput
    _avg?: DomaineAvgOrderByAggregateInput
    _max?: DomaineMaxOrderByAggregateInput
    _min?: DomaineMinOrderByAggregateInput
    _sum?: DomaineSumOrderByAggregateInput
  }

  export type DomaineScalarWhereWithAggregatesInput = {
    AND?: DomaineScalarWhereWithAggregatesInput | DomaineScalarWhereWithAggregatesInput[]
    OR?: DomaineScalarWhereWithAggregatesInput[]
    NOT?: DomaineScalarWhereWithAggregatesInput | DomaineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Domaine"> | number
    nom?: StringWithAggregatesFilter<"Domaine"> | string
    frontieres?: StringNullableWithAggregatesFilter<"Domaine"> | string | null
    richessesOr?: DecimalNullableWithAggregatesFilter<"Domaine"> | Decimal | DecimalJsLike | number | string | null
    ressources?: StringNullableWithAggregatesFilter<"Domaine"> | string | null
  }

  export type TitreWhereInput = {
    AND?: TitreWhereInput | TitreWhereInput[]
    OR?: TitreWhereInput[]
    NOT?: TitreWhereInput | TitreWhereInput[]
    id?: IntFilter<"Titre"> | number
    libelle?: StringFilter<"Titre"> | string
    attributions?: PersonnageTitreListRelationFilter
  }

  export type TitreOrderByWithRelationInput = {
    id?: SortOrder
    libelle?: SortOrder
    attributions?: PersonnageTitreOrderByRelationAggregateInput
  }

  export type TitreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    libelle?: string
    AND?: TitreWhereInput | TitreWhereInput[]
    OR?: TitreWhereInput[]
    NOT?: TitreWhereInput | TitreWhereInput[]
    attributions?: PersonnageTitreListRelationFilter
  }, "id" | "libelle">

  export type TitreOrderByWithAggregationInput = {
    id?: SortOrder
    libelle?: SortOrder
    _count?: TitreCountOrderByAggregateInput
    _avg?: TitreAvgOrderByAggregateInput
    _max?: TitreMaxOrderByAggregateInput
    _min?: TitreMinOrderByAggregateInput
    _sum?: TitreSumOrderByAggregateInput
  }

  export type TitreScalarWhereWithAggregatesInput = {
    AND?: TitreScalarWhereWithAggregatesInput | TitreScalarWhereWithAggregatesInput[]
    OR?: TitreScalarWhereWithAggregatesInput[]
    NOT?: TitreScalarWhereWithAggregatesInput | TitreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Titre"> | number
    libelle?: StringWithAggregatesFilter<"Titre"> | string
  }

  export type PersonnageTitreWhereInput = {
    AND?: PersonnageTitreWhereInput | PersonnageTitreWhereInput[]
    OR?: PersonnageTitreWhereInput[]
    NOT?: PersonnageTitreWhereInput | PersonnageTitreWhereInput[]
    id?: IntFilter<"PersonnageTitre"> | number
    dateDebut?: DateTimeNullableFilter<"PersonnageTitre"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"PersonnageTitre"> | Date | string | null
    estActif?: BoolFilter<"PersonnageTitre"> | boolean
    personnageId?: IntFilter<"PersonnageTitre"> | number
    titreId?: IntFilter<"PersonnageTitre"> | number
    domaineId?: IntNullableFilter<"PersonnageTitre"> | number | null
    ligneeId?: IntNullableFilter<"PersonnageTitre"> | number | null
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    titre?: XOR<TitreRelationFilter, TitreWhereInput>
    domaine?: XOR<DomaineNullableRelationFilter, DomaineWhereInput> | null
    lignee?: XOR<LigneeNullableRelationFilter, LigneeWhereInput> | null
  }

  export type PersonnageTitreOrderByWithRelationInput = {
    id?: SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFin?: SortOrderInput | SortOrder
    estActif?: SortOrder
    personnageId?: SortOrder
    titreId?: SortOrder
    domaineId?: SortOrderInput | SortOrder
    ligneeId?: SortOrderInput | SortOrder
    personnage?: PersonnageOrderByWithRelationInput
    titre?: TitreOrderByWithRelationInput
    domaine?: DomaineOrderByWithRelationInput
    lignee?: LigneeOrderByWithRelationInput
  }

  export type PersonnageTitreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PersonnageTitreWhereInput | PersonnageTitreWhereInput[]
    OR?: PersonnageTitreWhereInput[]
    NOT?: PersonnageTitreWhereInput | PersonnageTitreWhereInput[]
    dateDebut?: DateTimeNullableFilter<"PersonnageTitre"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"PersonnageTitre"> | Date | string | null
    estActif?: BoolFilter<"PersonnageTitre"> | boolean
    personnageId?: IntFilter<"PersonnageTitre"> | number
    titreId?: IntFilter<"PersonnageTitre"> | number
    domaineId?: IntNullableFilter<"PersonnageTitre"> | number | null
    ligneeId?: IntNullableFilter<"PersonnageTitre"> | number | null
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    titre?: XOR<TitreRelationFilter, TitreWhereInput>
    domaine?: XOR<DomaineNullableRelationFilter, DomaineWhereInput> | null
    lignee?: XOR<LigneeNullableRelationFilter, LigneeWhereInput> | null
  }, "id">

  export type PersonnageTitreOrderByWithAggregationInput = {
    id?: SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFin?: SortOrderInput | SortOrder
    estActif?: SortOrder
    personnageId?: SortOrder
    titreId?: SortOrder
    domaineId?: SortOrderInput | SortOrder
    ligneeId?: SortOrderInput | SortOrder
    _count?: PersonnageTitreCountOrderByAggregateInput
    _avg?: PersonnageTitreAvgOrderByAggregateInput
    _max?: PersonnageTitreMaxOrderByAggregateInput
    _min?: PersonnageTitreMinOrderByAggregateInput
    _sum?: PersonnageTitreSumOrderByAggregateInput
  }

  export type PersonnageTitreScalarWhereWithAggregatesInput = {
    AND?: PersonnageTitreScalarWhereWithAggregatesInput | PersonnageTitreScalarWhereWithAggregatesInput[]
    OR?: PersonnageTitreScalarWhereWithAggregatesInput[]
    NOT?: PersonnageTitreScalarWhereWithAggregatesInput | PersonnageTitreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PersonnageTitre"> | number
    dateDebut?: DateTimeNullableWithAggregatesFilter<"PersonnageTitre"> | Date | string | null
    dateFin?: DateTimeNullableWithAggregatesFilter<"PersonnageTitre"> | Date | string | null
    estActif?: BoolWithAggregatesFilter<"PersonnageTitre"> | boolean
    personnageId?: IntWithAggregatesFilter<"PersonnageTitre"> | number
    titreId?: IntWithAggregatesFilter<"PersonnageTitre"> | number
    domaineId?: IntNullableWithAggregatesFilter<"PersonnageTitre"> | number | null
    ligneeId?: IntNullableWithAggregatesFilter<"PersonnageTitre"> | number | null
  }

  export type VillageWhereInput = {
    AND?: VillageWhereInput | VillageWhereInput[]
    OR?: VillageWhereInput[]
    NOT?: VillageWhereInput | VillageWhereInput[]
    id?: IntFilter<"Village"> | number
    nom?: StringFilter<"Village"> | string
    localisation?: StringNullableFilter<"Village"> | string | null
    population?: IntNullableFilter<"Village"> | number | null
    ressourcePrincipale?: StringNullableFilter<"Village"> | string | null
    domaineId?: IntNullableFilter<"Village"> | number | null
    domaine?: XOR<DomaineNullableRelationFilter, DomaineWhereInput> | null
    inventaires?: InventaireListRelationFilter
  }

  export type VillageOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    localisation?: SortOrderInput | SortOrder
    population?: SortOrderInput | SortOrder
    ressourcePrincipale?: SortOrderInput | SortOrder
    domaineId?: SortOrderInput | SortOrder
    domaine?: DomaineOrderByWithRelationInput
    inventaires?: InventaireOrderByRelationAggregateInput
  }

  export type VillageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: VillageWhereInput | VillageWhereInput[]
    OR?: VillageWhereInput[]
    NOT?: VillageWhereInput | VillageWhereInput[]
    localisation?: StringNullableFilter<"Village"> | string | null
    population?: IntNullableFilter<"Village"> | number | null
    ressourcePrincipale?: StringNullableFilter<"Village"> | string | null
    domaineId?: IntNullableFilter<"Village"> | number | null
    domaine?: XOR<DomaineNullableRelationFilter, DomaineWhereInput> | null
    inventaires?: InventaireListRelationFilter
  }, "id" | "nom">

  export type VillageOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    localisation?: SortOrderInput | SortOrder
    population?: SortOrderInput | SortOrder
    ressourcePrincipale?: SortOrderInput | SortOrder
    domaineId?: SortOrderInput | SortOrder
    _count?: VillageCountOrderByAggregateInput
    _avg?: VillageAvgOrderByAggregateInput
    _max?: VillageMaxOrderByAggregateInput
    _min?: VillageMinOrderByAggregateInput
    _sum?: VillageSumOrderByAggregateInput
  }

  export type VillageScalarWhereWithAggregatesInput = {
    AND?: VillageScalarWhereWithAggregatesInput | VillageScalarWhereWithAggregatesInput[]
    OR?: VillageScalarWhereWithAggregatesInput[]
    NOT?: VillageScalarWhereWithAggregatesInput | VillageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Village"> | number
    nom?: StringWithAggregatesFilter<"Village"> | string
    localisation?: StringNullableWithAggregatesFilter<"Village"> | string | null
    population?: IntNullableWithAggregatesFilter<"Village"> | number | null
    ressourcePrincipale?: StringNullableWithAggregatesFilter<"Village"> | string | null
    domaineId?: IntNullableWithAggregatesFilter<"Village"> | number | null
  }

  export type GuildeWhereInput = {
    AND?: GuildeWhereInput | GuildeWhereInput[]
    OR?: GuildeWhereInput[]
    NOT?: GuildeWhereInput | GuildeWhereInput[]
    id?: IntFilter<"Guilde"> | number
    nom?: StringFilter<"Guilde"> | string
    specialite?: StringNullableFilter<"Guilde"> | string | null
    reputation?: StringNullableFilter<"Guilde"> | string | null
    membres?: GuildeMembreListRelationFilter
    batailles?: GuildeBatailleListRelationFilter
  }

  export type GuildeOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    specialite?: SortOrderInput | SortOrder
    reputation?: SortOrderInput | SortOrder
    membres?: GuildeMembreOrderByRelationAggregateInput
    batailles?: GuildeBatailleOrderByRelationAggregateInput
  }

  export type GuildeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: GuildeWhereInput | GuildeWhereInput[]
    OR?: GuildeWhereInput[]
    NOT?: GuildeWhereInput | GuildeWhereInput[]
    specialite?: StringNullableFilter<"Guilde"> | string | null
    reputation?: StringNullableFilter<"Guilde"> | string | null
    membres?: GuildeMembreListRelationFilter
    batailles?: GuildeBatailleListRelationFilter
  }, "id" | "nom">

  export type GuildeOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    specialite?: SortOrderInput | SortOrder
    reputation?: SortOrderInput | SortOrder
    _count?: GuildeCountOrderByAggregateInput
    _avg?: GuildeAvgOrderByAggregateInput
    _max?: GuildeMaxOrderByAggregateInput
    _min?: GuildeMinOrderByAggregateInput
    _sum?: GuildeSumOrderByAggregateInput
  }

  export type GuildeScalarWhereWithAggregatesInput = {
    AND?: GuildeScalarWhereWithAggregatesInput | GuildeScalarWhereWithAggregatesInput[]
    OR?: GuildeScalarWhereWithAggregatesInput[]
    NOT?: GuildeScalarWhereWithAggregatesInput | GuildeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Guilde"> | number
    nom?: StringWithAggregatesFilter<"Guilde"> | string
    specialite?: StringNullableWithAggregatesFilter<"Guilde"> | string | null
    reputation?: StringNullableWithAggregatesFilter<"Guilde"> | string | null
  }

  export type GuildeMembreWhereInput = {
    AND?: GuildeMembreWhereInput | GuildeMembreWhereInput[]
    OR?: GuildeMembreWhereInput[]
    NOT?: GuildeMembreWhereInput | GuildeMembreWhereInput[]
    personnageId?: IntFilter<"GuildeMembre"> | number
    guildeId?: IntFilter<"GuildeMembre"> | number
    dateEntree?: DateTimeNullableFilter<"GuildeMembre"> | Date | string | null
    dateSortie?: DateTimeNullableFilter<"GuildeMembre"> | Date | string | null
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    guilde?: XOR<GuildeRelationFilter, GuildeWhereInput>
  }

  export type GuildeMembreOrderByWithRelationInput = {
    personnageId?: SortOrder
    guildeId?: SortOrder
    dateEntree?: SortOrderInput | SortOrder
    dateSortie?: SortOrderInput | SortOrder
    personnage?: PersonnageOrderByWithRelationInput
    guilde?: GuildeOrderByWithRelationInput
  }

  export type GuildeMembreWhereUniqueInput = Prisma.AtLeast<{
    personnageId_guildeId?: GuildeMembrePersonnageIdGuildeIdCompoundUniqueInput
    AND?: GuildeMembreWhereInput | GuildeMembreWhereInput[]
    OR?: GuildeMembreWhereInput[]
    NOT?: GuildeMembreWhereInput | GuildeMembreWhereInput[]
    personnageId?: IntFilter<"GuildeMembre"> | number
    guildeId?: IntFilter<"GuildeMembre"> | number
    dateEntree?: DateTimeNullableFilter<"GuildeMembre"> | Date | string | null
    dateSortie?: DateTimeNullableFilter<"GuildeMembre"> | Date | string | null
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    guilde?: XOR<GuildeRelationFilter, GuildeWhereInput>
  }, "personnageId_guildeId">

  export type GuildeMembreOrderByWithAggregationInput = {
    personnageId?: SortOrder
    guildeId?: SortOrder
    dateEntree?: SortOrderInput | SortOrder
    dateSortie?: SortOrderInput | SortOrder
    _count?: GuildeMembreCountOrderByAggregateInput
    _avg?: GuildeMembreAvgOrderByAggregateInput
    _max?: GuildeMembreMaxOrderByAggregateInput
    _min?: GuildeMembreMinOrderByAggregateInput
    _sum?: GuildeMembreSumOrderByAggregateInput
  }

  export type GuildeMembreScalarWhereWithAggregatesInput = {
    AND?: GuildeMembreScalarWhereWithAggregatesInput | GuildeMembreScalarWhereWithAggregatesInput[]
    OR?: GuildeMembreScalarWhereWithAggregatesInput[]
    NOT?: GuildeMembreScalarWhereWithAggregatesInput | GuildeMembreScalarWhereWithAggregatesInput[]
    personnageId?: IntWithAggregatesFilter<"GuildeMembre"> | number
    guildeId?: IntWithAggregatesFilter<"GuildeMembre"> | number
    dateEntree?: DateTimeNullableWithAggregatesFilter<"GuildeMembre"> | Date | string | null
    dateSortie?: DateTimeNullableWithAggregatesFilter<"GuildeMembre"> | Date | string | null
  }

  export type CreatureWhereInput = {
    AND?: CreatureWhereInput | CreatureWhereInput[]
    OR?: CreatureWhereInput[]
    NOT?: CreatureWhereInput | CreatureWhereInput[]
    id?: IntFilter<"Creature"> | number
    espece?: StringFilter<"Creature"> | string
    forces?: StringNullableFilter<"Creature"> | string | null
    faiblesses?: StringNullableFilter<"Creature"> | string | null
    dangerosite?: StringNullableFilter<"Creature"> | string | null
    batailles?: CreatureBatailleListRelationFilter
  }

  export type CreatureOrderByWithRelationInput = {
    id?: SortOrder
    espece?: SortOrder
    forces?: SortOrderInput | SortOrder
    faiblesses?: SortOrderInput | SortOrder
    dangerosite?: SortOrderInput | SortOrder
    batailles?: CreatureBatailleOrderByRelationAggregateInput
  }

  export type CreatureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    espece?: string
    AND?: CreatureWhereInput | CreatureWhereInput[]
    OR?: CreatureWhereInput[]
    NOT?: CreatureWhereInput | CreatureWhereInput[]
    forces?: StringNullableFilter<"Creature"> | string | null
    faiblesses?: StringNullableFilter<"Creature"> | string | null
    dangerosite?: StringNullableFilter<"Creature"> | string | null
    batailles?: CreatureBatailleListRelationFilter
  }, "id" | "espece">

  export type CreatureOrderByWithAggregationInput = {
    id?: SortOrder
    espece?: SortOrder
    forces?: SortOrderInput | SortOrder
    faiblesses?: SortOrderInput | SortOrder
    dangerosite?: SortOrderInput | SortOrder
    _count?: CreatureCountOrderByAggregateInput
    _avg?: CreatureAvgOrderByAggregateInput
    _max?: CreatureMaxOrderByAggregateInput
    _min?: CreatureMinOrderByAggregateInput
    _sum?: CreatureSumOrderByAggregateInput
  }

  export type CreatureScalarWhereWithAggregatesInput = {
    AND?: CreatureScalarWhereWithAggregatesInput | CreatureScalarWhereWithAggregatesInput[]
    OR?: CreatureScalarWhereWithAggregatesInput[]
    NOT?: CreatureScalarWhereWithAggregatesInput | CreatureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Creature"> | number
    espece?: StringWithAggregatesFilter<"Creature"> | string
    forces?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    faiblesses?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    dangerosite?: StringNullableWithAggregatesFilter<"Creature"> | string | null
  }

  export type EcoleMagieWhereInput = {
    AND?: EcoleMagieWhereInput | EcoleMagieWhereInput[]
    OR?: EcoleMagieWhereInput[]
    NOT?: EcoleMagieWhereInput | EcoleMagieWhereInput[]
    id?: IntFilter<"EcoleMagie"> | number
    nom?: StringFilter<"EcoleMagie"> | string
    sorts?: SortListRelationFilter
  }

  export type EcoleMagieOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    sorts?: SortOrderByRelationAggregateInput
  }

  export type EcoleMagieWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: EcoleMagieWhereInput | EcoleMagieWhereInput[]
    OR?: EcoleMagieWhereInput[]
    NOT?: EcoleMagieWhereInput | EcoleMagieWhereInput[]
    sorts?: SortListRelationFilter
  }, "id" | "nom">

  export type EcoleMagieOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    _count?: EcoleMagieCountOrderByAggregateInput
    _avg?: EcoleMagieAvgOrderByAggregateInput
    _max?: EcoleMagieMaxOrderByAggregateInput
    _min?: EcoleMagieMinOrderByAggregateInput
    _sum?: EcoleMagieSumOrderByAggregateInput
  }

  export type EcoleMagieScalarWhereWithAggregatesInput = {
    AND?: EcoleMagieScalarWhereWithAggregatesInput | EcoleMagieScalarWhereWithAggregatesInput[]
    OR?: EcoleMagieScalarWhereWithAggregatesInput[]
    NOT?: EcoleMagieScalarWhereWithAggregatesInput | EcoleMagieScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EcoleMagie"> | number
    nom?: StringWithAggregatesFilter<"EcoleMagie"> | string
  }

  export type SortWhereInput = {
    AND?: SortWhereInput | SortWhereInput[]
    OR?: SortWhereInput[]
    NOT?: SortWhereInput | SortWhereInput[]
    id?: IntFilter<"Sort"> | number
    nom?: StringFilter<"Sort"> | string
    element?: StringNullableFilter<"Sort"> | string | null
    coutMana?: IntNullableFilter<"Sort"> | number | null
    niveauRequis?: StringNullableFilter<"Sort"> | string | null
    estInterdit?: BoolFilter<"Sort"> | boolean
    estRituel?: BoolFilter<"Sort"> | boolean
    ecoleId?: IntNullableFilter<"Sort"> | number | null
    ecole?: XOR<EcoleMagieNullableRelationFilter, EcoleMagieWhereInput> | null
  }

  export type SortOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    element?: SortOrderInput | SortOrder
    coutMana?: SortOrderInput | SortOrder
    niveauRequis?: SortOrderInput | SortOrder
    estInterdit?: SortOrder
    estRituel?: SortOrder
    ecoleId?: SortOrderInput | SortOrder
    ecole?: EcoleMagieOrderByWithRelationInput
  }

  export type SortWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: SortWhereInput | SortWhereInput[]
    OR?: SortWhereInput[]
    NOT?: SortWhereInput | SortWhereInput[]
    element?: StringNullableFilter<"Sort"> | string | null
    coutMana?: IntNullableFilter<"Sort"> | number | null
    niveauRequis?: StringNullableFilter<"Sort"> | string | null
    estInterdit?: BoolFilter<"Sort"> | boolean
    estRituel?: BoolFilter<"Sort"> | boolean
    ecoleId?: IntNullableFilter<"Sort"> | number | null
    ecole?: XOR<EcoleMagieNullableRelationFilter, EcoleMagieWhereInput> | null
  }, "id" | "nom">

  export type SortOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    element?: SortOrderInput | SortOrder
    coutMana?: SortOrderInput | SortOrder
    niveauRequis?: SortOrderInput | SortOrder
    estInterdit?: SortOrder
    estRituel?: SortOrder
    ecoleId?: SortOrderInput | SortOrder
    _count?: SortCountOrderByAggregateInput
    _avg?: SortAvgOrderByAggregateInput
    _max?: SortMaxOrderByAggregateInput
    _min?: SortMinOrderByAggregateInput
    _sum?: SortSumOrderByAggregateInput
  }

  export type SortScalarWhereWithAggregatesInput = {
    AND?: SortScalarWhereWithAggregatesInput | SortScalarWhereWithAggregatesInput[]
    OR?: SortScalarWhereWithAggregatesInput[]
    NOT?: SortScalarWhereWithAggregatesInput | SortScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sort"> | number
    nom?: StringWithAggregatesFilter<"Sort"> | string
    element?: StringNullableWithAggregatesFilter<"Sort"> | string | null
    coutMana?: IntNullableWithAggregatesFilter<"Sort"> | number | null
    niveauRequis?: StringNullableWithAggregatesFilter<"Sort"> | string | null
    estInterdit?: BoolWithAggregatesFilter<"Sort"> | boolean
    estRituel?: BoolWithAggregatesFilter<"Sort"> | boolean
    ecoleId?: IntNullableWithAggregatesFilter<"Sort"> | number | null
  }

  export type MaladieWhereInput = {
    AND?: MaladieWhereInput | MaladieWhereInput[]
    OR?: MaladieWhereInput[]
    NOT?: MaladieWhereInput | MaladieWhereInput[]
    id?: IntFilter<"Maladie"> | number
    nom?: StringFilter<"Maladie"> | string
    effets?: StringNullableFilter<"Maladie"> | string | null
    contagion?: StringNullableFilter<"Maladie"> | string | null
    remede?: StringNullableFilter<"Maladie"> | string | null
    tauxMortalite?: FloatNullableFilter<"Maladie"> | number | null
    cas?: PersonnageMaladieListRelationFilter
  }

  export type MaladieOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    effets?: SortOrderInput | SortOrder
    contagion?: SortOrderInput | SortOrder
    remede?: SortOrderInput | SortOrder
    tauxMortalite?: SortOrderInput | SortOrder
    cas?: PersonnageMaladieOrderByRelationAggregateInput
  }

  export type MaladieWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: MaladieWhereInput | MaladieWhereInput[]
    OR?: MaladieWhereInput[]
    NOT?: MaladieWhereInput | MaladieWhereInput[]
    effets?: StringNullableFilter<"Maladie"> | string | null
    contagion?: StringNullableFilter<"Maladie"> | string | null
    remede?: StringNullableFilter<"Maladie"> | string | null
    tauxMortalite?: FloatNullableFilter<"Maladie"> | number | null
    cas?: PersonnageMaladieListRelationFilter
  }, "id" | "nom">

  export type MaladieOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    effets?: SortOrderInput | SortOrder
    contagion?: SortOrderInput | SortOrder
    remede?: SortOrderInput | SortOrder
    tauxMortalite?: SortOrderInput | SortOrder
    _count?: MaladieCountOrderByAggregateInput
    _avg?: MaladieAvgOrderByAggregateInput
    _max?: MaladieMaxOrderByAggregateInput
    _min?: MaladieMinOrderByAggregateInput
    _sum?: MaladieSumOrderByAggregateInput
  }

  export type MaladieScalarWhereWithAggregatesInput = {
    AND?: MaladieScalarWhereWithAggregatesInput | MaladieScalarWhereWithAggregatesInput[]
    OR?: MaladieScalarWhereWithAggregatesInput[]
    NOT?: MaladieScalarWhereWithAggregatesInput | MaladieScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Maladie"> | number
    nom?: StringWithAggregatesFilter<"Maladie"> | string
    effets?: StringNullableWithAggregatesFilter<"Maladie"> | string | null
    contagion?: StringNullableWithAggregatesFilter<"Maladie"> | string | null
    remede?: StringNullableWithAggregatesFilter<"Maladie"> | string | null
    tauxMortalite?: FloatNullableWithAggregatesFilter<"Maladie"> | number | null
  }

  export type PersonnageMaladieWhereInput = {
    AND?: PersonnageMaladieWhereInput | PersonnageMaladieWhereInput[]
    OR?: PersonnageMaladieWhereInput[]
    NOT?: PersonnageMaladieWhereInput | PersonnageMaladieWhereInput[]
    personnageId?: IntFilter<"PersonnageMaladie"> | number
    maladieId?: IntFilter<"PersonnageMaladie"> | number
    dateDebut?: DateTimeFilter<"PersonnageMaladie"> | Date | string
    dateFin?: DateTimeNullableFilter<"PersonnageMaladie"> | Date | string | null
    issue?: StringNullableFilter<"PersonnageMaladie"> | string | null
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    maladie?: XOR<MaladieRelationFilter, MaladieWhereInput>
  }

  export type PersonnageMaladieOrderByWithRelationInput = {
    personnageId?: SortOrder
    maladieId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrderInput | SortOrder
    issue?: SortOrderInput | SortOrder
    personnage?: PersonnageOrderByWithRelationInput
    maladie?: MaladieOrderByWithRelationInput
  }

  export type PersonnageMaladieWhereUniqueInput = Prisma.AtLeast<{
    personnageId_maladieId_dateDebut?: PersonnageMaladiePersonnageIdMaladieIdDateDebutCompoundUniqueInput
    AND?: PersonnageMaladieWhereInput | PersonnageMaladieWhereInput[]
    OR?: PersonnageMaladieWhereInput[]
    NOT?: PersonnageMaladieWhereInput | PersonnageMaladieWhereInput[]
    personnageId?: IntFilter<"PersonnageMaladie"> | number
    maladieId?: IntFilter<"PersonnageMaladie"> | number
    dateDebut?: DateTimeFilter<"PersonnageMaladie"> | Date | string
    dateFin?: DateTimeNullableFilter<"PersonnageMaladie"> | Date | string | null
    issue?: StringNullableFilter<"PersonnageMaladie"> | string | null
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    maladie?: XOR<MaladieRelationFilter, MaladieWhereInput>
  }, "personnageId_maladieId_dateDebut">

  export type PersonnageMaladieOrderByWithAggregationInput = {
    personnageId?: SortOrder
    maladieId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrderInput | SortOrder
    issue?: SortOrderInput | SortOrder
    _count?: PersonnageMaladieCountOrderByAggregateInput
    _avg?: PersonnageMaladieAvgOrderByAggregateInput
    _max?: PersonnageMaladieMaxOrderByAggregateInput
    _min?: PersonnageMaladieMinOrderByAggregateInput
    _sum?: PersonnageMaladieSumOrderByAggregateInput
  }

  export type PersonnageMaladieScalarWhereWithAggregatesInput = {
    AND?: PersonnageMaladieScalarWhereWithAggregatesInput | PersonnageMaladieScalarWhereWithAggregatesInput[]
    OR?: PersonnageMaladieScalarWhereWithAggregatesInput[]
    NOT?: PersonnageMaladieScalarWhereWithAggregatesInput | PersonnageMaladieScalarWhereWithAggregatesInput[]
    personnageId?: IntWithAggregatesFilter<"PersonnageMaladie"> | number
    maladieId?: IntWithAggregatesFilter<"PersonnageMaladie"> | number
    dateDebut?: DateTimeWithAggregatesFilter<"PersonnageMaladie"> | Date | string
    dateFin?: DateTimeNullableWithAggregatesFilter<"PersonnageMaladie"> | Date | string | null
    issue?: StringNullableWithAggregatesFilter<"PersonnageMaladie"> | string | null
  }

  export type ArmeeWhereInput = {
    AND?: ArmeeWhereInput | ArmeeWhereInput[]
    OR?: ArmeeWhereInput[]
    NOT?: ArmeeWhereInput | ArmeeWhereInput[]
    id?: IntFilter<"Armee"> | number
    nom?: StringNullableFilter<"Armee"> | string | null
    effectif?: IntNullableFilter<"Armee"> | number | null
    composition?: StringNullableFilter<"Armee"> | string | null
    moral?: StringNullableFilter<"Armee"> | string | null
    etatApprovisionnement?: StringNullableFilter<"Armee"> | string | null
    domaineId?: IntNullableFilter<"Armee"> | number | null
    commandantId?: IntNullableFilter<"Armee"> | number | null
    domaine?: XOR<DomaineNullableRelationFilter, DomaineWhereInput> | null
    commandant?: XOR<PersonnageNullableRelationFilter, PersonnageWhereInput> | null
    batailles?: ArmeeBatailleListRelationFilter
    inventaires?: InventaireListRelationFilter
  }

  export type ArmeeOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrderInput | SortOrder
    effectif?: SortOrderInput | SortOrder
    composition?: SortOrderInput | SortOrder
    moral?: SortOrderInput | SortOrder
    etatApprovisionnement?: SortOrderInput | SortOrder
    domaineId?: SortOrderInput | SortOrder
    commandantId?: SortOrderInput | SortOrder
    domaine?: DomaineOrderByWithRelationInput
    commandant?: PersonnageOrderByWithRelationInput
    batailles?: ArmeeBatailleOrderByRelationAggregateInput
    inventaires?: InventaireOrderByRelationAggregateInput
  }

  export type ArmeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ArmeeWhereInput | ArmeeWhereInput[]
    OR?: ArmeeWhereInput[]
    NOT?: ArmeeWhereInput | ArmeeWhereInput[]
    nom?: StringNullableFilter<"Armee"> | string | null
    effectif?: IntNullableFilter<"Armee"> | number | null
    composition?: StringNullableFilter<"Armee"> | string | null
    moral?: StringNullableFilter<"Armee"> | string | null
    etatApprovisionnement?: StringNullableFilter<"Armee"> | string | null
    domaineId?: IntNullableFilter<"Armee"> | number | null
    commandantId?: IntNullableFilter<"Armee"> | number | null
    domaine?: XOR<DomaineNullableRelationFilter, DomaineWhereInput> | null
    commandant?: XOR<PersonnageNullableRelationFilter, PersonnageWhereInput> | null
    batailles?: ArmeeBatailleListRelationFilter
    inventaires?: InventaireListRelationFilter
  }, "id">

  export type ArmeeOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrderInput | SortOrder
    effectif?: SortOrderInput | SortOrder
    composition?: SortOrderInput | SortOrder
    moral?: SortOrderInput | SortOrder
    etatApprovisionnement?: SortOrderInput | SortOrder
    domaineId?: SortOrderInput | SortOrder
    commandantId?: SortOrderInput | SortOrder
    _count?: ArmeeCountOrderByAggregateInput
    _avg?: ArmeeAvgOrderByAggregateInput
    _max?: ArmeeMaxOrderByAggregateInput
    _min?: ArmeeMinOrderByAggregateInput
    _sum?: ArmeeSumOrderByAggregateInput
  }

  export type ArmeeScalarWhereWithAggregatesInput = {
    AND?: ArmeeScalarWhereWithAggregatesInput | ArmeeScalarWhereWithAggregatesInput[]
    OR?: ArmeeScalarWhereWithAggregatesInput[]
    NOT?: ArmeeScalarWhereWithAggregatesInput | ArmeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Armee"> | number
    nom?: StringNullableWithAggregatesFilter<"Armee"> | string | null
    effectif?: IntNullableWithAggregatesFilter<"Armee"> | number | null
    composition?: StringNullableWithAggregatesFilter<"Armee"> | string | null
    moral?: StringNullableWithAggregatesFilter<"Armee"> | string | null
    etatApprovisionnement?: StringNullableWithAggregatesFilter<"Armee"> | string | null
    domaineId?: IntNullableWithAggregatesFilter<"Armee"> | number | null
    commandantId?: IntNullableWithAggregatesFilter<"Armee"> | number | null
  }

  export type BatailleWhereInput = {
    AND?: BatailleWhereInput | BatailleWhereInput[]
    OR?: BatailleWhereInput[]
    NOT?: BatailleWhereInput | BatailleWhereInput[]
    id?: IntFilter<"Bataille"> | number
    nom?: StringNullableFilter<"Bataille"> | string | null
    dateBataille?: DateTimeNullableFilter<"Bataille"> | Date | string | null
    lieu?: StringNullableFilter<"Bataille"> | string | null
    pertesA?: IntNullableFilter<"Bataille"> | number | null
    pertesB?: IntNullableFilter<"Bataille"> | number | null
    vainqueurTexte?: StringNullableFilter<"Bataille"> | string | null
    armees?: ArmeeBatailleListRelationFilter
    guildes?: GuildeBatailleListRelationFilter
    creatures?: CreatureBatailleListRelationFilter
  }

  export type BatailleOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrderInput | SortOrder
    dateBataille?: SortOrderInput | SortOrder
    lieu?: SortOrderInput | SortOrder
    pertesA?: SortOrderInput | SortOrder
    pertesB?: SortOrderInput | SortOrder
    vainqueurTexte?: SortOrderInput | SortOrder
    armees?: ArmeeBatailleOrderByRelationAggregateInput
    guildes?: GuildeBatailleOrderByRelationAggregateInput
    creatures?: CreatureBatailleOrderByRelationAggregateInput
  }

  export type BatailleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BatailleWhereInput | BatailleWhereInput[]
    OR?: BatailleWhereInput[]
    NOT?: BatailleWhereInput | BatailleWhereInput[]
    nom?: StringNullableFilter<"Bataille"> | string | null
    dateBataille?: DateTimeNullableFilter<"Bataille"> | Date | string | null
    lieu?: StringNullableFilter<"Bataille"> | string | null
    pertesA?: IntNullableFilter<"Bataille"> | number | null
    pertesB?: IntNullableFilter<"Bataille"> | number | null
    vainqueurTexte?: StringNullableFilter<"Bataille"> | string | null
    armees?: ArmeeBatailleListRelationFilter
    guildes?: GuildeBatailleListRelationFilter
    creatures?: CreatureBatailleListRelationFilter
  }, "id">

  export type BatailleOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrderInput | SortOrder
    dateBataille?: SortOrderInput | SortOrder
    lieu?: SortOrderInput | SortOrder
    pertesA?: SortOrderInput | SortOrder
    pertesB?: SortOrderInput | SortOrder
    vainqueurTexte?: SortOrderInput | SortOrder
    _count?: BatailleCountOrderByAggregateInput
    _avg?: BatailleAvgOrderByAggregateInput
    _max?: BatailleMaxOrderByAggregateInput
    _min?: BatailleMinOrderByAggregateInput
    _sum?: BatailleSumOrderByAggregateInput
  }

  export type BatailleScalarWhereWithAggregatesInput = {
    AND?: BatailleScalarWhereWithAggregatesInput | BatailleScalarWhereWithAggregatesInput[]
    OR?: BatailleScalarWhereWithAggregatesInput[]
    NOT?: BatailleScalarWhereWithAggregatesInput | BatailleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bataille"> | number
    nom?: StringNullableWithAggregatesFilter<"Bataille"> | string | null
    dateBataille?: DateTimeNullableWithAggregatesFilter<"Bataille"> | Date | string | null
    lieu?: StringNullableWithAggregatesFilter<"Bataille"> | string | null
    pertesA?: IntNullableWithAggregatesFilter<"Bataille"> | number | null
    pertesB?: IntNullableWithAggregatesFilter<"Bataille"> | number | null
    vainqueurTexte?: StringNullableWithAggregatesFilter<"Bataille"> | string | null
  }

  export type ArmeeBatailleWhereInput = {
    AND?: ArmeeBatailleWhereInput | ArmeeBatailleWhereInput[]
    OR?: ArmeeBatailleWhereInput[]
    NOT?: ArmeeBatailleWhereInput | ArmeeBatailleWhereInput[]
    armeeId?: IntFilter<"ArmeeBataille"> | number
    batailleId?: IntFilter<"ArmeeBataille"> | number
    cote?: StringNullableFilter<"ArmeeBataille"> | string | null
    pertes?: IntNullableFilter<"ArmeeBataille"> | number | null
    armee?: XOR<ArmeeRelationFilter, ArmeeWhereInput>
    bataille?: XOR<BatailleRelationFilter, BatailleWhereInput>
  }

  export type ArmeeBatailleOrderByWithRelationInput = {
    armeeId?: SortOrder
    batailleId?: SortOrder
    cote?: SortOrderInput | SortOrder
    pertes?: SortOrderInput | SortOrder
    armee?: ArmeeOrderByWithRelationInput
    bataille?: BatailleOrderByWithRelationInput
  }

  export type ArmeeBatailleWhereUniqueInput = Prisma.AtLeast<{
    armeeId_batailleId?: ArmeeBatailleArmeeIdBatailleIdCompoundUniqueInput
    AND?: ArmeeBatailleWhereInput | ArmeeBatailleWhereInput[]
    OR?: ArmeeBatailleWhereInput[]
    NOT?: ArmeeBatailleWhereInput | ArmeeBatailleWhereInput[]
    armeeId?: IntFilter<"ArmeeBataille"> | number
    batailleId?: IntFilter<"ArmeeBataille"> | number
    cote?: StringNullableFilter<"ArmeeBataille"> | string | null
    pertes?: IntNullableFilter<"ArmeeBataille"> | number | null
    armee?: XOR<ArmeeRelationFilter, ArmeeWhereInput>
    bataille?: XOR<BatailleRelationFilter, BatailleWhereInput>
  }, "armeeId_batailleId">

  export type ArmeeBatailleOrderByWithAggregationInput = {
    armeeId?: SortOrder
    batailleId?: SortOrder
    cote?: SortOrderInput | SortOrder
    pertes?: SortOrderInput | SortOrder
    _count?: ArmeeBatailleCountOrderByAggregateInput
    _avg?: ArmeeBatailleAvgOrderByAggregateInput
    _max?: ArmeeBatailleMaxOrderByAggregateInput
    _min?: ArmeeBatailleMinOrderByAggregateInput
    _sum?: ArmeeBatailleSumOrderByAggregateInput
  }

  export type ArmeeBatailleScalarWhereWithAggregatesInput = {
    AND?: ArmeeBatailleScalarWhereWithAggregatesInput | ArmeeBatailleScalarWhereWithAggregatesInput[]
    OR?: ArmeeBatailleScalarWhereWithAggregatesInput[]
    NOT?: ArmeeBatailleScalarWhereWithAggregatesInput | ArmeeBatailleScalarWhereWithAggregatesInput[]
    armeeId?: IntWithAggregatesFilter<"ArmeeBataille"> | number
    batailleId?: IntWithAggregatesFilter<"ArmeeBataille"> | number
    cote?: StringNullableWithAggregatesFilter<"ArmeeBataille"> | string | null
    pertes?: IntNullableWithAggregatesFilter<"ArmeeBataille"> | number | null
  }

  export type GuildeBatailleWhereInput = {
    AND?: GuildeBatailleWhereInput | GuildeBatailleWhereInput[]
    OR?: GuildeBatailleWhereInput[]
    NOT?: GuildeBatailleWhereInput | GuildeBatailleWhereInput[]
    guildeId?: IntFilter<"GuildeBataille"> | number
    batailleId?: IntFilter<"GuildeBataille"> | number
    role?: StringNullableFilter<"GuildeBataille"> | string | null
    guilde?: XOR<GuildeRelationFilter, GuildeWhereInput>
    bataille?: XOR<BatailleRelationFilter, BatailleWhereInput>
  }

  export type GuildeBatailleOrderByWithRelationInput = {
    guildeId?: SortOrder
    batailleId?: SortOrder
    role?: SortOrderInput | SortOrder
    guilde?: GuildeOrderByWithRelationInput
    bataille?: BatailleOrderByWithRelationInput
  }

  export type GuildeBatailleWhereUniqueInput = Prisma.AtLeast<{
    guildeId_batailleId?: GuildeBatailleGuildeIdBatailleIdCompoundUniqueInput
    AND?: GuildeBatailleWhereInput | GuildeBatailleWhereInput[]
    OR?: GuildeBatailleWhereInput[]
    NOT?: GuildeBatailleWhereInput | GuildeBatailleWhereInput[]
    guildeId?: IntFilter<"GuildeBataille"> | number
    batailleId?: IntFilter<"GuildeBataille"> | number
    role?: StringNullableFilter<"GuildeBataille"> | string | null
    guilde?: XOR<GuildeRelationFilter, GuildeWhereInput>
    bataille?: XOR<BatailleRelationFilter, BatailleWhereInput>
  }, "guildeId_batailleId">

  export type GuildeBatailleOrderByWithAggregationInput = {
    guildeId?: SortOrder
    batailleId?: SortOrder
    role?: SortOrderInput | SortOrder
    _count?: GuildeBatailleCountOrderByAggregateInput
    _avg?: GuildeBatailleAvgOrderByAggregateInput
    _max?: GuildeBatailleMaxOrderByAggregateInput
    _min?: GuildeBatailleMinOrderByAggregateInput
    _sum?: GuildeBatailleSumOrderByAggregateInput
  }

  export type GuildeBatailleScalarWhereWithAggregatesInput = {
    AND?: GuildeBatailleScalarWhereWithAggregatesInput | GuildeBatailleScalarWhereWithAggregatesInput[]
    OR?: GuildeBatailleScalarWhereWithAggregatesInput[]
    NOT?: GuildeBatailleScalarWhereWithAggregatesInput | GuildeBatailleScalarWhereWithAggregatesInput[]
    guildeId?: IntWithAggregatesFilter<"GuildeBataille"> | number
    batailleId?: IntWithAggregatesFilter<"GuildeBataille"> | number
    role?: StringNullableWithAggregatesFilter<"GuildeBataille"> | string | null
  }

  export type CreatureBatailleWhereInput = {
    AND?: CreatureBatailleWhereInput | CreatureBatailleWhereInput[]
    OR?: CreatureBatailleWhereInput[]
    NOT?: CreatureBatailleWhereInput | CreatureBatailleWhereInput[]
    creatureId?: IntFilter<"CreatureBataille"> | number
    batailleId?: IntFilter<"CreatureBataille"> | number
    nombre?: IntNullableFilter<"CreatureBataille"> | number | null
    role?: StringNullableFilter<"CreatureBataille"> | string | null
    creature?: XOR<CreatureRelationFilter, CreatureWhereInput>
    bataille?: XOR<BatailleRelationFilter, BatailleWhereInput>
  }

  export type CreatureBatailleOrderByWithRelationInput = {
    creatureId?: SortOrder
    batailleId?: SortOrder
    nombre?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    creature?: CreatureOrderByWithRelationInput
    bataille?: BatailleOrderByWithRelationInput
  }

  export type CreatureBatailleWhereUniqueInput = Prisma.AtLeast<{
    creatureId_batailleId?: CreatureBatailleCreatureIdBatailleIdCompoundUniqueInput
    AND?: CreatureBatailleWhereInput | CreatureBatailleWhereInput[]
    OR?: CreatureBatailleWhereInput[]
    NOT?: CreatureBatailleWhereInput | CreatureBatailleWhereInput[]
    creatureId?: IntFilter<"CreatureBataille"> | number
    batailleId?: IntFilter<"CreatureBataille"> | number
    nombre?: IntNullableFilter<"CreatureBataille"> | number | null
    role?: StringNullableFilter<"CreatureBataille"> | string | null
    creature?: XOR<CreatureRelationFilter, CreatureWhereInput>
    bataille?: XOR<BatailleRelationFilter, BatailleWhereInput>
  }, "creatureId_batailleId">

  export type CreatureBatailleOrderByWithAggregationInput = {
    creatureId?: SortOrder
    batailleId?: SortOrder
    nombre?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    _count?: CreatureBatailleCountOrderByAggregateInput
    _avg?: CreatureBatailleAvgOrderByAggregateInput
    _max?: CreatureBatailleMaxOrderByAggregateInput
    _min?: CreatureBatailleMinOrderByAggregateInput
    _sum?: CreatureBatailleSumOrderByAggregateInput
  }

  export type CreatureBatailleScalarWhereWithAggregatesInput = {
    AND?: CreatureBatailleScalarWhereWithAggregatesInput | CreatureBatailleScalarWhereWithAggregatesInput[]
    OR?: CreatureBatailleScalarWhereWithAggregatesInput[]
    NOT?: CreatureBatailleScalarWhereWithAggregatesInput | CreatureBatailleScalarWhereWithAggregatesInput[]
    creatureId?: IntWithAggregatesFilter<"CreatureBataille"> | number
    batailleId?: IntWithAggregatesFilter<"CreatureBataille"> | number
    nombre?: IntNullableWithAggregatesFilter<"CreatureBataille"> | number | null
    role?: StringNullableWithAggregatesFilter<"CreatureBataille"> | string | null
  }

  export type EquipementWhereInput = {
    AND?: EquipementWhereInput | EquipementWhereInput[]
    OR?: EquipementWhereInput[]
    NOT?: EquipementWhereInput | EquipementWhereInput[]
    id?: IntFilter<"Equipement"> | number
    nom?: StringFilter<"Equipement"> | string
    typeEquipement?: StringNullableFilter<"Equipement"> | string | null
    materiaux?: StringNullableFilter<"Equipement"> | string | null
    rarete?: StringNullableFilter<"Equipement"> | string | null
    enchantements?: StringNullableFilter<"Equipement"> | string | null
    affiniteRequise?: StringNullableFilter<"Equipement"> | string | null
    possesseurs?: PersonnageEquipementListRelationFilter
  }

  export type EquipementOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    typeEquipement?: SortOrderInput | SortOrder
    materiaux?: SortOrderInput | SortOrder
    rarete?: SortOrderInput | SortOrder
    enchantements?: SortOrderInput | SortOrder
    affiniteRequise?: SortOrderInput | SortOrder
    possesseurs?: PersonnageEquipementOrderByRelationAggregateInput
  }

  export type EquipementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: EquipementWhereInput | EquipementWhereInput[]
    OR?: EquipementWhereInput[]
    NOT?: EquipementWhereInput | EquipementWhereInput[]
    typeEquipement?: StringNullableFilter<"Equipement"> | string | null
    materiaux?: StringNullableFilter<"Equipement"> | string | null
    rarete?: StringNullableFilter<"Equipement"> | string | null
    enchantements?: StringNullableFilter<"Equipement"> | string | null
    affiniteRequise?: StringNullableFilter<"Equipement"> | string | null
    possesseurs?: PersonnageEquipementListRelationFilter
  }, "id" | "nom">

  export type EquipementOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    typeEquipement?: SortOrderInput | SortOrder
    materiaux?: SortOrderInput | SortOrder
    rarete?: SortOrderInput | SortOrder
    enchantements?: SortOrderInput | SortOrder
    affiniteRequise?: SortOrderInput | SortOrder
    _count?: EquipementCountOrderByAggregateInput
    _avg?: EquipementAvgOrderByAggregateInput
    _max?: EquipementMaxOrderByAggregateInput
    _min?: EquipementMinOrderByAggregateInput
    _sum?: EquipementSumOrderByAggregateInput
  }

  export type EquipementScalarWhereWithAggregatesInput = {
    AND?: EquipementScalarWhereWithAggregatesInput | EquipementScalarWhereWithAggregatesInput[]
    OR?: EquipementScalarWhereWithAggregatesInput[]
    NOT?: EquipementScalarWhereWithAggregatesInput | EquipementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Equipement"> | number
    nom?: StringWithAggregatesFilter<"Equipement"> | string
    typeEquipement?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    materiaux?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    rarete?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    enchantements?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    affiniteRequise?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
  }

  export type PersonnageEquipementWhereInput = {
    AND?: PersonnageEquipementWhereInput | PersonnageEquipementWhereInput[]
    OR?: PersonnageEquipementWhereInput[]
    NOT?: PersonnageEquipementWhereInput | PersonnageEquipementWhereInput[]
    personnageId?: IntFilter<"PersonnageEquipement"> | number
    equipementId?: IntFilter<"PersonnageEquipement"> | number
    dateAcquisition?: DateTimeNullableFilter<"PersonnageEquipement"> | Date | string | null
    source?: StringNullableFilter<"PersonnageEquipement"> | string | null
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    equipement?: XOR<EquipementRelationFilter, EquipementWhereInput>
  }

  export type PersonnageEquipementOrderByWithRelationInput = {
    personnageId?: SortOrder
    equipementId?: SortOrder
    dateAcquisition?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    personnage?: PersonnageOrderByWithRelationInput
    equipement?: EquipementOrderByWithRelationInput
  }

  export type PersonnageEquipementWhereUniqueInput = Prisma.AtLeast<{
    personnageId_equipementId?: PersonnageEquipementPersonnageIdEquipementIdCompoundUniqueInput
    AND?: PersonnageEquipementWhereInput | PersonnageEquipementWhereInput[]
    OR?: PersonnageEquipementWhereInput[]
    NOT?: PersonnageEquipementWhereInput | PersonnageEquipementWhereInput[]
    personnageId?: IntFilter<"PersonnageEquipement"> | number
    equipementId?: IntFilter<"PersonnageEquipement"> | number
    dateAcquisition?: DateTimeNullableFilter<"PersonnageEquipement"> | Date | string | null
    source?: StringNullableFilter<"PersonnageEquipement"> | string | null
    personnage?: XOR<PersonnageRelationFilter, PersonnageWhereInput>
    equipement?: XOR<EquipementRelationFilter, EquipementWhereInput>
  }, "personnageId_equipementId">

  export type PersonnageEquipementOrderByWithAggregationInput = {
    personnageId?: SortOrder
    equipementId?: SortOrder
    dateAcquisition?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    _count?: PersonnageEquipementCountOrderByAggregateInput
    _avg?: PersonnageEquipementAvgOrderByAggregateInput
    _max?: PersonnageEquipementMaxOrderByAggregateInput
    _min?: PersonnageEquipementMinOrderByAggregateInput
    _sum?: PersonnageEquipementSumOrderByAggregateInput
  }

  export type PersonnageEquipementScalarWhereWithAggregatesInput = {
    AND?: PersonnageEquipementScalarWhereWithAggregatesInput | PersonnageEquipementScalarWhereWithAggregatesInput[]
    OR?: PersonnageEquipementScalarWhereWithAggregatesInput[]
    NOT?: PersonnageEquipementScalarWhereWithAggregatesInput | PersonnageEquipementScalarWhereWithAggregatesInput[]
    personnageId?: IntWithAggregatesFilter<"PersonnageEquipement"> | number
    equipementId?: IntWithAggregatesFilter<"PersonnageEquipement"> | number
    dateAcquisition?: DateTimeNullableWithAggregatesFilter<"PersonnageEquipement"> | Date | string | null
    source?: StringNullableWithAggregatesFilter<"PersonnageEquipement"> | string | null
  }

  export type MarchandWhereInput = {
    AND?: MarchandWhereInput | MarchandWhereInput[]
    OR?: MarchandWhereInput[]
    NOT?: MarchandWhereInput | MarchandWhereInput[]
    id?: IntFilter<"Marchand"> | number
    nom?: StringFilter<"Marchand"> | string
    routes?: MarchandRouteListRelationFilter
  }

  export type MarchandOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    routes?: MarchandRouteOrderByRelationAggregateInput
  }

  export type MarchandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: MarchandWhereInput | MarchandWhereInput[]
    OR?: MarchandWhereInput[]
    NOT?: MarchandWhereInput | MarchandWhereInput[]
    routes?: MarchandRouteListRelationFilter
  }, "id" | "nom">

  export type MarchandOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    _count?: MarchandCountOrderByAggregateInput
    _avg?: MarchandAvgOrderByAggregateInput
    _max?: MarchandMaxOrderByAggregateInput
    _min?: MarchandMinOrderByAggregateInput
    _sum?: MarchandSumOrderByAggregateInput
  }

  export type MarchandScalarWhereWithAggregatesInput = {
    AND?: MarchandScalarWhereWithAggregatesInput | MarchandScalarWhereWithAggregatesInput[]
    OR?: MarchandScalarWhereWithAggregatesInput[]
    NOT?: MarchandScalarWhereWithAggregatesInput | MarchandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Marchand"> | number
    nom?: StringWithAggregatesFilter<"Marchand"> | string
  }

  export type RouteCommercialeWhereInput = {
    AND?: RouteCommercialeWhereInput | RouteCommercialeWhereInput[]
    OR?: RouteCommercialeWhereInput[]
    NOT?: RouteCommercialeWhereInput | RouteCommercialeWhereInput[]
    id?: IntFilter<"RouteCommerciale"> | number
    nom?: StringFilter<"RouteCommerciale"> | string
    securite?: StringNullableFilter<"RouteCommerciale"> | string | null
    saison?: StringNullableFilter<"RouteCommerciale"> | string | null
    segments?: RouteSegmentListRelationFilter
    marchands?: MarchandRouteListRelationFilter
  }

  export type RouteCommercialeOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    securite?: SortOrderInput | SortOrder
    saison?: SortOrderInput | SortOrder
    segments?: RouteSegmentOrderByRelationAggregateInput
    marchands?: MarchandRouteOrderByRelationAggregateInput
  }

  export type RouteCommercialeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: RouteCommercialeWhereInput | RouteCommercialeWhereInput[]
    OR?: RouteCommercialeWhereInput[]
    NOT?: RouteCommercialeWhereInput | RouteCommercialeWhereInput[]
    securite?: StringNullableFilter<"RouteCommerciale"> | string | null
    saison?: StringNullableFilter<"RouteCommerciale"> | string | null
    segments?: RouteSegmentListRelationFilter
    marchands?: MarchandRouteListRelationFilter
  }, "id" | "nom">

  export type RouteCommercialeOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    securite?: SortOrderInput | SortOrder
    saison?: SortOrderInput | SortOrder
    _count?: RouteCommercialeCountOrderByAggregateInput
    _avg?: RouteCommercialeAvgOrderByAggregateInput
    _max?: RouteCommercialeMaxOrderByAggregateInput
    _min?: RouteCommercialeMinOrderByAggregateInput
    _sum?: RouteCommercialeSumOrderByAggregateInput
  }

  export type RouteCommercialeScalarWhereWithAggregatesInput = {
    AND?: RouteCommercialeScalarWhereWithAggregatesInput | RouteCommercialeScalarWhereWithAggregatesInput[]
    OR?: RouteCommercialeScalarWhereWithAggregatesInput[]
    NOT?: RouteCommercialeScalarWhereWithAggregatesInput | RouteCommercialeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RouteCommerciale"> | number
    nom?: StringWithAggregatesFilter<"RouteCommerciale"> | string
    securite?: StringNullableWithAggregatesFilter<"RouteCommerciale"> | string | null
    saison?: StringNullableWithAggregatesFilter<"RouteCommerciale"> | string | null
  }

  export type LieuWhereInput = {
    AND?: LieuWhereInput | LieuWhereInput[]
    OR?: LieuWhereInput[]
    NOT?: LieuWhereInput | LieuWhereInput[]
    id?: IntFilter<"Lieu"> | number
    nom?: StringFilter<"Lieu"> | string
    typeLieu?: StringNullableFilter<"Lieu"> | string | null
    localisation?: StringNullableFilter<"Lieu"> | string | null
    segments?: RouteSegmentListRelationFilter
    inventaires?: InventaireListRelationFilter
  }

  export type LieuOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    typeLieu?: SortOrderInput | SortOrder
    localisation?: SortOrderInput | SortOrder
    segments?: RouteSegmentOrderByRelationAggregateInput
    inventaires?: InventaireOrderByRelationAggregateInput
  }

  export type LieuWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: LieuWhereInput | LieuWhereInput[]
    OR?: LieuWhereInput[]
    NOT?: LieuWhereInput | LieuWhereInput[]
    typeLieu?: StringNullableFilter<"Lieu"> | string | null
    localisation?: StringNullableFilter<"Lieu"> | string | null
    segments?: RouteSegmentListRelationFilter
    inventaires?: InventaireListRelationFilter
  }, "id" | "nom">

  export type LieuOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    typeLieu?: SortOrderInput | SortOrder
    localisation?: SortOrderInput | SortOrder
    _count?: LieuCountOrderByAggregateInput
    _avg?: LieuAvgOrderByAggregateInput
    _max?: LieuMaxOrderByAggregateInput
    _min?: LieuMinOrderByAggregateInput
    _sum?: LieuSumOrderByAggregateInput
  }

  export type LieuScalarWhereWithAggregatesInput = {
    AND?: LieuScalarWhereWithAggregatesInput | LieuScalarWhereWithAggregatesInput[]
    OR?: LieuScalarWhereWithAggregatesInput[]
    NOT?: LieuScalarWhereWithAggregatesInput | LieuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lieu"> | number
    nom?: StringWithAggregatesFilter<"Lieu"> | string
    typeLieu?: StringNullableWithAggregatesFilter<"Lieu"> | string | null
    localisation?: StringNullableWithAggregatesFilter<"Lieu"> | string | null
  }

  export type RouteSegmentWhereInput = {
    AND?: RouteSegmentWhereInput | RouteSegmentWhereInput[]
    OR?: RouteSegmentWhereInput[]
    NOT?: RouteSegmentWhereInput | RouteSegmentWhereInput[]
    routeId?: IntFilter<"RouteSegment"> | number
    lieuId?: IntFilter<"RouteSegment"> | number
    ordre?: IntFilter<"RouteSegment"> | number
    route?: XOR<RouteCommercialeRelationFilter, RouteCommercialeWhereInput>
    lieu?: XOR<LieuRelationFilter, LieuWhereInput>
  }

  export type RouteSegmentOrderByWithRelationInput = {
    routeId?: SortOrder
    lieuId?: SortOrder
    ordre?: SortOrder
    route?: RouteCommercialeOrderByWithRelationInput
    lieu?: LieuOrderByWithRelationInput
  }

  export type RouteSegmentWhereUniqueInput = Prisma.AtLeast<{
    routeId_lieuId_ordre?: RouteSegmentRouteIdLieuIdOrdreCompoundUniqueInput
    AND?: RouteSegmentWhereInput | RouteSegmentWhereInput[]
    OR?: RouteSegmentWhereInput[]
    NOT?: RouteSegmentWhereInput | RouteSegmentWhereInput[]
    routeId?: IntFilter<"RouteSegment"> | number
    lieuId?: IntFilter<"RouteSegment"> | number
    ordre?: IntFilter<"RouteSegment"> | number
    route?: XOR<RouteCommercialeRelationFilter, RouteCommercialeWhereInput>
    lieu?: XOR<LieuRelationFilter, LieuWhereInput>
  }, "routeId_lieuId_ordre">

  export type RouteSegmentOrderByWithAggregationInput = {
    routeId?: SortOrder
    lieuId?: SortOrder
    ordre?: SortOrder
    _count?: RouteSegmentCountOrderByAggregateInput
    _avg?: RouteSegmentAvgOrderByAggregateInput
    _max?: RouteSegmentMaxOrderByAggregateInput
    _min?: RouteSegmentMinOrderByAggregateInput
    _sum?: RouteSegmentSumOrderByAggregateInput
  }

  export type RouteSegmentScalarWhereWithAggregatesInput = {
    AND?: RouteSegmentScalarWhereWithAggregatesInput | RouteSegmentScalarWhereWithAggregatesInput[]
    OR?: RouteSegmentScalarWhereWithAggregatesInput[]
    NOT?: RouteSegmentScalarWhereWithAggregatesInput | RouteSegmentScalarWhereWithAggregatesInput[]
    routeId?: IntWithAggregatesFilter<"RouteSegment"> | number
    lieuId?: IntWithAggregatesFilter<"RouteSegment"> | number
    ordre?: IntWithAggregatesFilter<"RouteSegment"> | number
  }

  export type MarchandRouteWhereInput = {
    AND?: MarchandRouteWhereInput | MarchandRouteWhereInput[]
    OR?: MarchandRouteWhereInput[]
    NOT?: MarchandRouteWhereInput | MarchandRouteWhereInput[]
    marchandId?: IntFilter<"MarchandRoute"> | number
    routeId?: IntFilter<"MarchandRoute"> | number
    biens?: StringNullableFilter<"MarchandRoute"> | string | null
    taxes?: FloatNullableFilter<"MarchandRoute"> | number | null
    marchand?: XOR<MarchandRelationFilter, MarchandWhereInput>
    route?: XOR<RouteCommercialeRelationFilter, RouteCommercialeWhereInput>
  }

  export type MarchandRouteOrderByWithRelationInput = {
    marchandId?: SortOrder
    routeId?: SortOrder
    biens?: SortOrderInput | SortOrder
    taxes?: SortOrderInput | SortOrder
    marchand?: MarchandOrderByWithRelationInput
    route?: RouteCommercialeOrderByWithRelationInput
  }

  export type MarchandRouteWhereUniqueInput = Prisma.AtLeast<{
    marchandId_routeId?: MarchandRouteMarchandIdRouteIdCompoundUniqueInput
    AND?: MarchandRouteWhereInput | MarchandRouteWhereInput[]
    OR?: MarchandRouteWhereInput[]
    NOT?: MarchandRouteWhereInput | MarchandRouteWhereInput[]
    marchandId?: IntFilter<"MarchandRoute"> | number
    routeId?: IntFilter<"MarchandRoute"> | number
    biens?: StringNullableFilter<"MarchandRoute"> | string | null
    taxes?: FloatNullableFilter<"MarchandRoute"> | number | null
    marchand?: XOR<MarchandRelationFilter, MarchandWhereInput>
    route?: XOR<RouteCommercialeRelationFilter, RouteCommercialeWhereInput>
  }, "marchandId_routeId">

  export type MarchandRouteOrderByWithAggregationInput = {
    marchandId?: SortOrder
    routeId?: SortOrder
    biens?: SortOrderInput | SortOrder
    taxes?: SortOrderInput | SortOrder
    _count?: MarchandRouteCountOrderByAggregateInput
    _avg?: MarchandRouteAvgOrderByAggregateInput
    _max?: MarchandRouteMaxOrderByAggregateInput
    _min?: MarchandRouteMinOrderByAggregateInput
    _sum?: MarchandRouteSumOrderByAggregateInput
  }

  export type MarchandRouteScalarWhereWithAggregatesInput = {
    AND?: MarchandRouteScalarWhereWithAggregatesInput | MarchandRouteScalarWhereWithAggregatesInput[]
    OR?: MarchandRouteScalarWhereWithAggregatesInput[]
    NOT?: MarchandRouteScalarWhereWithAggregatesInput | MarchandRouteScalarWhereWithAggregatesInput[]
    marchandId?: IntWithAggregatesFilter<"MarchandRoute"> | number
    routeId?: IntWithAggregatesFilter<"MarchandRoute"> | number
    biens?: StringNullableWithAggregatesFilter<"MarchandRoute"> | string | null
    taxes?: FloatNullableWithAggregatesFilter<"MarchandRoute"> | number | null
  }

  export type BardeWhereInput = {
    AND?: BardeWhereInput | BardeWhereInput[]
    OR?: BardeWhereInput[]
    NOT?: BardeWhereInput | BardeWhereInput[]
    id?: IntFilter<"Barde"> | number
    nom?: StringFilter<"Barde"> | string
    histoires?: HistoireListRelationFilter
  }

  export type BardeOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    histoires?: HistoireOrderByRelationAggregateInput
  }

  export type BardeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: BardeWhereInput | BardeWhereInput[]
    OR?: BardeWhereInput[]
    NOT?: BardeWhereInput | BardeWhereInput[]
    histoires?: HistoireListRelationFilter
  }, "id" | "nom">

  export type BardeOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    _count?: BardeCountOrderByAggregateInput
    _avg?: BardeAvgOrderByAggregateInput
    _max?: BardeMaxOrderByAggregateInput
    _min?: BardeMinOrderByAggregateInput
    _sum?: BardeSumOrderByAggregateInput
  }

  export type BardeScalarWhereWithAggregatesInput = {
    AND?: BardeScalarWhereWithAggregatesInput | BardeScalarWhereWithAggregatesInput[]
    OR?: BardeScalarWhereWithAggregatesInput[]
    NOT?: BardeScalarWhereWithAggregatesInput | BardeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Barde"> | number
    nom?: StringWithAggregatesFilter<"Barde"> | string
  }

  export type HistoireWhereInput = {
    AND?: HistoireWhereInput | HistoireWhereInput[]
    OR?: HistoireWhereInput[]
    NOT?: HistoireWhereInput | HistoireWhereInput[]
    id?: IntFilter<"Histoire"> | number
    titre?: StringNullableFilter<"Histoire"> | string | null
    typeEvenement?: StringNullableFilter<"Histoire"> | string | null
    description?: StringNullableFilter<"Histoire"> | string | null
    dateEvenement?: DateTimeNullableFilter<"Histoire"> | Date | string | null
    bardeId?: IntNullableFilter<"Histoire"> | number | null
    barde?: XOR<BardeNullableRelationFilter, BardeWhereInput> | null
  }

  export type HistoireOrderByWithRelationInput = {
    id?: SortOrder
    titre?: SortOrderInput | SortOrder
    typeEvenement?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    dateEvenement?: SortOrderInput | SortOrder
    bardeId?: SortOrderInput | SortOrder
    barde?: BardeOrderByWithRelationInput
  }

  export type HistoireWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HistoireWhereInput | HistoireWhereInput[]
    OR?: HistoireWhereInput[]
    NOT?: HistoireWhereInput | HistoireWhereInput[]
    titre?: StringNullableFilter<"Histoire"> | string | null
    typeEvenement?: StringNullableFilter<"Histoire"> | string | null
    description?: StringNullableFilter<"Histoire"> | string | null
    dateEvenement?: DateTimeNullableFilter<"Histoire"> | Date | string | null
    bardeId?: IntNullableFilter<"Histoire"> | number | null
    barde?: XOR<BardeNullableRelationFilter, BardeWhereInput> | null
  }, "id">

  export type HistoireOrderByWithAggregationInput = {
    id?: SortOrder
    titre?: SortOrderInput | SortOrder
    typeEvenement?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    dateEvenement?: SortOrderInput | SortOrder
    bardeId?: SortOrderInput | SortOrder
    _count?: HistoireCountOrderByAggregateInput
    _avg?: HistoireAvgOrderByAggregateInput
    _max?: HistoireMaxOrderByAggregateInput
    _min?: HistoireMinOrderByAggregateInput
    _sum?: HistoireSumOrderByAggregateInput
  }

  export type HistoireScalarWhereWithAggregatesInput = {
    AND?: HistoireScalarWhereWithAggregatesInput | HistoireScalarWhereWithAggregatesInput[]
    OR?: HistoireScalarWhereWithAggregatesInput[]
    NOT?: HistoireScalarWhereWithAggregatesInput | HistoireScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Histoire"> | number
    titre?: StringNullableWithAggregatesFilter<"Histoire"> | string | null
    typeEvenement?: StringNullableWithAggregatesFilter<"Histoire"> | string | null
    description?: StringNullableWithAggregatesFilter<"Histoire"> | string | null
    dateEvenement?: DateTimeNullableWithAggregatesFilter<"Histoire"> | Date | string | null
    bardeId?: IntNullableWithAggregatesFilter<"Histoire"> | number | null
  }

  export type InventaireWhereInput = {
    AND?: InventaireWhereInput | InventaireWhereInput[]
    OR?: InventaireWhereInput[]
    NOT?: InventaireWhereInput | InventaireWhereInput[]
    id?: IntFilter<"Inventaire"> | number
    typeRessource?: StringNullableFilter<"Inventaire"> | string | null
    stock?: IntNullableFilter<"Inventaire"> | number | null
    seuilAlerte?: IntNullableFilter<"Inventaire"> | number | null
    dateMesure?: DateTimeNullableFilter<"Inventaire"> | Date | string | null
    lieuId?: IntNullableFilter<"Inventaire"> | number | null
    armeeId?: IntNullableFilter<"Inventaire"> | number | null
    villageId?: IntNullableFilter<"Inventaire"> | number | null
    lieu?: XOR<LieuNullableRelationFilter, LieuWhereInput> | null
    armee?: XOR<ArmeeNullableRelationFilter, ArmeeWhereInput> | null
    Village?: XOR<VillageNullableRelationFilter, VillageWhereInput> | null
  }

  export type InventaireOrderByWithRelationInput = {
    id?: SortOrder
    typeRessource?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    seuilAlerte?: SortOrderInput | SortOrder
    dateMesure?: SortOrderInput | SortOrder
    lieuId?: SortOrderInput | SortOrder
    armeeId?: SortOrderInput | SortOrder
    villageId?: SortOrderInput | SortOrder
    lieu?: LieuOrderByWithRelationInput
    armee?: ArmeeOrderByWithRelationInput
    Village?: VillageOrderByWithRelationInput
  }

  export type InventaireWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventaireWhereInput | InventaireWhereInput[]
    OR?: InventaireWhereInput[]
    NOT?: InventaireWhereInput | InventaireWhereInput[]
    typeRessource?: StringNullableFilter<"Inventaire"> | string | null
    stock?: IntNullableFilter<"Inventaire"> | number | null
    seuilAlerte?: IntNullableFilter<"Inventaire"> | number | null
    dateMesure?: DateTimeNullableFilter<"Inventaire"> | Date | string | null
    lieuId?: IntNullableFilter<"Inventaire"> | number | null
    armeeId?: IntNullableFilter<"Inventaire"> | number | null
    villageId?: IntNullableFilter<"Inventaire"> | number | null
    lieu?: XOR<LieuNullableRelationFilter, LieuWhereInput> | null
    armee?: XOR<ArmeeNullableRelationFilter, ArmeeWhereInput> | null
    Village?: XOR<VillageNullableRelationFilter, VillageWhereInput> | null
  }, "id">

  export type InventaireOrderByWithAggregationInput = {
    id?: SortOrder
    typeRessource?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    seuilAlerte?: SortOrderInput | SortOrder
    dateMesure?: SortOrderInput | SortOrder
    lieuId?: SortOrderInput | SortOrder
    armeeId?: SortOrderInput | SortOrder
    villageId?: SortOrderInput | SortOrder
    _count?: InventaireCountOrderByAggregateInput
    _avg?: InventaireAvgOrderByAggregateInput
    _max?: InventaireMaxOrderByAggregateInput
    _min?: InventaireMinOrderByAggregateInput
    _sum?: InventaireSumOrderByAggregateInput
  }

  export type InventaireScalarWhereWithAggregatesInput = {
    AND?: InventaireScalarWhereWithAggregatesInput | InventaireScalarWhereWithAggregatesInput[]
    OR?: InventaireScalarWhereWithAggregatesInput[]
    NOT?: InventaireScalarWhereWithAggregatesInput | InventaireScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inventaire"> | number
    typeRessource?: StringNullableWithAggregatesFilter<"Inventaire"> | string | null
    stock?: IntNullableWithAggregatesFilter<"Inventaire"> | number | null
    seuilAlerte?: IntNullableWithAggregatesFilter<"Inventaire"> | number | null
    dateMesure?: DateTimeNullableWithAggregatesFilter<"Inventaire"> | Date | string | null
    lieuId?: IntNullableWithAggregatesFilter<"Inventaire"> | number | null
    armeeId?: IntNullableWithAggregatesFilter<"Inventaire"> | number | null
    villageId?: IntNullableWithAggregatesFilter<"Inventaire"> | number | null
  }

  export type RelationDiplomatiqueWhereInput = {
    AND?: RelationDiplomatiqueWhereInput | RelationDiplomatiqueWhereInput[]
    OR?: RelationDiplomatiqueWhereInput[]
    NOT?: RelationDiplomatiqueWhereInput | RelationDiplomatiqueWhereInput[]
    id?: IntFilter<"RelationDiplomatique"> | number
    typeRelation?: StringNullableFilter<"RelationDiplomatique"> | string | null
    conditions?: StringNullableFilter<"RelationDiplomatique"> | string | null
    dateSignature?: DateTimeNullableFilter<"RelationDiplomatique"> | Date | string | null
    echeance?: StringNullableFilter<"RelationDiplomatique"> | string | null
    domaineSourceId?: IntFilter<"RelationDiplomatique"> | number
    domaineCibleId?: IntFilter<"RelationDiplomatique"> | number
    domaineSource?: XOR<DomaineRelationFilter, DomaineWhereInput>
    domaineCible?: XOR<DomaineRelationFilter, DomaineWhereInput>
  }

  export type RelationDiplomatiqueOrderByWithRelationInput = {
    id?: SortOrder
    typeRelation?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    dateSignature?: SortOrderInput | SortOrder
    echeance?: SortOrderInput | SortOrder
    domaineSourceId?: SortOrder
    domaineCibleId?: SortOrder
    domaineSource?: DomaineOrderByWithRelationInput
    domaineCible?: DomaineOrderByWithRelationInput
  }

  export type RelationDiplomatiqueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RelationDiplomatiqueWhereInput | RelationDiplomatiqueWhereInput[]
    OR?: RelationDiplomatiqueWhereInput[]
    NOT?: RelationDiplomatiqueWhereInput | RelationDiplomatiqueWhereInput[]
    typeRelation?: StringNullableFilter<"RelationDiplomatique"> | string | null
    conditions?: StringNullableFilter<"RelationDiplomatique"> | string | null
    dateSignature?: DateTimeNullableFilter<"RelationDiplomatique"> | Date | string | null
    echeance?: StringNullableFilter<"RelationDiplomatique"> | string | null
    domaineSourceId?: IntFilter<"RelationDiplomatique"> | number
    domaineCibleId?: IntFilter<"RelationDiplomatique"> | number
    domaineSource?: XOR<DomaineRelationFilter, DomaineWhereInput>
    domaineCible?: XOR<DomaineRelationFilter, DomaineWhereInput>
  }, "id">

  export type RelationDiplomatiqueOrderByWithAggregationInput = {
    id?: SortOrder
    typeRelation?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    dateSignature?: SortOrderInput | SortOrder
    echeance?: SortOrderInput | SortOrder
    domaineSourceId?: SortOrder
    domaineCibleId?: SortOrder
    _count?: RelationDiplomatiqueCountOrderByAggregateInput
    _avg?: RelationDiplomatiqueAvgOrderByAggregateInput
    _max?: RelationDiplomatiqueMaxOrderByAggregateInput
    _min?: RelationDiplomatiqueMinOrderByAggregateInput
    _sum?: RelationDiplomatiqueSumOrderByAggregateInput
  }

  export type RelationDiplomatiqueScalarWhereWithAggregatesInput = {
    AND?: RelationDiplomatiqueScalarWhereWithAggregatesInput | RelationDiplomatiqueScalarWhereWithAggregatesInput[]
    OR?: RelationDiplomatiqueScalarWhereWithAggregatesInput[]
    NOT?: RelationDiplomatiqueScalarWhereWithAggregatesInput | RelationDiplomatiqueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RelationDiplomatique"> | number
    typeRelation?: StringNullableWithAggregatesFilter<"RelationDiplomatique"> | string | null
    conditions?: StringNullableWithAggregatesFilter<"RelationDiplomatique"> | string | null
    dateSignature?: DateTimeNullableWithAggregatesFilter<"RelationDiplomatique"> | Date | string | null
    echeance?: StringNullableWithAggregatesFilter<"RelationDiplomatique"> | string | null
    domaineSourceId?: IntWithAggregatesFilter<"RelationDiplomatique"> | number
    domaineCibleId?: IntWithAggregatesFilter<"RelationDiplomatique"> | number
  }

  export type LoiWhereInput = {
    AND?: LoiWhereInput | LoiWhereInput[]
    OR?: LoiWhereInput[]
    NOT?: LoiWhereInput | LoiWhereInput[]
    id?: IntFilter<"Loi"> | number
    libelle?: StringFilter<"Loi"> | string
    effet?: StringNullableFilter<"Loi"> | string | null
    domaines?: LoiTerritoireListRelationFilter
  }

  export type LoiOrderByWithRelationInput = {
    id?: SortOrder
    libelle?: SortOrder
    effet?: SortOrderInput | SortOrder
    domaines?: LoiTerritoireOrderByRelationAggregateInput
  }

  export type LoiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    libelle?: string
    AND?: LoiWhereInput | LoiWhereInput[]
    OR?: LoiWhereInput[]
    NOT?: LoiWhereInput | LoiWhereInput[]
    effet?: StringNullableFilter<"Loi"> | string | null
    domaines?: LoiTerritoireListRelationFilter
  }, "id" | "libelle">

  export type LoiOrderByWithAggregationInput = {
    id?: SortOrder
    libelle?: SortOrder
    effet?: SortOrderInput | SortOrder
    _count?: LoiCountOrderByAggregateInput
    _avg?: LoiAvgOrderByAggregateInput
    _max?: LoiMaxOrderByAggregateInput
    _min?: LoiMinOrderByAggregateInput
    _sum?: LoiSumOrderByAggregateInput
  }

  export type LoiScalarWhereWithAggregatesInput = {
    AND?: LoiScalarWhereWithAggregatesInput | LoiScalarWhereWithAggregatesInput[]
    OR?: LoiScalarWhereWithAggregatesInput[]
    NOT?: LoiScalarWhereWithAggregatesInput | LoiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Loi"> | number
    libelle?: StringWithAggregatesFilter<"Loi"> | string
    effet?: StringNullableWithAggregatesFilter<"Loi"> | string | null
  }

  export type LoiTerritoireWhereInput = {
    AND?: LoiTerritoireWhereInput | LoiTerritoireWhereInput[]
    OR?: LoiTerritoireWhereInput[]
    NOT?: LoiTerritoireWhereInput | LoiTerritoireWhereInput[]
    loiId?: IntFilter<"LoiTerritoire"> | number
    domaineId?: IntFilter<"LoiTerritoire"> | number
    loi?: XOR<LoiRelationFilter, LoiWhereInput>
    domaine?: XOR<DomaineRelationFilter, DomaineWhereInput>
  }

  export type LoiTerritoireOrderByWithRelationInput = {
    loiId?: SortOrder
    domaineId?: SortOrder
    loi?: LoiOrderByWithRelationInput
    domaine?: DomaineOrderByWithRelationInput
  }

  export type LoiTerritoireWhereUniqueInput = Prisma.AtLeast<{
    loiId_domaineId?: LoiTerritoireLoiIdDomaineIdCompoundUniqueInput
    AND?: LoiTerritoireWhereInput | LoiTerritoireWhereInput[]
    OR?: LoiTerritoireWhereInput[]
    NOT?: LoiTerritoireWhereInput | LoiTerritoireWhereInput[]
    loiId?: IntFilter<"LoiTerritoire"> | number
    domaineId?: IntFilter<"LoiTerritoire"> | number
    loi?: XOR<LoiRelationFilter, LoiWhereInput>
    domaine?: XOR<DomaineRelationFilter, DomaineWhereInput>
  }, "loiId_domaineId">

  export type LoiTerritoireOrderByWithAggregationInput = {
    loiId?: SortOrder
    domaineId?: SortOrder
    _count?: LoiTerritoireCountOrderByAggregateInput
    _avg?: LoiTerritoireAvgOrderByAggregateInput
    _max?: LoiTerritoireMaxOrderByAggregateInput
    _min?: LoiTerritoireMinOrderByAggregateInput
    _sum?: LoiTerritoireSumOrderByAggregateInput
  }

  export type LoiTerritoireScalarWhereWithAggregatesInput = {
    AND?: LoiTerritoireScalarWhereWithAggregatesInput | LoiTerritoireScalarWhereWithAggregatesInput[]
    OR?: LoiTerritoireScalarWhereWithAggregatesInput[]
    NOT?: LoiTerritoireScalarWhereWithAggregatesInput | LoiTerritoireScalarWhereWithAggregatesInput[]
    loiId?: IntWithAggregatesFilter<"LoiTerritoire"> | number
    domaineId?: IntWithAggregatesFilter<"LoiTerritoire"> | number
  }

  export type RaceCreateInput = {
    libelle: string
    personnages?: PersonnageCreateNestedManyWithoutRaceInput
    competences?: CompetenceCreateNestedManyWithoutExigenceRaceInput
  }

  export type RaceUncheckedCreateInput = {
    id?: number
    libelle: string
    personnages?: PersonnageUncheckedCreateNestedManyWithoutRaceInput
    competences?: CompetenceUncheckedCreateNestedManyWithoutExigenceRaceInput
  }

  export type RaceUpdateInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    personnages?: PersonnageUpdateManyWithoutRaceNestedInput
    competences?: CompetenceUpdateManyWithoutExigenceRaceNestedInput
  }

  export type RaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    personnages?: PersonnageUncheckedUpdateManyWithoutRaceNestedInput
    competences?: CompetenceUncheckedUpdateManyWithoutExigenceRaceNestedInput
  }

  export type RaceCreateManyInput = {
    id?: number
    libelle: string
  }

  export type RaceUpdateManyMutationInput = {
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type RaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    libelle: string
    personnages?: PersonnageRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    libelle: string
    personnages?: PersonnageRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    personnages?: PersonnageRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    personnages?: PersonnageRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    libelle: string
  }

  export type RoleUpdateManyMutationInput = {
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type LigneeCreateInput = {
    nom: string
    personnages?: PersonnageCreateNestedManyWithoutLigneeInput
    titres?: PersonnageTitreCreateNestedManyWithoutLigneeInput
  }

  export type LigneeUncheckedCreateInput = {
    id?: number
    nom: string
    personnages?: PersonnageUncheckedCreateNestedManyWithoutLigneeInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutLigneeInput
  }

  export type LigneeUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    personnages?: PersonnageUpdateManyWithoutLigneeNestedInput
    titres?: PersonnageTitreUpdateManyWithoutLigneeNestedInput
  }

  export type LigneeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    personnages?: PersonnageUncheckedUpdateManyWithoutLigneeNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutLigneeNestedInput
  }

  export type LigneeCreateManyInput = {
    id?: number
    nom: string
  }

  export type LigneeUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type LigneeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type PersonnageCreateInput = {
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    race?: RaceCreateNestedOneWithoutPersonnagesInput
    lignee?: LigneeCreateNestedOneWithoutPersonnagesInput
    roles?: PersonnageRoleCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUncheckedCreateInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
    ligneeId?: number | null
    roles?: PersonnageRoleUncheckedCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceUncheckedCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieUncheckedCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeUncheckedCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementUncheckedCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreUncheckedCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneWithoutPersonnagesNestedInput
    lignee?: LigneeUpdateOneWithoutPersonnagesNestedInput
    roles?: PersonnageRoleUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
    roles?: PersonnageRoleUncheckedUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUncheckedUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUncheckedUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUncheckedUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUncheckedUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageCreateManyInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
    ligneeId?: number | null
  }

  export type PersonnageUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageRoleCreateInput = {
    personnage: PersonnageCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutPersonnagesInput
  }

  export type PersonnageRoleUncheckedCreateInput = {
    personnageId: number
    roleId: number
  }

  export type PersonnageRoleUpdateInput = {
    personnage?: PersonnageUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutPersonnagesNestedInput
  }

  export type PersonnageRoleUncheckedUpdateInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageRoleCreateManyInput = {
    personnageId: number
    roleId: number
  }

  export type PersonnageRoleUpdateManyMutationInput = {

  }

  export type PersonnageRoleUncheckedUpdateManyInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type CompetenceCreateInput = {
    nom: string
    exigenceFormation?: string | null
    exigenceRace?: RaceCreateNestedOneWithoutCompetencesInput
    personnages?: PersonnageCompetenceCreateNestedManyWithoutCompetenceInput
  }

  export type CompetenceUncheckedCreateInput = {
    id?: number
    nom: string
    exigenceFormation?: string | null
    exigenceRaceId?: number | null
    personnages?: PersonnageCompetenceUncheckedCreateNestedManyWithoutCompetenceInput
  }

  export type CompetenceUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    exigenceFormation?: NullableStringFieldUpdateOperationsInput | string | null
    exigenceRace?: RaceUpdateOneWithoutCompetencesNestedInput
    personnages?: PersonnageCompetenceUpdateManyWithoutCompetenceNestedInput
  }

  export type CompetenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    exigenceFormation?: NullableStringFieldUpdateOperationsInput | string | null
    exigenceRaceId?: NullableIntFieldUpdateOperationsInput | number | null
    personnages?: PersonnageCompetenceUncheckedUpdateManyWithoutCompetenceNestedInput
  }

  export type CompetenceCreateManyInput = {
    id?: number
    nom: string
    exigenceFormation?: string | null
    exigenceRaceId?: number | null
  }

  export type CompetenceUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    exigenceFormation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompetenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    exigenceFormation?: NullableStringFieldUpdateOperationsInput | string | null
    exigenceRaceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageCompetenceCreateInput = {
    niveau: number
    personnage: PersonnageCreateNestedOneWithoutCompetencesInput
    competence: CompetenceCreateNestedOneWithoutPersonnagesInput
  }

  export type PersonnageCompetenceUncheckedCreateInput = {
    personnageId: number
    competenceId: number
    niveau: number
  }

  export type PersonnageCompetenceUpdateInput = {
    niveau?: IntFieldUpdateOperationsInput | number
    personnage?: PersonnageUpdateOneRequiredWithoutCompetencesNestedInput
    competence?: CompetenceUpdateOneRequiredWithoutPersonnagesNestedInput
  }

  export type PersonnageCompetenceUncheckedUpdateInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    competenceId?: IntFieldUpdateOperationsInput | number
    niveau?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageCompetenceCreateManyInput = {
    personnageId: number
    competenceId: number
    niveau: number
  }

  export type PersonnageCompetenceUpdateManyMutationInput = {
    niveau?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageCompetenceUncheckedUpdateManyInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    competenceId?: IntFieldUpdateOperationsInput | number
    niveau?: IntFieldUpdateOperationsInput | number
  }

  export type DomaineCreateInput = {
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageCreateNestedManyWithoutDomaineInput
    titres?: PersonnageTitreCreateNestedManyWithoutDomaineInput
    armees?: ArmeeCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueCreateNestedManyWithoutDomaineSourceInput
    relationsCible?: RelationDiplomatiqueCreateNestedManyWithoutDomaineCibleInput
    lois?: LoiTerritoireCreateNestedManyWithoutDomaineInput
  }

  export type DomaineUncheckedCreateInput = {
    id?: number
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageUncheckedCreateNestedManyWithoutDomaineInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutDomaineInput
    armees?: ArmeeUncheckedCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineSourceInput
    relationsCible?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineCibleInput
    lois?: LoiTerritoireUncheckedCreateNestedManyWithoutDomaineInput
  }

  export type DomaineUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUpdateManyWithoutDomaineNestedInput
    titres?: PersonnageTitreUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUpdateManyWithoutDomaineSourceNestedInput
    relationsCible?: RelationDiplomatiqueUpdateManyWithoutDomaineCibleNestedInput
    lois?: LoiTerritoireUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUncheckedUpdateManyWithoutDomaineNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUncheckedUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineSourceNestedInput
    relationsCible?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineCibleNestedInput
    lois?: LoiTerritoireUncheckedUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineCreateManyInput = {
    id?: number
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
  }

  export type DomaineUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DomaineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TitreCreateInput = {
    libelle: string
    attributions?: PersonnageTitreCreateNestedManyWithoutTitreInput
  }

  export type TitreUncheckedCreateInput = {
    id?: number
    libelle: string
    attributions?: PersonnageTitreUncheckedCreateNestedManyWithoutTitreInput
  }

  export type TitreUpdateInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    attributions?: PersonnageTitreUpdateManyWithoutTitreNestedInput
  }

  export type TitreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    attributions?: PersonnageTitreUncheckedUpdateManyWithoutTitreNestedInput
  }

  export type TitreCreateManyInput = {
    id?: number
    libelle: string
  }

  export type TitreUpdateManyMutationInput = {
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type TitreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type PersonnageTitreCreateInput = {
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnage: PersonnageCreateNestedOneWithoutTitresInput
    titre: TitreCreateNestedOneWithoutAttributionsInput
    domaine?: DomaineCreateNestedOneWithoutTitresInput
    lignee?: LigneeCreateNestedOneWithoutTitresInput
  }

  export type PersonnageTitreUncheckedCreateInput = {
    id?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnageId: number
    titreId: number
    domaineId?: number | null
    ligneeId?: number | null
  }

  export type PersonnageTitreUpdateInput = {
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnage?: PersonnageUpdateOneRequiredWithoutTitresNestedInput
    titre?: TitreUpdateOneRequiredWithoutAttributionsNestedInput
    domaine?: DomaineUpdateOneWithoutTitresNestedInput
    lignee?: LigneeUpdateOneWithoutTitresNestedInput
  }

  export type PersonnageTitreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnageId?: IntFieldUpdateOperationsInput | number
    titreId?: IntFieldUpdateOperationsInput | number
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageTitreCreateManyInput = {
    id?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnageId: number
    titreId: number
    domaineId?: number | null
    ligneeId?: number | null
  }

  export type PersonnageTitreUpdateManyMutationInput = {
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersonnageTitreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnageId?: IntFieldUpdateOperationsInput | number
    titreId?: IntFieldUpdateOperationsInput | number
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VillageCreateInput = {
    nom: string
    localisation?: string | null
    population?: number | null
    ressourcePrincipale?: string | null
    domaine?: DomaineCreateNestedOneWithoutVillagesInput
    inventaires?: InventaireCreateNestedManyWithoutVillageInput
  }

  export type VillageUncheckedCreateInput = {
    id?: number
    nom: string
    localisation?: string | null
    population?: number | null
    ressourcePrincipale?: string | null
    domaineId?: number | null
    inventaires?: InventaireUncheckedCreateNestedManyWithoutVillageInput
  }

  export type VillageUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    ressourcePrincipale?: NullableStringFieldUpdateOperationsInput | string | null
    domaine?: DomaineUpdateOneWithoutVillagesNestedInput
    inventaires?: InventaireUpdateManyWithoutVillageNestedInput
  }

  export type VillageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    ressourcePrincipale?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    inventaires?: InventaireUncheckedUpdateManyWithoutVillageNestedInput
  }

  export type VillageCreateManyInput = {
    id?: number
    nom: string
    localisation?: string | null
    population?: number | null
    ressourcePrincipale?: string | null
    domaineId?: number | null
  }

  export type VillageUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    ressourcePrincipale?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VillageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    ressourcePrincipale?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GuildeCreateInput = {
    nom: string
    specialite?: string | null
    reputation?: string | null
    membres?: GuildeMembreCreateNestedManyWithoutGuildeInput
    batailles?: GuildeBatailleCreateNestedManyWithoutGuildeInput
  }

  export type GuildeUncheckedCreateInput = {
    id?: number
    nom: string
    specialite?: string | null
    reputation?: string | null
    membres?: GuildeMembreUncheckedCreateNestedManyWithoutGuildeInput
    batailles?: GuildeBatailleUncheckedCreateNestedManyWithoutGuildeInput
  }

  export type GuildeUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableStringFieldUpdateOperationsInput | string | null
    membres?: GuildeMembreUpdateManyWithoutGuildeNestedInput
    batailles?: GuildeBatailleUpdateManyWithoutGuildeNestedInput
  }

  export type GuildeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableStringFieldUpdateOperationsInput | string | null
    membres?: GuildeMembreUncheckedUpdateManyWithoutGuildeNestedInput
    batailles?: GuildeBatailleUncheckedUpdateManyWithoutGuildeNestedInput
  }

  export type GuildeCreateManyInput = {
    id?: number
    nom: string
    specialite?: string | null
    reputation?: string | null
  }

  export type GuildeUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildeMembreCreateInput = {
    dateEntree?: Date | string | null
    dateSortie?: Date | string | null
    personnage: PersonnageCreateNestedOneWithoutGuildesInput
    guilde: GuildeCreateNestedOneWithoutMembresInput
  }

  export type GuildeMembreUncheckedCreateInput = {
    personnageId: number
    guildeId: number
    dateEntree?: Date | string | null
    dateSortie?: Date | string | null
  }

  export type GuildeMembreUpdateInput = {
    dateEntree?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnage?: PersonnageUpdateOneRequiredWithoutGuildesNestedInput
    guilde?: GuildeUpdateOneRequiredWithoutMembresNestedInput
  }

  export type GuildeMembreUncheckedUpdateInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    guildeId?: IntFieldUpdateOperationsInput | number
    dateEntree?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuildeMembreCreateManyInput = {
    personnageId: number
    guildeId: number
    dateEntree?: Date | string | null
    dateSortie?: Date | string | null
  }

  export type GuildeMembreUpdateManyMutationInput = {
    dateEntree?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuildeMembreUncheckedUpdateManyInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    guildeId?: IntFieldUpdateOperationsInput | number
    dateEntree?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreatureCreateInput = {
    espece: string
    forces?: string | null
    faiblesses?: string | null
    dangerosite?: string | null
    batailles?: CreatureBatailleCreateNestedManyWithoutCreatureInput
  }

  export type CreatureUncheckedCreateInput = {
    id?: number
    espece: string
    forces?: string | null
    faiblesses?: string | null
    dangerosite?: string | null
    batailles?: CreatureBatailleUncheckedCreateNestedManyWithoutCreatureInput
  }

  export type CreatureUpdateInput = {
    espece?: StringFieldUpdateOperationsInput | string
    forces?: NullableStringFieldUpdateOperationsInput | string | null
    faiblesses?: NullableStringFieldUpdateOperationsInput | string | null
    dangerosite?: NullableStringFieldUpdateOperationsInput | string | null
    batailles?: CreatureBatailleUpdateManyWithoutCreatureNestedInput
  }

  export type CreatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    espece?: StringFieldUpdateOperationsInput | string
    forces?: NullableStringFieldUpdateOperationsInput | string | null
    faiblesses?: NullableStringFieldUpdateOperationsInput | string | null
    dangerosite?: NullableStringFieldUpdateOperationsInput | string | null
    batailles?: CreatureBatailleUncheckedUpdateManyWithoutCreatureNestedInput
  }

  export type CreatureCreateManyInput = {
    id?: number
    espece: string
    forces?: string | null
    faiblesses?: string | null
    dangerosite?: string | null
  }

  export type CreatureUpdateManyMutationInput = {
    espece?: StringFieldUpdateOperationsInput | string
    forces?: NullableStringFieldUpdateOperationsInput | string | null
    faiblesses?: NullableStringFieldUpdateOperationsInput | string | null
    dangerosite?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    espece?: StringFieldUpdateOperationsInput | string
    forces?: NullableStringFieldUpdateOperationsInput | string | null
    faiblesses?: NullableStringFieldUpdateOperationsInput | string | null
    dangerosite?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EcoleMagieCreateInput = {
    nom: string
    sorts?: SortCreateNestedManyWithoutEcoleInput
  }

  export type EcoleMagieUncheckedCreateInput = {
    id?: number
    nom: string
    sorts?: SortUncheckedCreateNestedManyWithoutEcoleInput
  }

  export type EcoleMagieUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    sorts?: SortUpdateManyWithoutEcoleNestedInput
  }

  export type EcoleMagieUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    sorts?: SortUncheckedUpdateManyWithoutEcoleNestedInput
  }

  export type EcoleMagieCreateManyInput = {
    id?: number
    nom: string
  }

  export type EcoleMagieUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type EcoleMagieUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type SortCreateInput = {
    nom: string
    element?: string | null
    coutMana?: number | null
    niveauRequis?: string | null
    estInterdit?: boolean
    estRituel?: boolean
    ecole?: EcoleMagieCreateNestedOneWithoutSortsInput
  }

  export type SortUncheckedCreateInput = {
    id?: number
    nom: string
    element?: string | null
    coutMana?: number | null
    niveauRequis?: string | null
    estInterdit?: boolean
    estRituel?: boolean
    ecoleId?: number | null
  }

  export type SortUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    coutMana?: NullableIntFieldUpdateOperationsInput | number | null
    niveauRequis?: NullableStringFieldUpdateOperationsInput | string | null
    estInterdit?: BoolFieldUpdateOperationsInput | boolean
    estRituel?: BoolFieldUpdateOperationsInput | boolean
    ecole?: EcoleMagieUpdateOneWithoutSortsNestedInput
  }

  export type SortUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    coutMana?: NullableIntFieldUpdateOperationsInput | number | null
    niveauRequis?: NullableStringFieldUpdateOperationsInput | string | null
    estInterdit?: BoolFieldUpdateOperationsInput | boolean
    estRituel?: BoolFieldUpdateOperationsInput | boolean
    ecoleId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SortCreateManyInput = {
    id?: number
    nom: string
    element?: string | null
    coutMana?: number | null
    niveauRequis?: string | null
    estInterdit?: boolean
    estRituel?: boolean
    ecoleId?: number | null
  }

  export type SortUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    coutMana?: NullableIntFieldUpdateOperationsInput | number | null
    niveauRequis?: NullableStringFieldUpdateOperationsInput | string | null
    estInterdit?: BoolFieldUpdateOperationsInput | boolean
    estRituel?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SortUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    coutMana?: NullableIntFieldUpdateOperationsInput | number | null
    niveauRequis?: NullableStringFieldUpdateOperationsInput | string | null
    estInterdit?: BoolFieldUpdateOperationsInput | boolean
    estRituel?: BoolFieldUpdateOperationsInput | boolean
    ecoleId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MaladieCreateInput = {
    nom: string
    effets?: string | null
    contagion?: string | null
    remede?: string | null
    tauxMortalite?: number | null
    cas?: PersonnageMaladieCreateNestedManyWithoutMaladieInput
  }

  export type MaladieUncheckedCreateInput = {
    id?: number
    nom: string
    effets?: string | null
    contagion?: string | null
    remede?: string | null
    tauxMortalite?: number | null
    cas?: PersonnageMaladieUncheckedCreateNestedManyWithoutMaladieInput
  }

  export type MaladieUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    effets?: NullableStringFieldUpdateOperationsInput | string | null
    contagion?: NullableStringFieldUpdateOperationsInput | string | null
    remede?: NullableStringFieldUpdateOperationsInput | string | null
    tauxMortalite?: NullableFloatFieldUpdateOperationsInput | number | null
    cas?: PersonnageMaladieUpdateManyWithoutMaladieNestedInput
  }

  export type MaladieUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    effets?: NullableStringFieldUpdateOperationsInput | string | null
    contagion?: NullableStringFieldUpdateOperationsInput | string | null
    remede?: NullableStringFieldUpdateOperationsInput | string | null
    tauxMortalite?: NullableFloatFieldUpdateOperationsInput | number | null
    cas?: PersonnageMaladieUncheckedUpdateManyWithoutMaladieNestedInput
  }

  export type MaladieCreateManyInput = {
    id?: number
    nom: string
    effets?: string | null
    contagion?: string | null
    remede?: string | null
    tauxMortalite?: number | null
  }

  export type MaladieUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    effets?: NullableStringFieldUpdateOperationsInput | string | null
    contagion?: NullableStringFieldUpdateOperationsInput | string | null
    remede?: NullableStringFieldUpdateOperationsInput | string | null
    tauxMortalite?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MaladieUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    effets?: NullableStringFieldUpdateOperationsInput | string | null
    contagion?: NullableStringFieldUpdateOperationsInput | string | null
    remede?: NullableStringFieldUpdateOperationsInput | string | null
    tauxMortalite?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PersonnageMaladieCreateInput = {
    dateDebut: Date | string
    dateFin?: Date | string | null
    issue?: string | null
    personnage: PersonnageCreateNestedOneWithoutMaladiesInput
    maladie: MaladieCreateNestedOneWithoutCasInput
  }

  export type PersonnageMaladieUncheckedCreateInput = {
    personnageId: number
    maladieId: number
    dateDebut: Date | string
    dateFin?: Date | string | null
    issue?: string | null
  }

  export type PersonnageMaladieUpdateInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    personnage?: PersonnageUpdateOneRequiredWithoutMaladiesNestedInput
    maladie?: MaladieUpdateOneRequiredWithoutCasNestedInput
  }

  export type PersonnageMaladieUncheckedUpdateInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    maladieId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageMaladieCreateManyInput = {
    personnageId: number
    maladieId: number
    dateDebut: Date | string
    dateFin?: Date | string | null
    issue?: string | null
  }

  export type PersonnageMaladieUpdateManyMutationInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageMaladieUncheckedUpdateManyInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    maladieId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArmeeCreateInput = {
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    domaine?: DomaineCreateNestedOneWithoutArmeesInput
    commandant?: PersonnageCreateNestedOneWithoutCommandementsInput
    batailles?: ArmeeBatailleCreateNestedManyWithoutArmeeInput
    inventaires?: InventaireCreateNestedManyWithoutArmeeInput
  }

  export type ArmeeUncheckedCreateInput = {
    id?: number
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    domaineId?: number | null
    commandantId?: number | null
    batailles?: ArmeeBatailleUncheckedCreateNestedManyWithoutArmeeInput
    inventaires?: InventaireUncheckedCreateNestedManyWithoutArmeeInput
  }

  export type ArmeeUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    domaine?: DomaineUpdateOneWithoutArmeesNestedInput
    commandant?: PersonnageUpdateOneWithoutCommandementsNestedInput
    batailles?: ArmeeBatailleUpdateManyWithoutArmeeNestedInput
    inventaires?: InventaireUpdateManyWithoutArmeeNestedInput
  }

  export type ArmeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    commandantId?: NullableIntFieldUpdateOperationsInput | number | null
    batailles?: ArmeeBatailleUncheckedUpdateManyWithoutArmeeNestedInput
    inventaires?: InventaireUncheckedUpdateManyWithoutArmeeNestedInput
  }

  export type ArmeeCreateManyInput = {
    id?: number
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    domaineId?: number | null
    commandantId?: number | null
  }

  export type ArmeeUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArmeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    commandantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BatailleCreateInput = {
    nom?: string | null
    dateBataille?: Date | string | null
    lieu?: string | null
    pertesA?: number | null
    pertesB?: number | null
    vainqueurTexte?: string | null
    armees?: ArmeeBatailleCreateNestedManyWithoutBatailleInput
    guildes?: GuildeBatailleCreateNestedManyWithoutBatailleInput
    creatures?: CreatureBatailleCreateNestedManyWithoutBatailleInput
  }

  export type BatailleUncheckedCreateInput = {
    id?: number
    nom?: string | null
    dateBataille?: Date | string | null
    lieu?: string | null
    pertesA?: number | null
    pertesB?: number | null
    vainqueurTexte?: string | null
    armees?: ArmeeBatailleUncheckedCreateNestedManyWithoutBatailleInput
    guildes?: GuildeBatailleUncheckedCreateNestedManyWithoutBatailleInput
    creatures?: CreatureBatailleUncheckedCreateNestedManyWithoutBatailleInput
  }

  export type BatailleUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dateBataille?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    pertesA?: NullableIntFieldUpdateOperationsInput | number | null
    pertesB?: NullableIntFieldUpdateOperationsInput | number | null
    vainqueurTexte?: NullableStringFieldUpdateOperationsInput | string | null
    armees?: ArmeeBatailleUpdateManyWithoutBatailleNestedInput
    guildes?: GuildeBatailleUpdateManyWithoutBatailleNestedInput
    creatures?: CreatureBatailleUpdateManyWithoutBatailleNestedInput
  }

  export type BatailleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dateBataille?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    pertesA?: NullableIntFieldUpdateOperationsInput | number | null
    pertesB?: NullableIntFieldUpdateOperationsInput | number | null
    vainqueurTexte?: NullableStringFieldUpdateOperationsInput | string | null
    armees?: ArmeeBatailleUncheckedUpdateManyWithoutBatailleNestedInput
    guildes?: GuildeBatailleUncheckedUpdateManyWithoutBatailleNestedInput
    creatures?: CreatureBatailleUncheckedUpdateManyWithoutBatailleNestedInput
  }

  export type BatailleCreateManyInput = {
    id?: number
    nom?: string | null
    dateBataille?: Date | string | null
    lieu?: string | null
    pertesA?: number | null
    pertesB?: number | null
    vainqueurTexte?: string | null
  }

  export type BatailleUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dateBataille?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    pertesA?: NullableIntFieldUpdateOperationsInput | number | null
    pertesB?: NullableIntFieldUpdateOperationsInput | number | null
    vainqueurTexte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatailleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dateBataille?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    pertesA?: NullableIntFieldUpdateOperationsInput | number | null
    pertesB?: NullableIntFieldUpdateOperationsInput | number | null
    vainqueurTexte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArmeeBatailleCreateInput = {
    cote?: string | null
    pertes?: number | null
    armee: ArmeeCreateNestedOneWithoutBataillesInput
    bataille: BatailleCreateNestedOneWithoutArmeesInput
  }

  export type ArmeeBatailleUncheckedCreateInput = {
    armeeId: number
    batailleId: number
    cote?: string | null
    pertes?: number | null
  }

  export type ArmeeBatailleUpdateInput = {
    cote?: NullableStringFieldUpdateOperationsInput | string | null
    pertes?: NullableIntFieldUpdateOperationsInput | number | null
    armee?: ArmeeUpdateOneRequiredWithoutBataillesNestedInput
    bataille?: BatailleUpdateOneRequiredWithoutArmeesNestedInput
  }

  export type ArmeeBatailleUncheckedUpdateInput = {
    armeeId?: IntFieldUpdateOperationsInput | number
    batailleId?: IntFieldUpdateOperationsInput | number
    cote?: NullableStringFieldUpdateOperationsInput | string | null
    pertes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmeeBatailleCreateManyInput = {
    armeeId: number
    batailleId: number
    cote?: string | null
    pertes?: number | null
  }

  export type ArmeeBatailleUpdateManyMutationInput = {
    cote?: NullableStringFieldUpdateOperationsInput | string | null
    pertes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmeeBatailleUncheckedUpdateManyInput = {
    armeeId?: IntFieldUpdateOperationsInput | number
    batailleId?: IntFieldUpdateOperationsInput | number
    cote?: NullableStringFieldUpdateOperationsInput | string | null
    pertes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GuildeBatailleCreateInput = {
    role?: string | null
    guilde: GuildeCreateNestedOneWithoutBataillesInput
    bataille: BatailleCreateNestedOneWithoutGuildesInput
  }

  export type GuildeBatailleUncheckedCreateInput = {
    guildeId: number
    batailleId: number
    role?: string | null
  }

  export type GuildeBatailleUpdateInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    guilde?: GuildeUpdateOneRequiredWithoutBataillesNestedInput
    bataille?: BatailleUpdateOneRequiredWithoutGuildesNestedInput
  }

  export type GuildeBatailleUncheckedUpdateInput = {
    guildeId?: IntFieldUpdateOperationsInput | number
    batailleId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildeBatailleCreateManyInput = {
    guildeId: number
    batailleId: number
    role?: string | null
  }

  export type GuildeBatailleUpdateManyMutationInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildeBatailleUncheckedUpdateManyInput = {
    guildeId?: IntFieldUpdateOperationsInput | number
    batailleId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureBatailleCreateInput = {
    nombre?: number | null
    role?: string | null
    creature: CreatureCreateNestedOneWithoutBataillesInput
    bataille: BatailleCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureBatailleUncheckedCreateInput = {
    creatureId: number
    batailleId: number
    nombre?: number | null
    role?: string | null
  }

  export type CreatureBatailleUpdateInput = {
    nombre?: NullableIntFieldUpdateOperationsInput | number | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    creature?: CreatureUpdateOneRequiredWithoutBataillesNestedInput
    bataille?: BatailleUpdateOneRequiredWithoutCreaturesNestedInput
  }

  export type CreatureBatailleUncheckedUpdateInput = {
    creatureId?: IntFieldUpdateOperationsInput | number
    batailleId?: IntFieldUpdateOperationsInput | number
    nombre?: NullableIntFieldUpdateOperationsInput | number | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureBatailleCreateManyInput = {
    creatureId: number
    batailleId: number
    nombre?: number | null
    role?: string | null
  }

  export type CreatureBatailleUpdateManyMutationInput = {
    nombre?: NullableIntFieldUpdateOperationsInput | number | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureBatailleUncheckedUpdateManyInput = {
    creatureId?: IntFieldUpdateOperationsInput | number
    batailleId?: IntFieldUpdateOperationsInput | number
    nombre?: NullableIntFieldUpdateOperationsInput | number | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipementCreateInput = {
    nom: string
    typeEquipement?: string | null
    materiaux?: string | null
    rarete?: string | null
    enchantements?: string | null
    affiniteRequise?: string | null
    possesseurs?: PersonnageEquipementCreateNestedManyWithoutEquipementInput
  }

  export type EquipementUncheckedCreateInput = {
    id?: number
    nom: string
    typeEquipement?: string | null
    materiaux?: string | null
    rarete?: string | null
    enchantements?: string | null
    affiniteRequise?: string | null
    possesseurs?: PersonnageEquipementUncheckedCreateNestedManyWithoutEquipementInput
  }

  export type EquipementUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    typeEquipement?: NullableStringFieldUpdateOperationsInput | string | null
    materiaux?: NullableStringFieldUpdateOperationsInput | string | null
    rarete?: NullableStringFieldUpdateOperationsInput | string | null
    enchantements?: NullableStringFieldUpdateOperationsInput | string | null
    affiniteRequise?: NullableStringFieldUpdateOperationsInput | string | null
    possesseurs?: PersonnageEquipementUpdateManyWithoutEquipementNestedInput
  }

  export type EquipementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    typeEquipement?: NullableStringFieldUpdateOperationsInput | string | null
    materiaux?: NullableStringFieldUpdateOperationsInput | string | null
    rarete?: NullableStringFieldUpdateOperationsInput | string | null
    enchantements?: NullableStringFieldUpdateOperationsInput | string | null
    affiniteRequise?: NullableStringFieldUpdateOperationsInput | string | null
    possesseurs?: PersonnageEquipementUncheckedUpdateManyWithoutEquipementNestedInput
  }

  export type EquipementCreateManyInput = {
    id?: number
    nom: string
    typeEquipement?: string | null
    materiaux?: string | null
    rarete?: string | null
    enchantements?: string | null
    affiniteRequise?: string | null
  }

  export type EquipementUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    typeEquipement?: NullableStringFieldUpdateOperationsInput | string | null
    materiaux?: NullableStringFieldUpdateOperationsInput | string | null
    rarete?: NullableStringFieldUpdateOperationsInput | string | null
    enchantements?: NullableStringFieldUpdateOperationsInput | string | null
    affiniteRequise?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    typeEquipement?: NullableStringFieldUpdateOperationsInput | string | null
    materiaux?: NullableStringFieldUpdateOperationsInput | string | null
    rarete?: NullableStringFieldUpdateOperationsInput | string | null
    enchantements?: NullableStringFieldUpdateOperationsInput | string | null
    affiniteRequise?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageEquipementCreateInput = {
    dateAcquisition?: Date | string | null
    source?: string | null
    personnage: PersonnageCreateNestedOneWithoutEquipementsInput
    equipement: EquipementCreateNestedOneWithoutPossesseursInput
  }

  export type PersonnageEquipementUncheckedCreateInput = {
    personnageId: number
    equipementId: number
    dateAcquisition?: Date | string | null
    source?: string | null
  }

  export type PersonnageEquipementUpdateInput = {
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    personnage?: PersonnageUpdateOneRequiredWithoutEquipementsNestedInput
    equipement?: EquipementUpdateOneRequiredWithoutPossesseursNestedInput
  }

  export type PersonnageEquipementUncheckedUpdateInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    equipementId?: IntFieldUpdateOperationsInput | number
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageEquipementCreateManyInput = {
    personnageId: number
    equipementId: number
    dateAcquisition?: Date | string | null
    source?: string | null
  }

  export type PersonnageEquipementUpdateManyMutationInput = {
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageEquipementUncheckedUpdateManyInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    equipementId?: IntFieldUpdateOperationsInput | number
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarchandCreateInput = {
    nom: string
    routes?: MarchandRouteCreateNestedManyWithoutMarchandInput
  }

  export type MarchandUncheckedCreateInput = {
    id?: number
    nom: string
    routes?: MarchandRouteUncheckedCreateNestedManyWithoutMarchandInput
  }

  export type MarchandUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    routes?: MarchandRouteUpdateManyWithoutMarchandNestedInput
  }

  export type MarchandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    routes?: MarchandRouteUncheckedUpdateManyWithoutMarchandNestedInput
  }

  export type MarchandCreateManyInput = {
    id?: number
    nom: string
  }

  export type MarchandUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type MarchandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type RouteCommercialeCreateInput = {
    nom: string
    securite?: string | null
    saison?: string | null
    segments?: RouteSegmentCreateNestedManyWithoutRouteInput
    marchands?: MarchandRouteCreateNestedManyWithoutRouteInput
  }

  export type RouteCommercialeUncheckedCreateInput = {
    id?: number
    nom: string
    securite?: string | null
    saison?: string | null
    segments?: RouteSegmentUncheckedCreateNestedManyWithoutRouteInput
    marchands?: MarchandRouteUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCommercialeUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    securite?: NullableStringFieldUpdateOperationsInput | string | null
    saison?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: RouteSegmentUpdateManyWithoutRouteNestedInput
    marchands?: MarchandRouteUpdateManyWithoutRouteNestedInput
  }

  export type RouteCommercialeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    securite?: NullableStringFieldUpdateOperationsInput | string | null
    saison?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: RouteSegmentUncheckedUpdateManyWithoutRouteNestedInput
    marchands?: MarchandRouteUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteCommercialeCreateManyInput = {
    id?: number
    nom: string
    securite?: string | null
    saison?: string | null
  }

  export type RouteCommercialeUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    securite?: NullableStringFieldUpdateOperationsInput | string | null
    saison?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RouteCommercialeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    securite?: NullableStringFieldUpdateOperationsInput | string | null
    saison?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LieuCreateInput = {
    nom: string
    typeLieu?: string | null
    localisation?: string | null
    segments?: RouteSegmentCreateNestedManyWithoutLieuInput
    inventaires?: InventaireCreateNestedManyWithoutLieuInput
  }

  export type LieuUncheckedCreateInput = {
    id?: number
    nom: string
    typeLieu?: string | null
    localisation?: string | null
    segments?: RouteSegmentUncheckedCreateNestedManyWithoutLieuInput
    inventaires?: InventaireUncheckedCreateNestedManyWithoutLieuInput
  }

  export type LieuUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    typeLieu?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: RouteSegmentUpdateManyWithoutLieuNestedInput
    inventaires?: InventaireUpdateManyWithoutLieuNestedInput
  }

  export type LieuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    typeLieu?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: RouteSegmentUncheckedUpdateManyWithoutLieuNestedInput
    inventaires?: InventaireUncheckedUpdateManyWithoutLieuNestedInput
  }

  export type LieuCreateManyInput = {
    id?: number
    nom: string
    typeLieu?: string | null
    localisation?: string | null
  }

  export type LieuUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    typeLieu?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LieuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    typeLieu?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RouteSegmentCreateInput = {
    ordre: number
    route: RouteCommercialeCreateNestedOneWithoutSegmentsInput
    lieu: LieuCreateNestedOneWithoutSegmentsInput
  }

  export type RouteSegmentUncheckedCreateInput = {
    routeId: number
    lieuId: number
    ordre: number
  }

  export type RouteSegmentUpdateInput = {
    ordre?: IntFieldUpdateOperationsInput | number
    route?: RouteCommercialeUpdateOneRequiredWithoutSegmentsNestedInput
    lieu?: LieuUpdateOneRequiredWithoutSegmentsNestedInput
  }

  export type RouteSegmentUncheckedUpdateInput = {
    routeId?: IntFieldUpdateOperationsInput | number
    lieuId?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type RouteSegmentCreateManyInput = {
    routeId: number
    lieuId: number
    ordre: number
  }

  export type RouteSegmentUpdateManyMutationInput = {
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type RouteSegmentUncheckedUpdateManyInput = {
    routeId?: IntFieldUpdateOperationsInput | number
    lieuId?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type MarchandRouteCreateInput = {
    biens?: string | null
    taxes?: number | null
    marchand: MarchandCreateNestedOneWithoutRoutesInput
    route: RouteCommercialeCreateNestedOneWithoutMarchandsInput
  }

  export type MarchandRouteUncheckedCreateInput = {
    marchandId: number
    routeId: number
    biens?: string | null
    taxes?: number | null
  }

  export type MarchandRouteUpdateInput = {
    biens?: NullableStringFieldUpdateOperationsInput | string | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    marchand?: MarchandUpdateOneRequiredWithoutRoutesNestedInput
    route?: RouteCommercialeUpdateOneRequiredWithoutMarchandsNestedInput
  }

  export type MarchandRouteUncheckedUpdateInput = {
    marchandId?: IntFieldUpdateOperationsInput | number
    routeId?: IntFieldUpdateOperationsInput | number
    biens?: NullableStringFieldUpdateOperationsInput | string | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MarchandRouteCreateManyInput = {
    marchandId: number
    routeId: number
    biens?: string | null
    taxes?: number | null
  }

  export type MarchandRouteUpdateManyMutationInput = {
    biens?: NullableStringFieldUpdateOperationsInput | string | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MarchandRouteUncheckedUpdateManyInput = {
    marchandId?: IntFieldUpdateOperationsInput | number
    routeId?: IntFieldUpdateOperationsInput | number
    biens?: NullableStringFieldUpdateOperationsInput | string | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BardeCreateInput = {
    nom: string
    histoires?: HistoireCreateNestedManyWithoutBardeInput
  }

  export type BardeUncheckedCreateInput = {
    id?: number
    nom: string
    histoires?: HistoireUncheckedCreateNestedManyWithoutBardeInput
  }

  export type BardeUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    histoires?: HistoireUpdateManyWithoutBardeNestedInput
  }

  export type BardeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    histoires?: HistoireUncheckedUpdateManyWithoutBardeNestedInput
  }

  export type BardeCreateManyInput = {
    id?: number
    nom: string
  }

  export type BardeUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type BardeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type HistoireCreateInput = {
    titre?: string | null
    typeEvenement?: string | null
    description?: string | null
    dateEvenement?: Date | string | null
    barde?: BardeCreateNestedOneWithoutHistoiresInput
  }

  export type HistoireUncheckedCreateInput = {
    id?: number
    titre?: string | null
    typeEvenement?: string | null
    description?: string | null
    dateEvenement?: Date | string | null
    bardeId?: number | null
  }

  export type HistoireUpdateInput = {
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateEvenement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barde?: BardeUpdateOneWithoutHistoiresNestedInput
  }

  export type HistoireUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateEvenement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bardeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HistoireCreateManyInput = {
    id?: number
    titre?: string | null
    typeEvenement?: string | null
    description?: string | null
    dateEvenement?: Date | string | null
    bardeId?: number | null
  }

  export type HistoireUpdateManyMutationInput = {
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateEvenement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistoireUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateEvenement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bardeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventaireCreateInput = {
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    lieu?: LieuCreateNestedOneWithoutInventairesInput
    armee?: ArmeeCreateNestedOneWithoutInventairesInput
    Village?: VillageCreateNestedOneWithoutInventairesInput
  }

  export type InventaireUncheckedCreateInput = {
    id?: number
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    lieuId?: number | null
    armeeId?: number | null
    villageId?: number | null
  }

  export type InventaireUpdateInput = {
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: LieuUpdateOneWithoutInventairesNestedInput
    armee?: ArmeeUpdateOneWithoutInventairesNestedInput
    Village?: VillageUpdateOneWithoutInventairesNestedInput
  }

  export type InventaireUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuId?: NullableIntFieldUpdateOperationsInput | number | null
    armeeId?: NullableIntFieldUpdateOperationsInput | number | null
    villageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventaireCreateManyInput = {
    id?: number
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    lieuId?: number | null
    armeeId?: number | null
    villageId?: number | null
  }

  export type InventaireUpdateManyMutationInput = {
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventaireUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuId?: NullableIntFieldUpdateOperationsInput | number | null
    armeeId?: NullableIntFieldUpdateOperationsInput | number | null
    villageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RelationDiplomatiqueCreateInput = {
    typeRelation?: string | null
    conditions?: string | null
    dateSignature?: Date | string | null
    echeance?: string | null
    domaineSource: DomaineCreateNestedOneWithoutRelationsSourceInput
    domaineCible: DomaineCreateNestedOneWithoutRelationsCibleInput
  }

  export type RelationDiplomatiqueUncheckedCreateInput = {
    id?: number
    typeRelation?: string | null
    conditions?: string | null
    dateSignature?: Date | string | null
    echeance?: string | null
    domaineSourceId: number
    domaineCibleId: number
  }

  export type RelationDiplomatiqueUpdateInput = {
    typeRelation?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    echeance?: NullableStringFieldUpdateOperationsInput | string | null
    domaineSource?: DomaineUpdateOneRequiredWithoutRelationsSourceNestedInput
    domaineCible?: DomaineUpdateOneRequiredWithoutRelationsCibleNestedInput
  }

  export type RelationDiplomatiqueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRelation?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    echeance?: NullableStringFieldUpdateOperationsInput | string | null
    domaineSourceId?: IntFieldUpdateOperationsInput | number
    domaineCibleId?: IntFieldUpdateOperationsInput | number
  }

  export type RelationDiplomatiqueCreateManyInput = {
    id?: number
    typeRelation?: string | null
    conditions?: string | null
    dateSignature?: Date | string | null
    echeance?: string | null
    domaineSourceId: number
    domaineCibleId: number
  }

  export type RelationDiplomatiqueUpdateManyMutationInput = {
    typeRelation?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    echeance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RelationDiplomatiqueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRelation?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    echeance?: NullableStringFieldUpdateOperationsInput | string | null
    domaineSourceId?: IntFieldUpdateOperationsInput | number
    domaineCibleId?: IntFieldUpdateOperationsInput | number
  }

  export type LoiCreateInput = {
    libelle: string
    effet?: string | null
    domaines?: LoiTerritoireCreateNestedManyWithoutLoiInput
  }

  export type LoiUncheckedCreateInput = {
    id?: number
    libelle: string
    effet?: string | null
    domaines?: LoiTerritoireUncheckedCreateNestedManyWithoutLoiInput
  }

  export type LoiUpdateInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    effet?: NullableStringFieldUpdateOperationsInput | string | null
    domaines?: LoiTerritoireUpdateManyWithoutLoiNestedInput
  }

  export type LoiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    effet?: NullableStringFieldUpdateOperationsInput | string | null
    domaines?: LoiTerritoireUncheckedUpdateManyWithoutLoiNestedInput
  }

  export type LoiCreateManyInput = {
    id?: number
    libelle: string
    effet?: string | null
  }

  export type LoiUpdateManyMutationInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    effet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    effet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoiTerritoireCreateInput = {
    loi: LoiCreateNestedOneWithoutDomainesInput
    domaine: DomaineCreateNestedOneWithoutLoisInput
  }

  export type LoiTerritoireUncheckedCreateInput = {
    loiId: number
    domaineId: number
  }

  export type LoiTerritoireUpdateInput = {
    loi?: LoiUpdateOneRequiredWithoutDomainesNestedInput
    domaine?: DomaineUpdateOneRequiredWithoutLoisNestedInput
  }

  export type LoiTerritoireUncheckedUpdateInput = {
    loiId?: IntFieldUpdateOperationsInput | number
    domaineId?: IntFieldUpdateOperationsInput | number
  }

  export type LoiTerritoireCreateManyInput = {
    loiId: number
    domaineId: number
  }

  export type LoiTerritoireUpdateManyMutationInput = {

  }

  export type LoiTerritoireUncheckedUpdateManyInput = {
    loiId?: IntFieldUpdateOperationsInput | number
    domaineId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type PersonnageListRelationFilter = {
    every?: PersonnageWhereInput
    some?: PersonnageWhereInput
    none?: PersonnageWhereInput
  }

  export type CompetenceListRelationFilter = {
    every?: CompetenceWhereInput
    some?: CompetenceWhereInput
    none?: CompetenceWhereInput
  }

  export type PersonnageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompetenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaceCountOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type RaceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RaceMaxOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type RaceMinOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type RaceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type PersonnageRoleListRelationFilter = {
    every?: PersonnageRoleWhereInput
    some?: PersonnageRoleWhereInput
    none?: PersonnageRoleWhereInput
  }

  export type PersonnageRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PersonnageTitreListRelationFilter = {
    every?: PersonnageTitreWhereInput
    some?: PersonnageTitreWhereInput
    none?: PersonnageTitreWhereInput
  }

  export type PersonnageTitreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LigneeCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type LigneeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LigneeMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type LigneeMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type LigneeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RaceNullableRelationFilter = {
    is?: RaceWhereInput | null
    isNot?: RaceWhereInput | null
  }

  export type LigneeNullableRelationFilter = {
    is?: LigneeWhereInput | null
    isNot?: LigneeWhereInput | null
  }

  export type PersonnageCompetenceListRelationFilter = {
    every?: PersonnageCompetenceWhereInput
    some?: PersonnageCompetenceWhereInput
    none?: PersonnageCompetenceWhereInput
  }

  export type PersonnageMaladieListRelationFilter = {
    every?: PersonnageMaladieWhereInput
    some?: PersonnageMaladieWhereInput
    none?: PersonnageMaladieWhereInput
  }

  export type ArmeeListRelationFilter = {
    every?: ArmeeWhereInput
    some?: ArmeeWhereInput
    none?: ArmeeWhereInput
  }

  export type PersonnageEquipementListRelationFilter = {
    every?: PersonnageEquipementWhereInput
    some?: PersonnageEquipementWhereInput
    none?: PersonnageEquipementWhereInput
  }

  export type GuildeMembreListRelationFilter = {
    every?: GuildeMembreWhereInput
    some?: GuildeMembreWhereInput
    none?: GuildeMembreWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PersonnageCompetenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonnageMaladieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArmeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonnageEquipementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuildeMembreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonnageCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    dateNaissance?: SortOrder
    statutVie?: SortOrder
    dateDeces?: SortOrder
    causeDeces?: SortOrder
    raceId?: SortOrder
    ligneeId?: SortOrder
  }

  export type PersonnageAvgOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    ligneeId?: SortOrder
  }

  export type PersonnageMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    dateNaissance?: SortOrder
    statutVie?: SortOrder
    dateDeces?: SortOrder
    causeDeces?: SortOrder
    raceId?: SortOrder
    ligneeId?: SortOrder
  }

  export type PersonnageMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    dateNaissance?: SortOrder
    statutVie?: SortOrder
    dateDeces?: SortOrder
    causeDeces?: SortOrder
    raceId?: SortOrder
    ligneeId?: SortOrder
  }

  export type PersonnageSumOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    ligneeId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PersonnageRelationFilter = {
    is?: PersonnageWhereInput
    isNot?: PersonnageWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PersonnageRolePersonnageIdRoleIdCompoundUniqueInput = {
    personnageId: number
    roleId: number
  }

  export type PersonnageRoleCountOrderByAggregateInput = {
    personnageId?: SortOrder
    roleId?: SortOrder
  }

  export type PersonnageRoleAvgOrderByAggregateInput = {
    personnageId?: SortOrder
    roleId?: SortOrder
  }

  export type PersonnageRoleMaxOrderByAggregateInput = {
    personnageId?: SortOrder
    roleId?: SortOrder
  }

  export type PersonnageRoleMinOrderByAggregateInput = {
    personnageId?: SortOrder
    roleId?: SortOrder
  }

  export type PersonnageRoleSumOrderByAggregateInput = {
    personnageId?: SortOrder
    roleId?: SortOrder
  }

  export type CompetenceCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    exigenceFormation?: SortOrder
    exigenceRaceId?: SortOrder
  }

  export type CompetenceAvgOrderByAggregateInput = {
    id?: SortOrder
    exigenceRaceId?: SortOrder
  }

  export type CompetenceMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    exigenceFormation?: SortOrder
    exigenceRaceId?: SortOrder
  }

  export type CompetenceMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    exigenceFormation?: SortOrder
    exigenceRaceId?: SortOrder
  }

  export type CompetenceSumOrderByAggregateInput = {
    id?: SortOrder
    exigenceRaceId?: SortOrder
  }

  export type CompetenceRelationFilter = {
    is?: CompetenceWhereInput
    isNot?: CompetenceWhereInput
  }

  export type PersonnageCompetencePersonnageIdCompetenceIdCompoundUniqueInput = {
    personnageId: number
    competenceId: number
  }

  export type PersonnageCompetenceCountOrderByAggregateInput = {
    personnageId?: SortOrder
    competenceId?: SortOrder
    niveau?: SortOrder
  }

  export type PersonnageCompetenceAvgOrderByAggregateInput = {
    personnageId?: SortOrder
    competenceId?: SortOrder
    niveau?: SortOrder
  }

  export type PersonnageCompetenceMaxOrderByAggregateInput = {
    personnageId?: SortOrder
    competenceId?: SortOrder
    niveau?: SortOrder
  }

  export type PersonnageCompetenceMinOrderByAggregateInput = {
    personnageId?: SortOrder
    competenceId?: SortOrder
    niveau?: SortOrder
  }

  export type PersonnageCompetenceSumOrderByAggregateInput = {
    personnageId?: SortOrder
    competenceId?: SortOrder
    niveau?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type VillageListRelationFilter = {
    every?: VillageWhereInput
    some?: VillageWhereInput
    none?: VillageWhereInput
  }

  export type RelationDiplomatiqueListRelationFilter = {
    every?: RelationDiplomatiqueWhereInput
    some?: RelationDiplomatiqueWhereInput
    none?: RelationDiplomatiqueWhereInput
  }

  export type LoiTerritoireListRelationFilter = {
    every?: LoiTerritoireWhereInput
    some?: LoiTerritoireWhereInput
    none?: LoiTerritoireWhereInput
  }

  export type VillageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelationDiplomatiqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoiTerritoireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomaineCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    frontieres?: SortOrder
    richessesOr?: SortOrder
    ressources?: SortOrder
  }

  export type DomaineAvgOrderByAggregateInput = {
    id?: SortOrder
    richessesOr?: SortOrder
  }

  export type DomaineMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    frontieres?: SortOrder
    richessesOr?: SortOrder
    ressources?: SortOrder
  }

  export type DomaineMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    frontieres?: SortOrder
    richessesOr?: SortOrder
    ressources?: SortOrder
  }

  export type DomaineSumOrderByAggregateInput = {
    id?: SortOrder
    richessesOr?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type TitreCountOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type TitreAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TitreMaxOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type TitreMinOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type TitreSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TitreRelationFilter = {
    is?: TitreWhereInput
    isNot?: TitreWhereInput
  }

  export type DomaineNullableRelationFilter = {
    is?: DomaineWhereInput | null
    isNot?: DomaineWhereInput | null
  }

  export type PersonnageTitreCountOrderByAggregateInput = {
    id?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    estActif?: SortOrder
    personnageId?: SortOrder
    titreId?: SortOrder
    domaineId?: SortOrder
    ligneeId?: SortOrder
  }

  export type PersonnageTitreAvgOrderByAggregateInput = {
    id?: SortOrder
    personnageId?: SortOrder
    titreId?: SortOrder
    domaineId?: SortOrder
    ligneeId?: SortOrder
  }

  export type PersonnageTitreMaxOrderByAggregateInput = {
    id?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    estActif?: SortOrder
    personnageId?: SortOrder
    titreId?: SortOrder
    domaineId?: SortOrder
    ligneeId?: SortOrder
  }

  export type PersonnageTitreMinOrderByAggregateInput = {
    id?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    estActif?: SortOrder
    personnageId?: SortOrder
    titreId?: SortOrder
    domaineId?: SortOrder
    ligneeId?: SortOrder
  }

  export type PersonnageTitreSumOrderByAggregateInput = {
    id?: SortOrder
    personnageId?: SortOrder
    titreId?: SortOrder
    domaineId?: SortOrder
    ligneeId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type InventaireListRelationFilter = {
    every?: InventaireWhereInput
    some?: InventaireWhereInput
    none?: InventaireWhereInput
  }

  export type InventaireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VillageCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    localisation?: SortOrder
    population?: SortOrder
    ressourcePrincipale?: SortOrder
    domaineId?: SortOrder
  }

  export type VillageAvgOrderByAggregateInput = {
    id?: SortOrder
    population?: SortOrder
    domaineId?: SortOrder
  }

  export type VillageMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    localisation?: SortOrder
    population?: SortOrder
    ressourcePrincipale?: SortOrder
    domaineId?: SortOrder
  }

  export type VillageMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    localisation?: SortOrder
    population?: SortOrder
    ressourcePrincipale?: SortOrder
    domaineId?: SortOrder
  }

  export type VillageSumOrderByAggregateInput = {
    id?: SortOrder
    population?: SortOrder
    domaineId?: SortOrder
  }

  export type GuildeBatailleListRelationFilter = {
    every?: GuildeBatailleWhereInput
    some?: GuildeBatailleWhereInput
    none?: GuildeBatailleWhereInput
  }

  export type GuildeBatailleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuildeCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    specialite?: SortOrder
    reputation?: SortOrder
  }

  export type GuildeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuildeMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    specialite?: SortOrder
    reputation?: SortOrder
  }

  export type GuildeMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    specialite?: SortOrder
    reputation?: SortOrder
  }

  export type GuildeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuildeRelationFilter = {
    is?: GuildeWhereInput
    isNot?: GuildeWhereInput
  }

  export type GuildeMembrePersonnageIdGuildeIdCompoundUniqueInput = {
    personnageId: number
    guildeId: number
  }

  export type GuildeMembreCountOrderByAggregateInput = {
    personnageId?: SortOrder
    guildeId?: SortOrder
    dateEntree?: SortOrder
    dateSortie?: SortOrder
  }

  export type GuildeMembreAvgOrderByAggregateInput = {
    personnageId?: SortOrder
    guildeId?: SortOrder
  }

  export type GuildeMembreMaxOrderByAggregateInput = {
    personnageId?: SortOrder
    guildeId?: SortOrder
    dateEntree?: SortOrder
    dateSortie?: SortOrder
  }

  export type GuildeMembreMinOrderByAggregateInput = {
    personnageId?: SortOrder
    guildeId?: SortOrder
    dateEntree?: SortOrder
    dateSortie?: SortOrder
  }

  export type GuildeMembreSumOrderByAggregateInput = {
    personnageId?: SortOrder
    guildeId?: SortOrder
  }

  export type CreatureBatailleListRelationFilter = {
    every?: CreatureBatailleWhereInput
    some?: CreatureBatailleWhereInput
    none?: CreatureBatailleWhereInput
  }

  export type CreatureBatailleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatureCountOrderByAggregateInput = {
    id?: SortOrder
    espece?: SortOrder
    forces?: SortOrder
    faiblesses?: SortOrder
    dangerosite?: SortOrder
  }

  export type CreatureAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatureMaxOrderByAggregateInput = {
    id?: SortOrder
    espece?: SortOrder
    forces?: SortOrder
    faiblesses?: SortOrder
    dangerosite?: SortOrder
  }

  export type CreatureMinOrderByAggregateInput = {
    id?: SortOrder
    espece?: SortOrder
    forces?: SortOrder
    faiblesses?: SortOrder
    dangerosite?: SortOrder
  }

  export type CreatureSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SortListRelationFilter = {
    every?: SortWhereInput
    some?: SortWhereInput
    none?: SortWhereInput
  }

  export type SortOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EcoleMagieCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type EcoleMagieAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EcoleMagieMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type EcoleMagieMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type EcoleMagieSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EcoleMagieNullableRelationFilter = {
    is?: EcoleMagieWhereInput | null
    isNot?: EcoleMagieWhereInput | null
  }

  export type SortCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    element?: SortOrder
    coutMana?: SortOrder
    niveauRequis?: SortOrder
    estInterdit?: SortOrder
    estRituel?: SortOrder
    ecoleId?: SortOrder
  }

  export type SortAvgOrderByAggregateInput = {
    id?: SortOrder
    coutMana?: SortOrder
    ecoleId?: SortOrder
  }

  export type SortMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    element?: SortOrder
    coutMana?: SortOrder
    niveauRequis?: SortOrder
    estInterdit?: SortOrder
    estRituel?: SortOrder
    ecoleId?: SortOrder
  }

  export type SortMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    element?: SortOrder
    coutMana?: SortOrder
    niveauRequis?: SortOrder
    estInterdit?: SortOrder
    estRituel?: SortOrder
    ecoleId?: SortOrder
  }

  export type SortSumOrderByAggregateInput = {
    id?: SortOrder
    coutMana?: SortOrder
    ecoleId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MaladieCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    effets?: SortOrder
    contagion?: SortOrder
    remede?: SortOrder
    tauxMortalite?: SortOrder
  }

  export type MaladieAvgOrderByAggregateInput = {
    id?: SortOrder
    tauxMortalite?: SortOrder
  }

  export type MaladieMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    effets?: SortOrder
    contagion?: SortOrder
    remede?: SortOrder
    tauxMortalite?: SortOrder
  }

  export type MaladieMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    effets?: SortOrder
    contagion?: SortOrder
    remede?: SortOrder
    tauxMortalite?: SortOrder
  }

  export type MaladieSumOrderByAggregateInput = {
    id?: SortOrder
    tauxMortalite?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MaladieRelationFilter = {
    is?: MaladieWhereInput
    isNot?: MaladieWhereInput
  }

  export type PersonnageMaladiePersonnageIdMaladieIdDateDebutCompoundUniqueInput = {
    personnageId: number
    maladieId: number
    dateDebut: Date | string
  }

  export type PersonnageMaladieCountOrderByAggregateInput = {
    personnageId?: SortOrder
    maladieId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    issue?: SortOrder
  }

  export type PersonnageMaladieAvgOrderByAggregateInput = {
    personnageId?: SortOrder
    maladieId?: SortOrder
  }

  export type PersonnageMaladieMaxOrderByAggregateInput = {
    personnageId?: SortOrder
    maladieId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    issue?: SortOrder
  }

  export type PersonnageMaladieMinOrderByAggregateInput = {
    personnageId?: SortOrder
    maladieId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    issue?: SortOrder
  }

  export type PersonnageMaladieSumOrderByAggregateInput = {
    personnageId?: SortOrder
    maladieId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PersonnageNullableRelationFilter = {
    is?: PersonnageWhereInput | null
    isNot?: PersonnageWhereInput | null
  }

  export type ArmeeBatailleListRelationFilter = {
    every?: ArmeeBatailleWhereInput
    some?: ArmeeBatailleWhereInput
    none?: ArmeeBatailleWhereInput
  }

  export type ArmeeBatailleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArmeeCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    effectif?: SortOrder
    composition?: SortOrder
    moral?: SortOrder
    etatApprovisionnement?: SortOrder
    domaineId?: SortOrder
    commandantId?: SortOrder
  }

  export type ArmeeAvgOrderByAggregateInput = {
    id?: SortOrder
    effectif?: SortOrder
    domaineId?: SortOrder
    commandantId?: SortOrder
  }

  export type ArmeeMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    effectif?: SortOrder
    composition?: SortOrder
    moral?: SortOrder
    etatApprovisionnement?: SortOrder
    domaineId?: SortOrder
    commandantId?: SortOrder
  }

  export type ArmeeMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    effectif?: SortOrder
    composition?: SortOrder
    moral?: SortOrder
    etatApprovisionnement?: SortOrder
    domaineId?: SortOrder
    commandantId?: SortOrder
  }

  export type ArmeeSumOrderByAggregateInput = {
    id?: SortOrder
    effectif?: SortOrder
    domaineId?: SortOrder
    commandantId?: SortOrder
  }

  export type BatailleCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    dateBataille?: SortOrder
    lieu?: SortOrder
    pertesA?: SortOrder
    pertesB?: SortOrder
    vainqueurTexte?: SortOrder
  }

  export type BatailleAvgOrderByAggregateInput = {
    id?: SortOrder
    pertesA?: SortOrder
    pertesB?: SortOrder
  }

  export type BatailleMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    dateBataille?: SortOrder
    lieu?: SortOrder
    pertesA?: SortOrder
    pertesB?: SortOrder
    vainqueurTexte?: SortOrder
  }

  export type BatailleMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    dateBataille?: SortOrder
    lieu?: SortOrder
    pertesA?: SortOrder
    pertesB?: SortOrder
    vainqueurTexte?: SortOrder
  }

  export type BatailleSumOrderByAggregateInput = {
    id?: SortOrder
    pertesA?: SortOrder
    pertesB?: SortOrder
  }

  export type ArmeeRelationFilter = {
    is?: ArmeeWhereInput
    isNot?: ArmeeWhereInput
  }

  export type BatailleRelationFilter = {
    is?: BatailleWhereInput
    isNot?: BatailleWhereInput
  }

  export type ArmeeBatailleArmeeIdBatailleIdCompoundUniqueInput = {
    armeeId: number
    batailleId: number
  }

  export type ArmeeBatailleCountOrderByAggregateInput = {
    armeeId?: SortOrder
    batailleId?: SortOrder
    cote?: SortOrder
    pertes?: SortOrder
  }

  export type ArmeeBatailleAvgOrderByAggregateInput = {
    armeeId?: SortOrder
    batailleId?: SortOrder
    pertes?: SortOrder
  }

  export type ArmeeBatailleMaxOrderByAggregateInput = {
    armeeId?: SortOrder
    batailleId?: SortOrder
    cote?: SortOrder
    pertes?: SortOrder
  }

  export type ArmeeBatailleMinOrderByAggregateInput = {
    armeeId?: SortOrder
    batailleId?: SortOrder
    cote?: SortOrder
    pertes?: SortOrder
  }

  export type ArmeeBatailleSumOrderByAggregateInput = {
    armeeId?: SortOrder
    batailleId?: SortOrder
    pertes?: SortOrder
  }

  export type GuildeBatailleGuildeIdBatailleIdCompoundUniqueInput = {
    guildeId: number
    batailleId: number
  }

  export type GuildeBatailleCountOrderByAggregateInput = {
    guildeId?: SortOrder
    batailleId?: SortOrder
    role?: SortOrder
  }

  export type GuildeBatailleAvgOrderByAggregateInput = {
    guildeId?: SortOrder
    batailleId?: SortOrder
  }

  export type GuildeBatailleMaxOrderByAggregateInput = {
    guildeId?: SortOrder
    batailleId?: SortOrder
    role?: SortOrder
  }

  export type GuildeBatailleMinOrderByAggregateInput = {
    guildeId?: SortOrder
    batailleId?: SortOrder
    role?: SortOrder
  }

  export type GuildeBatailleSumOrderByAggregateInput = {
    guildeId?: SortOrder
    batailleId?: SortOrder
  }

  export type CreatureRelationFilter = {
    is?: CreatureWhereInput
    isNot?: CreatureWhereInput
  }

  export type CreatureBatailleCreatureIdBatailleIdCompoundUniqueInput = {
    creatureId: number
    batailleId: number
  }

  export type CreatureBatailleCountOrderByAggregateInput = {
    creatureId?: SortOrder
    batailleId?: SortOrder
    nombre?: SortOrder
    role?: SortOrder
  }

  export type CreatureBatailleAvgOrderByAggregateInput = {
    creatureId?: SortOrder
    batailleId?: SortOrder
    nombre?: SortOrder
  }

  export type CreatureBatailleMaxOrderByAggregateInput = {
    creatureId?: SortOrder
    batailleId?: SortOrder
    nombre?: SortOrder
    role?: SortOrder
  }

  export type CreatureBatailleMinOrderByAggregateInput = {
    creatureId?: SortOrder
    batailleId?: SortOrder
    nombre?: SortOrder
    role?: SortOrder
  }

  export type CreatureBatailleSumOrderByAggregateInput = {
    creatureId?: SortOrder
    batailleId?: SortOrder
    nombre?: SortOrder
  }

  export type EquipementCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    typeEquipement?: SortOrder
    materiaux?: SortOrder
    rarete?: SortOrder
    enchantements?: SortOrder
    affiniteRequise?: SortOrder
  }

  export type EquipementAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EquipementMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    typeEquipement?: SortOrder
    materiaux?: SortOrder
    rarete?: SortOrder
    enchantements?: SortOrder
    affiniteRequise?: SortOrder
  }

  export type EquipementMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    typeEquipement?: SortOrder
    materiaux?: SortOrder
    rarete?: SortOrder
    enchantements?: SortOrder
    affiniteRequise?: SortOrder
  }

  export type EquipementSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EquipementRelationFilter = {
    is?: EquipementWhereInput
    isNot?: EquipementWhereInput
  }

  export type PersonnageEquipementPersonnageIdEquipementIdCompoundUniqueInput = {
    personnageId: number
    equipementId: number
  }

  export type PersonnageEquipementCountOrderByAggregateInput = {
    personnageId?: SortOrder
    equipementId?: SortOrder
    dateAcquisition?: SortOrder
    source?: SortOrder
  }

  export type PersonnageEquipementAvgOrderByAggregateInput = {
    personnageId?: SortOrder
    equipementId?: SortOrder
  }

  export type PersonnageEquipementMaxOrderByAggregateInput = {
    personnageId?: SortOrder
    equipementId?: SortOrder
    dateAcquisition?: SortOrder
    source?: SortOrder
  }

  export type PersonnageEquipementMinOrderByAggregateInput = {
    personnageId?: SortOrder
    equipementId?: SortOrder
    dateAcquisition?: SortOrder
    source?: SortOrder
  }

  export type PersonnageEquipementSumOrderByAggregateInput = {
    personnageId?: SortOrder
    equipementId?: SortOrder
  }

  export type MarchandRouteListRelationFilter = {
    every?: MarchandRouteWhereInput
    some?: MarchandRouteWhereInput
    none?: MarchandRouteWhereInput
  }

  export type MarchandRouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarchandCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type MarchandAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarchandMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type MarchandMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type MarchandSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RouteSegmentListRelationFilter = {
    every?: RouteSegmentWhereInput
    some?: RouteSegmentWhereInput
    none?: RouteSegmentWhereInput
  }

  export type RouteSegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RouteCommercialeCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    securite?: SortOrder
    saison?: SortOrder
  }

  export type RouteCommercialeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RouteCommercialeMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    securite?: SortOrder
    saison?: SortOrder
  }

  export type RouteCommercialeMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    securite?: SortOrder
    saison?: SortOrder
  }

  export type RouteCommercialeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LieuCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    typeLieu?: SortOrder
    localisation?: SortOrder
  }

  export type LieuAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LieuMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    typeLieu?: SortOrder
    localisation?: SortOrder
  }

  export type LieuMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    typeLieu?: SortOrder
    localisation?: SortOrder
  }

  export type LieuSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RouteCommercialeRelationFilter = {
    is?: RouteCommercialeWhereInput
    isNot?: RouteCommercialeWhereInput
  }

  export type LieuRelationFilter = {
    is?: LieuWhereInput
    isNot?: LieuWhereInput
  }

  export type RouteSegmentRouteIdLieuIdOrdreCompoundUniqueInput = {
    routeId: number
    lieuId: number
    ordre: number
  }

  export type RouteSegmentCountOrderByAggregateInput = {
    routeId?: SortOrder
    lieuId?: SortOrder
    ordre?: SortOrder
  }

  export type RouteSegmentAvgOrderByAggregateInput = {
    routeId?: SortOrder
    lieuId?: SortOrder
    ordre?: SortOrder
  }

  export type RouteSegmentMaxOrderByAggregateInput = {
    routeId?: SortOrder
    lieuId?: SortOrder
    ordre?: SortOrder
  }

  export type RouteSegmentMinOrderByAggregateInput = {
    routeId?: SortOrder
    lieuId?: SortOrder
    ordre?: SortOrder
  }

  export type RouteSegmentSumOrderByAggregateInput = {
    routeId?: SortOrder
    lieuId?: SortOrder
    ordre?: SortOrder
  }

  export type MarchandRelationFilter = {
    is?: MarchandWhereInput
    isNot?: MarchandWhereInput
  }

  export type MarchandRouteMarchandIdRouteIdCompoundUniqueInput = {
    marchandId: number
    routeId: number
  }

  export type MarchandRouteCountOrderByAggregateInput = {
    marchandId?: SortOrder
    routeId?: SortOrder
    biens?: SortOrder
    taxes?: SortOrder
  }

  export type MarchandRouteAvgOrderByAggregateInput = {
    marchandId?: SortOrder
    routeId?: SortOrder
    taxes?: SortOrder
  }

  export type MarchandRouteMaxOrderByAggregateInput = {
    marchandId?: SortOrder
    routeId?: SortOrder
    biens?: SortOrder
    taxes?: SortOrder
  }

  export type MarchandRouteMinOrderByAggregateInput = {
    marchandId?: SortOrder
    routeId?: SortOrder
    biens?: SortOrder
    taxes?: SortOrder
  }

  export type MarchandRouteSumOrderByAggregateInput = {
    marchandId?: SortOrder
    routeId?: SortOrder
    taxes?: SortOrder
  }

  export type HistoireListRelationFilter = {
    every?: HistoireWhereInput
    some?: HistoireWhereInput
    none?: HistoireWhereInput
  }

  export type HistoireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BardeCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type BardeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BardeMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type BardeMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type BardeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BardeNullableRelationFilter = {
    is?: BardeWhereInput | null
    isNot?: BardeWhereInput | null
  }

  export type HistoireCountOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    typeEvenement?: SortOrder
    description?: SortOrder
    dateEvenement?: SortOrder
    bardeId?: SortOrder
  }

  export type HistoireAvgOrderByAggregateInput = {
    id?: SortOrder
    bardeId?: SortOrder
  }

  export type HistoireMaxOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    typeEvenement?: SortOrder
    description?: SortOrder
    dateEvenement?: SortOrder
    bardeId?: SortOrder
  }

  export type HistoireMinOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    typeEvenement?: SortOrder
    description?: SortOrder
    dateEvenement?: SortOrder
    bardeId?: SortOrder
  }

  export type HistoireSumOrderByAggregateInput = {
    id?: SortOrder
    bardeId?: SortOrder
  }

  export type LieuNullableRelationFilter = {
    is?: LieuWhereInput | null
    isNot?: LieuWhereInput | null
  }

  export type ArmeeNullableRelationFilter = {
    is?: ArmeeWhereInput | null
    isNot?: ArmeeWhereInput | null
  }

  export type VillageNullableRelationFilter = {
    is?: VillageWhereInput | null
    isNot?: VillageWhereInput | null
  }

  export type InventaireCountOrderByAggregateInput = {
    id?: SortOrder
    typeRessource?: SortOrder
    stock?: SortOrder
    seuilAlerte?: SortOrder
    dateMesure?: SortOrder
    lieuId?: SortOrder
    armeeId?: SortOrder
    villageId?: SortOrder
  }

  export type InventaireAvgOrderByAggregateInput = {
    id?: SortOrder
    stock?: SortOrder
    seuilAlerte?: SortOrder
    lieuId?: SortOrder
    armeeId?: SortOrder
    villageId?: SortOrder
  }

  export type InventaireMaxOrderByAggregateInput = {
    id?: SortOrder
    typeRessource?: SortOrder
    stock?: SortOrder
    seuilAlerte?: SortOrder
    dateMesure?: SortOrder
    lieuId?: SortOrder
    armeeId?: SortOrder
    villageId?: SortOrder
  }

  export type InventaireMinOrderByAggregateInput = {
    id?: SortOrder
    typeRessource?: SortOrder
    stock?: SortOrder
    seuilAlerte?: SortOrder
    dateMesure?: SortOrder
    lieuId?: SortOrder
    armeeId?: SortOrder
    villageId?: SortOrder
  }

  export type InventaireSumOrderByAggregateInput = {
    id?: SortOrder
    stock?: SortOrder
    seuilAlerte?: SortOrder
    lieuId?: SortOrder
    armeeId?: SortOrder
    villageId?: SortOrder
  }

  export type DomaineRelationFilter = {
    is?: DomaineWhereInput
    isNot?: DomaineWhereInput
  }

  export type RelationDiplomatiqueCountOrderByAggregateInput = {
    id?: SortOrder
    typeRelation?: SortOrder
    conditions?: SortOrder
    dateSignature?: SortOrder
    echeance?: SortOrder
    domaineSourceId?: SortOrder
    domaineCibleId?: SortOrder
  }

  export type RelationDiplomatiqueAvgOrderByAggregateInput = {
    id?: SortOrder
    domaineSourceId?: SortOrder
    domaineCibleId?: SortOrder
  }

  export type RelationDiplomatiqueMaxOrderByAggregateInput = {
    id?: SortOrder
    typeRelation?: SortOrder
    conditions?: SortOrder
    dateSignature?: SortOrder
    echeance?: SortOrder
    domaineSourceId?: SortOrder
    domaineCibleId?: SortOrder
  }

  export type RelationDiplomatiqueMinOrderByAggregateInput = {
    id?: SortOrder
    typeRelation?: SortOrder
    conditions?: SortOrder
    dateSignature?: SortOrder
    echeance?: SortOrder
    domaineSourceId?: SortOrder
    domaineCibleId?: SortOrder
  }

  export type RelationDiplomatiqueSumOrderByAggregateInput = {
    id?: SortOrder
    domaineSourceId?: SortOrder
    domaineCibleId?: SortOrder
  }

  export type LoiCountOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    effet?: SortOrder
  }

  export type LoiAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LoiMaxOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    effet?: SortOrder
  }

  export type LoiMinOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    effet?: SortOrder
  }

  export type LoiSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LoiRelationFilter = {
    is?: LoiWhereInput
    isNot?: LoiWhereInput
  }

  export type LoiTerritoireLoiIdDomaineIdCompoundUniqueInput = {
    loiId: number
    domaineId: number
  }

  export type LoiTerritoireCountOrderByAggregateInput = {
    loiId?: SortOrder
    domaineId?: SortOrder
  }

  export type LoiTerritoireAvgOrderByAggregateInput = {
    loiId?: SortOrder
    domaineId?: SortOrder
  }

  export type LoiTerritoireMaxOrderByAggregateInput = {
    loiId?: SortOrder
    domaineId?: SortOrder
  }

  export type LoiTerritoireMinOrderByAggregateInput = {
    loiId?: SortOrder
    domaineId?: SortOrder
  }

  export type LoiTerritoireSumOrderByAggregateInput = {
    loiId?: SortOrder
    domaineId?: SortOrder
  }

  export type PersonnageCreateNestedManyWithoutRaceInput = {
    create?: XOR<PersonnageCreateWithoutRaceInput, PersonnageUncheckedCreateWithoutRaceInput> | PersonnageCreateWithoutRaceInput[] | PersonnageUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: PersonnageCreateOrConnectWithoutRaceInput | PersonnageCreateOrConnectWithoutRaceInput[]
    createMany?: PersonnageCreateManyRaceInputEnvelope
    connect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
  }

  export type CompetenceCreateNestedManyWithoutExigenceRaceInput = {
    create?: XOR<CompetenceCreateWithoutExigenceRaceInput, CompetenceUncheckedCreateWithoutExigenceRaceInput> | CompetenceCreateWithoutExigenceRaceInput[] | CompetenceUncheckedCreateWithoutExigenceRaceInput[]
    connectOrCreate?: CompetenceCreateOrConnectWithoutExigenceRaceInput | CompetenceCreateOrConnectWithoutExigenceRaceInput[]
    createMany?: CompetenceCreateManyExigenceRaceInputEnvelope
    connect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
  }

  export type PersonnageUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<PersonnageCreateWithoutRaceInput, PersonnageUncheckedCreateWithoutRaceInput> | PersonnageCreateWithoutRaceInput[] | PersonnageUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: PersonnageCreateOrConnectWithoutRaceInput | PersonnageCreateOrConnectWithoutRaceInput[]
    createMany?: PersonnageCreateManyRaceInputEnvelope
    connect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
  }

  export type CompetenceUncheckedCreateNestedManyWithoutExigenceRaceInput = {
    create?: XOR<CompetenceCreateWithoutExigenceRaceInput, CompetenceUncheckedCreateWithoutExigenceRaceInput> | CompetenceCreateWithoutExigenceRaceInput[] | CompetenceUncheckedCreateWithoutExigenceRaceInput[]
    connectOrCreate?: CompetenceCreateOrConnectWithoutExigenceRaceInput | CompetenceCreateOrConnectWithoutExigenceRaceInput[]
    createMany?: CompetenceCreateManyExigenceRaceInputEnvelope
    connect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type PersonnageUpdateManyWithoutRaceNestedInput = {
    create?: XOR<PersonnageCreateWithoutRaceInput, PersonnageUncheckedCreateWithoutRaceInput> | PersonnageCreateWithoutRaceInput[] | PersonnageUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: PersonnageCreateOrConnectWithoutRaceInput | PersonnageCreateOrConnectWithoutRaceInput[]
    upsert?: PersonnageUpsertWithWhereUniqueWithoutRaceInput | PersonnageUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: PersonnageCreateManyRaceInputEnvelope
    set?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    disconnect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    delete?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    connect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    update?: PersonnageUpdateWithWhereUniqueWithoutRaceInput | PersonnageUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: PersonnageUpdateManyWithWhereWithoutRaceInput | PersonnageUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: PersonnageScalarWhereInput | PersonnageScalarWhereInput[]
  }

  export type CompetenceUpdateManyWithoutExigenceRaceNestedInput = {
    create?: XOR<CompetenceCreateWithoutExigenceRaceInput, CompetenceUncheckedCreateWithoutExigenceRaceInput> | CompetenceCreateWithoutExigenceRaceInput[] | CompetenceUncheckedCreateWithoutExigenceRaceInput[]
    connectOrCreate?: CompetenceCreateOrConnectWithoutExigenceRaceInput | CompetenceCreateOrConnectWithoutExigenceRaceInput[]
    upsert?: CompetenceUpsertWithWhereUniqueWithoutExigenceRaceInput | CompetenceUpsertWithWhereUniqueWithoutExigenceRaceInput[]
    createMany?: CompetenceCreateManyExigenceRaceInputEnvelope
    set?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    disconnect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    delete?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    connect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    update?: CompetenceUpdateWithWhereUniqueWithoutExigenceRaceInput | CompetenceUpdateWithWhereUniqueWithoutExigenceRaceInput[]
    updateMany?: CompetenceUpdateManyWithWhereWithoutExigenceRaceInput | CompetenceUpdateManyWithWhereWithoutExigenceRaceInput[]
    deleteMany?: CompetenceScalarWhereInput | CompetenceScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonnageUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<PersonnageCreateWithoutRaceInput, PersonnageUncheckedCreateWithoutRaceInput> | PersonnageCreateWithoutRaceInput[] | PersonnageUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: PersonnageCreateOrConnectWithoutRaceInput | PersonnageCreateOrConnectWithoutRaceInput[]
    upsert?: PersonnageUpsertWithWhereUniqueWithoutRaceInput | PersonnageUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: PersonnageCreateManyRaceInputEnvelope
    set?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    disconnect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    delete?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    connect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    update?: PersonnageUpdateWithWhereUniqueWithoutRaceInput | PersonnageUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: PersonnageUpdateManyWithWhereWithoutRaceInput | PersonnageUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: PersonnageScalarWhereInput | PersonnageScalarWhereInput[]
  }

  export type CompetenceUncheckedUpdateManyWithoutExigenceRaceNestedInput = {
    create?: XOR<CompetenceCreateWithoutExigenceRaceInput, CompetenceUncheckedCreateWithoutExigenceRaceInput> | CompetenceCreateWithoutExigenceRaceInput[] | CompetenceUncheckedCreateWithoutExigenceRaceInput[]
    connectOrCreate?: CompetenceCreateOrConnectWithoutExigenceRaceInput | CompetenceCreateOrConnectWithoutExigenceRaceInput[]
    upsert?: CompetenceUpsertWithWhereUniqueWithoutExigenceRaceInput | CompetenceUpsertWithWhereUniqueWithoutExigenceRaceInput[]
    createMany?: CompetenceCreateManyExigenceRaceInputEnvelope
    set?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    disconnect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    delete?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    connect?: CompetenceWhereUniqueInput | CompetenceWhereUniqueInput[]
    update?: CompetenceUpdateWithWhereUniqueWithoutExigenceRaceInput | CompetenceUpdateWithWhereUniqueWithoutExigenceRaceInput[]
    updateMany?: CompetenceUpdateManyWithWhereWithoutExigenceRaceInput | CompetenceUpdateManyWithWhereWithoutExigenceRaceInput[]
    deleteMany?: CompetenceScalarWhereInput | CompetenceScalarWhereInput[]
  }

  export type PersonnageRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<PersonnageRoleCreateWithoutRoleInput, PersonnageRoleUncheckedCreateWithoutRoleInput> | PersonnageRoleCreateWithoutRoleInput[] | PersonnageRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PersonnageRoleCreateOrConnectWithoutRoleInput | PersonnageRoleCreateOrConnectWithoutRoleInput[]
    createMany?: PersonnageRoleCreateManyRoleInputEnvelope
    connect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
  }

  export type PersonnageRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<PersonnageRoleCreateWithoutRoleInput, PersonnageRoleUncheckedCreateWithoutRoleInput> | PersonnageRoleCreateWithoutRoleInput[] | PersonnageRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PersonnageRoleCreateOrConnectWithoutRoleInput | PersonnageRoleCreateOrConnectWithoutRoleInput[]
    createMany?: PersonnageRoleCreateManyRoleInputEnvelope
    connect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
  }

  export type PersonnageRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PersonnageRoleCreateWithoutRoleInput, PersonnageRoleUncheckedCreateWithoutRoleInput> | PersonnageRoleCreateWithoutRoleInput[] | PersonnageRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PersonnageRoleCreateOrConnectWithoutRoleInput | PersonnageRoleCreateOrConnectWithoutRoleInput[]
    upsert?: PersonnageRoleUpsertWithWhereUniqueWithoutRoleInput | PersonnageRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: PersonnageRoleCreateManyRoleInputEnvelope
    set?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    disconnect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    delete?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    connect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    update?: PersonnageRoleUpdateWithWhereUniqueWithoutRoleInput | PersonnageRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PersonnageRoleUpdateManyWithWhereWithoutRoleInput | PersonnageRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PersonnageRoleScalarWhereInput | PersonnageRoleScalarWhereInput[]
  }

  export type PersonnageRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PersonnageRoleCreateWithoutRoleInput, PersonnageRoleUncheckedCreateWithoutRoleInput> | PersonnageRoleCreateWithoutRoleInput[] | PersonnageRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PersonnageRoleCreateOrConnectWithoutRoleInput | PersonnageRoleCreateOrConnectWithoutRoleInput[]
    upsert?: PersonnageRoleUpsertWithWhereUniqueWithoutRoleInput | PersonnageRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: PersonnageRoleCreateManyRoleInputEnvelope
    set?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    disconnect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    delete?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    connect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    update?: PersonnageRoleUpdateWithWhereUniqueWithoutRoleInput | PersonnageRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PersonnageRoleUpdateManyWithWhereWithoutRoleInput | PersonnageRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PersonnageRoleScalarWhereInput | PersonnageRoleScalarWhereInput[]
  }

  export type PersonnageCreateNestedManyWithoutLigneeInput = {
    create?: XOR<PersonnageCreateWithoutLigneeInput, PersonnageUncheckedCreateWithoutLigneeInput> | PersonnageCreateWithoutLigneeInput[] | PersonnageUncheckedCreateWithoutLigneeInput[]
    connectOrCreate?: PersonnageCreateOrConnectWithoutLigneeInput | PersonnageCreateOrConnectWithoutLigneeInput[]
    createMany?: PersonnageCreateManyLigneeInputEnvelope
    connect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
  }

  export type PersonnageTitreCreateNestedManyWithoutLigneeInput = {
    create?: XOR<PersonnageTitreCreateWithoutLigneeInput, PersonnageTitreUncheckedCreateWithoutLigneeInput> | PersonnageTitreCreateWithoutLigneeInput[] | PersonnageTitreUncheckedCreateWithoutLigneeInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutLigneeInput | PersonnageTitreCreateOrConnectWithoutLigneeInput[]
    createMany?: PersonnageTitreCreateManyLigneeInputEnvelope
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
  }

  export type PersonnageUncheckedCreateNestedManyWithoutLigneeInput = {
    create?: XOR<PersonnageCreateWithoutLigneeInput, PersonnageUncheckedCreateWithoutLigneeInput> | PersonnageCreateWithoutLigneeInput[] | PersonnageUncheckedCreateWithoutLigneeInput[]
    connectOrCreate?: PersonnageCreateOrConnectWithoutLigneeInput | PersonnageCreateOrConnectWithoutLigneeInput[]
    createMany?: PersonnageCreateManyLigneeInputEnvelope
    connect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
  }

  export type PersonnageTitreUncheckedCreateNestedManyWithoutLigneeInput = {
    create?: XOR<PersonnageTitreCreateWithoutLigneeInput, PersonnageTitreUncheckedCreateWithoutLigneeInput> | PersonnageTitreCreateWithoutLigneeInput[] | PersonnageTitreUncheckedCreateWithoutLigneeInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutLigneeInput | PersonnageTitreCreateOrConnectWithoutLigneeInput[]
    createMany?: PersonnageTitreCreateManyLigneeInputEnvelope
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
  }

  export type PersonnageUpdateManyWithoutLigneeNestedInput = {
    create?: XOR<PersonnageCreateWithoutLigneeInput, PersonnageUncheckedCreateWithoutLigneeInput> | PersonnageCreateWithoutLigneeInput[] | PersonnageUncheckedCreateWithoutLigneeInput[]
    connectOrCreate?: PersonnageCreateOrConnectWithoutLigneeInput | PersonnageCreateOrConnectWithoutLigneeInput[]
    upsert?: PersonnageUpsertWithWhereUniqueWithoutLigneeInput | PersonnageUpsertWithWhereUniqueWithoutLigneeInput[]
    createMany?: PersonnageCreateManyLigneeInputEnvelope
    set?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    disconnect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    delete?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    connect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    update?: PersonnageUpdateWithWhereUniqueWithoutLigneeInput | PersonnageUpdateWithWhereUniqueWithoutLigneeInput[]
    updateMany?: PersonnageUpdateManyWithWhereWithoutLigneeInput | PersonnageUpdateManyWithWhereWithoutLigneeInput[]
    deleteMany?: PersonnageScalarWhereInput | PersonnageScalarWhereInput[]
  }

  export type PersonnageTitreUpdateManyWithoutLigneeNestedInput = {
    create?: XOR<PersonnageTitreCreateWithoutLigneeInput, PersonnageTitreUncheckedCreateWithoutLigneeInput> | PersonnageTitreCreateWithoutLigneeInput[] | PersonnageTitreUncheckedCreateWithoutLigneeInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutLigneeInput | PersonnageTitreCreateOrConnectWithoutLigneeInput[]
    upsert?: PersonnageTitreUpsertWithWhereUniqueWithoutLigneeInput | PersonnageTitreUpsertWithWhereUniqueWithoutLigneeInput[]
    createMany?: PersonnageTitreCreateManyLigneeInputEnvelope
    set?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    disconnect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    delete?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    update?: PersonnageTitreUpdateWithWhereUniqueWithoutLigneeInput | PersonnageTitreUpdateWithWhereUniqueWithoutLigneeInput[]
    updateMany?: PersonnageTitreUpdateManyWithWhereWithoutLigneeInput | PersonnageTitreUpdateManyWithWhereWithoutLigneeInput[]
    deleteMany?: PersonnageTitreScalarWhereInput | PersonnageTitreScalarWhereInput[]
  }

  export type PersonnageUncheckedUpdateManyWithoutLigneeNestedInput = {
    create?: XOR<PersonnageCreateWithoutLigneeInput, PersonnageUncheckedCreateWithoutLigneeInput> | PersonnageCreateWithoutLigneeInput[] | PersonnageUncheckedCreateWithoutLigneeInput[]
    connectOrCreate?: PersonnageCreateOrConnectWithoutLigneeInput | PersonnageCreateOrConnectWithoutLigneeInput[]
    upsert?: PersonnageUpsertWithWhereUniqueWithoutLigneeInput | PersonnageUpsertWithWhereUniqueWithoutLigneeInput[]
    createMany?: PersonnageCreateManyLigneeInputEnvelope
    set?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    disconnect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    delete?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    connect?: PersonnageWhereUniqueInput | PersonnageWhereUniqueInput[]
    update?: PersonnageUpdateWithWhereUniqueWithoutLigneeInput | PersonnageUpdateWithWhereUniqueWithoutLigneeInput[]
    updateMany?: PersonnageUpdateManyWithWhereWithoutLigneeInput | PersonnageUpdateManyWithWhereWithoutLigneeInput[]
    deleteMany?: PersonnageScalarWhereInput | PersonnageScalarWhereInput[]
  }

  export type PersonnageTitreUncheckedUpdateManyWithoutLigneeNestedInput = {
    create?: XOR<PersonnageTitreCreateWithoutLigneeInput, PersonnageTitreUncheckedCreateWithoutLigneeInput> | PersonnageTitreCreateWithoutLigneeInput[] | PersonnageTitreUncheckedCreateWithoutLigneeInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutLigneeInput | PersonnageTitreCreateOrConnectWithoutLigneeInput[]
    upsert?: PersonnageTitreUpsertWithWhereUniqueWithoutLigneeInput | PersonnageTitreUpsertWithWhereUniqueWithoutLigneeInput[]
    createMany?: PersonnageTitreCreateManyLigneeInputEnvelope
    set?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    disconnect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    delete?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    update?: PersonnageTitreUpdateWithWhereUniqueWithoutLigneeInput | PersonnageTitreUpdateWithWhereUniqueWithoutLigneeInput[]
    updateMany?: PersonnageTitreUpdateManyWithWhereWithoutLigneeInput | PersonnageTitreUpdateManyWithWhereWithoutLigneeInput[]
    deleteMany?: PersonnageTitreScalarWhereInput | PersonnageTitreScalarWhereInput[]
  }

  export type RaceCreateNestedOneWithoutPersonnagesInput = {
    create?: XOR<RaceCreateWithoutPersonnagesInput, RaceUncheckedCreateWithoutPersonnagesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutPersonnagesInput
    connect?: RaceWhereUniqueInput
  }

  export type LigneeCreateNestedOneWithoutPersonnagesInput = {
    create?: XOR<LigneeCreateWithoutPersonnagesInput, LigneeUncheckedCreateWithoutPersonnagesInput>
    connectOrCreate?: LigneeCreateOrConnectWithoutPersonnagesInput
    connect?: LigneeWhereUniqueInput
  }

  export type PersonnageRoleCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<PersonnageRoleCreateWithoutPersonnageInput, PersonnageRoleUncheckedCreateWithoutPersonnageInput> | PersonnageRoleCreateWithoutPersonnageInput[] | PersonnageRoleUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageRoleCreateOrConnectWithoutPersonnageInput | PersonnageRoleCreateOrConnectWithoutPersonnageInput[]
    createMany?: PersonnageRoleCreateManyPersonnageInputEnvelope
    connect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
  }

  export type PersonnageCompetenceCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<PersonnageCompetenceCreateWithoutPersonnageInput, PersonnageCompetenceUncheckedCreateWithoutPersonnageInput> | PersonnageCompetenceCreateWithoutPersonnageInput[] | PersonnageCompetenceUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageCompetenceCreateOrConnectWithoutPersonnageInput | PersonnageCompetenceCreateOrConnectWithoutPersonnageInput[]
    createMany?: PersonnageCompetenceCreateManyPersonnageInputEnvelope
    connect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
  }

  export type PersonnageTitreCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<PersonnageTitreCreateWithoutPersonnageInput, PersonnageTitreUncheckedCreateWithoutPersonnageInput> | PersonnageTitreCreateWithoutPersonnageInput[] | PersonnageTitreUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutPersonnageInput | PersonnageTitreCreateOrConnectWithoutPersonnageInput[]
    createMany?: PersonnageTitreCreateManyPersonnageInputEnvelope
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
  }

  export type PersonnageMaladieCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<PersonnageMaladieCreateWithoutPersonnageInput, PersonnageMaladieUncheckedCreateWithoutPersonnageInput> | PersonnageMaladieCreateWithoutPersonnageInput[] | PersonnageMaladieUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageMaladieCreateOrConnectWithoutPersonnageInput | PersonnageMaladieCreateOrConnectWithoutPersonnageInput[]
    createMany?: PersonnageMaladieCreateManyPersonnageInputEnvelope
    connect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
  }

  export type ArmeeCreateNestedManyWithoutCommandantInput = {
    create?: XOR<ArmeeCreateWithoutCommandantInput, ArmeeUncheckedCreateWithoutCommandantInput> | ArmeeCreateWithoutCommandantInput[] | ArmeeUncheckedCreateWithoutCommandantInput[]
    connectOrCreate?: ArmeeCreateOrConnectWithoutCommandantInput | ArmeeCreateOrConnectWithoutCommandantInput[]
    createMany?: ArmeeCreateManyCommandantInputEnvelope
    connect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
  }

  export type PersonnageEquipementCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<PersonnageEquipementCreateWithoutPersonnageInput, PersonnageEquipementUncheckedCreateWithoutPersonnageInput> | PersonnageEquipementCreateWithoutPersonnageInput[] | PersonnageEquipementUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageEquipementCreateOrConnectWithoutPersonnageInput | PersonnageEquipementCreateOrConnectWithoutPersonnageInput[]
    createMany?: PersonnageEquipementCreateManyPersonnageInputEnvelope
    connect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
  }

  export type GuildeMembreCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<GuildeMembreCreateWithoutPersonnageInput, GuildeMembreUncheckedCreateWithoutPersonnageInput> | GuildeMembreCreateWithoutPersonnageInput[] | GuildeMembreUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: GuildeMembreCreateOrConnectWithoutPersonnageInput | GuildeMembreCreateOrConnectWithoutPersonnageInput[]
    createMany?: GuildeMembreCreateManyPersonnageInputEnvelope
    connect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
  }

  export type PersonnageRoleUncheckedCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<PersonnageRoleCreateWithoutPersonnageInput, PersonnageRoleUncheckedCreateWithoutPersonnageInput> | PersonnageRoleCreateWithoutPersonnageInput[] | PersonnageRoleUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageRoleCreateOrConnectWithoutPersonnageInput | PersonnageRoleCreateOrConnectWithoutPersonnageInput[]
    createMany?: PersonnageRoleCreateManyPersonnageInputEnvelope
    connect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
  }

  export type PersonnageCompetenceUncheckedCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<PersonnageCompetenceCreateWithoutPersonnageInput, PersonnageCompetenceUncheckedCreateWithoutPersonnageInput> | PersonnageCompetenceCreateWithoutPersonnageInput[] | PersonnageCompetenceUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageCompetenceCreateOrConnectWithoutPersonnageInput | PersonnageCompetenceCreateOrConnectWithoutPersonnageInput[]
    createMany?: PersonnageCompetenceCreateManyPersonnageInputEnvelope
    connect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
  }

  export type PersonnageTitreUncheckedCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<PersonnageTitreCreateWithoutPersonnageInput, PersonnageTitreUncheckedCreateWithoutPersonnageInput> | PersonnageTitreCreateWithoutPersonnageInput[] | PersonnageTitreUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutPersonnageInput | PersonnageTitreCreateOrConnectWithoutPersonnageInput[]
    createMany?: PersonnageTitreCreateManyPersonnageInputEnvelope
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
  }

  export type PersonnageMaladieUncheckedCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<PersonnageMaladieCreateWithoutPersonnageInput, PersonnageMaladieUncheckedCreateWithoutPersonnageInput> | PersonnageMaladieCreateWithoutPersonnageInput[] | PersonnageMaladieUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageMaladieCreateOrConnectWithoutPersonnageInput | PersonnageMaladieCreateOrConnectWithoutPersonnageInput[]
    createMany?: PersonnageMaladieCreateManyPersonnageInputEnvelope
    connect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
  }

  export type ArmeeUncheckedCreateNestedManyWithoutCommandantInput = {
    create?: XOR<ArmeeCreateWithoutCommandantInput, ArmeeUncheckedCreateWithoutCommandantInput> | ArmeeCreateWithoutCommandantInput[] | ArmeeUncheckedCreateWithoutCommandantInput[]
    connectOrCreate?: ArmeeCreateOrConnectWithoutCommandantInput | ArmeeCreateOrConnectWithoutCommandantInput[]
    createMany?: ArmeeCreateManyCommandantInputEnvelope
    connect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
  }

  export type PersonnageEquipementUncheckedCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<PersonnageEquipementCreateWithoutPersonnageInput, PersonnageEquipementUncheckedCreateWithoutPersonnageInput> | PersonnageEquipementCreateWithoutPersonnageInput[] | PersonnageEquipementUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageEquipementCreateOrConnectWithoutPersonnageInput | PersonnageEquipementCreateOrConnectWithoutPersonnageInput[]
    createMany?: PersonnageEquipementCreateManyPersonnageInputEnvelope
    connect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
  }

  export type GuildeMembreUncheckedCreateNestedManyWithoutPersonnageInput = {
    create?: XOR<GuildeMembreCreateWithoutPersonnageInput, GuildeMembreUncheckedCreateWithoutPersonnageInput> | GuildeMembreCreateWithoutPersonnageInput[] | GuildeMembreUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: GuildeMembreCreateOrConnectWithoutPersonnageInput | GuildeMembreCreateOrConnectWithoutPersonnageInput[]
    createMany?: GuildeMembreCreateManyPersonnageInputEnvelope
    connect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RaceUpdateOneWithoutPersonnagesNestedInput = {
    create?: XOR<RaceCreateWithoutPersonnagesInput, RaceUncheckedCreateWithoutPersonnagesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutPersonnagesInput
    upsert?: RaceUpsertWithoutPersonnagesInput
    disconnect?: RaceWhereInput | boolean
    delete?: RaceWhereInput | boolean
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutPersonnagesInput, RaceUpdateWithoutPersonnagesInput>, RaceUncheckedUpdateWithoutPersonnagesInput>
  }

  export type LigneeUpdateOneWithoutPersonnagesNestedInput = {
    create?: XOR<LigneeCreateWithoutPersonnagesInput, LigneeUncheckedCreateWithoutPersonnagesInput>
    connectOrCreate?: LigneeCreateOrConnectWithoutPersonnagesInput
    upsert?: LigneeUpsertWithoutPersonnagesInput
    disconnect?: LigneeWhereInput | boolean
    delete?: LigneeWhereInput | boolean
    connect?: LigneeWhereUniqueInput
    update?: XOR<XOR<LigneeUpdateToOneWithWhereWithoutPersonnagesInput, LigneeUpdateWithoutPersonnagesInput>, LigneeUncheckedUpdateWithoutPersonnagesInput>
  }

  export type PersonnageRoleUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<PersonnageRoleCreateWithoutPersonnageInput, PersonnageRoleUncheckedCreateWithoutPersonnageInput> | PersonnageRoleCreateWithoutPersonnageInput[] | PersonnageRoleUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageRoleCreateOrConnectWithoutPersonnageInput | PersonnageRoleCreateOrConnectWithoutPersonnageInput[]
    upsert?: PersonnageRoleUpsertWithWhereUniqueWithoutPersonnageInput | PersonnageRoleUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: PersonnageRoleCreateManyPersonnageInputEnvelope
    set?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    disconnect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    delete?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    connect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    update?: PersonnageRoleUpdateWithWhereUniqueWithoutPersonnageInput | PersonnageRoleUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: PersonnageRoleUpdateManyWithWhereWithoutPersonnageInput | PersonnageRoleUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: PersonnageRoleScalarWhereInput | PersonnageRoleScalarWhereInput[]
  }

  export type PersonnageCompetenceUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<PersonnageCompetenceCreateWithoutPersonnageInput, PersonnageCompetenceUncheckedCreateWithoutPersonnageInput> | PersonnageCompetenceCreateWithoutPersonnageInput[] | PersonnageCompetenceUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageCompetenceCreateOrConnectWithoutPersonnageInput | PersonnageCompetenceCreateOrConnectWithoutPersonnageInput[]
    upsert?: PersonnageCompetenceUpsertWithWhereUniqueWithoutPersonnageInput | PersonnageCompetenceUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: PersonnageCompetenceCreateManyPersonnageInputEnvelope
    set?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    disconnect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    delete?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    connect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    update?: PersonnageCompetenceUpdateWithWhereUniqueWithoutPersonnageInput | PersonnageCompetenceUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: PersonnageCompetenceUpdateManyWithWhereWithoutPersonnageInput | PersonnageCompetenceUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: PersonnageCompetenceScalarWhereInput | PersonnageCompetenceScalarWhereInput[]
  }

  export type PersonnageTitreUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<PersonnageTitreCreateWithoutPersonnageInput, PersonnageTitreUncheckedCreateWithoutPersonnageInput> | PersonnageTitreCreateWithoutPersonnageInput[] | PersonnageTitreUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutPersonnageInput | PersonnageTitreCreateOrConnectWithoutPersonnageInput[]
    upsert?: PersonnageTitreUpsertWithWhereUniqueWithoutPersonnageInput | PersonnageTitreUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: PersonnageTitreCreateManyPersonnageInputEnvelope
    set?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    disconnect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    delete?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    update?: PersonnageTitreUpdateWithWhereUniqueWithoutPersonnageInput | PersonnageTitreUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: PersonnageTitreUpdateManyWithWhereWithoutPersonnageInput | PersonnageTitreUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: PersonnageTitreScalarWhereInput | PersonnageTitreScalarWhereInput[]
  }

  export type PersonnageMaladieUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<PersonnageMaladieCreateWithoutPersonnageInput, PersonnageMaladieUncheckedCreateWithoutPersonnageInput> | PersonnageMaladieCreateWithoutPersonnageInput[] | PersonnageMaladieUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageMaladieCreateOrConnectWithoutPersonnageInput | PersonnageMaladieCreateOrConnectWithoutPersonnageInput[]
    upsert?: PersonnageMaladieUpsertWithWhereUniqueWithoutPersonnageInput | PersonnageMaladieUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: PersonnageMaladieCreateManyPersonnageInputEnvelope
    set?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    disconnect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    delete?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    connect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    update?: PersonnageMaladieUpdateWithWhereUniqueWithoutPersonnageInput | PersonnageMaladieUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: PersonnageMaladieUpdateManyWithWhereWithoutPersonnageInput | PersonnageMaladieUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: PersonnageMaladieScalarWhereInput | PersonnageMaladieScalarWhereInput[]
  }

  export type ArmeeUpdateManyWithoutCommandantNestedInput = {
    create?: XOR<ArmeeCreateWithoutCommandantInput, ArmeeUncheckedCreateWithoutCommandantInput> | ArmeeCreateWithoutCommandantInput[] | ArmeeUncheckedCreateWithoutCommandantInput[]
    connectOrCreate?: ArmeeCreateOrConnectWithoutCommandantInput | ArmeeCreateOrConnectWithoutCommandantInput[]
    upsert?: ArmeeUpsertWithWhereUniqueWithoutCommandantInput | ArmeeUpsertWithWhereUniqueWithoutCommandantInput[]
    createMany?: ArmeeCreateManyCommandantInputEnvelope
    set?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    disconnect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    delete?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    connect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    update?: ArmeeUpdateWithWhereUniqueWithoutCommandantInput | ArmeeUpdateWithWhereUniqueWithoutCommandantInput[]
    updateMany?: ArmeeUpdateManyWithWhereWithoutCommandantInput | ArmeeUpdateManyWithWhereWithoutCommandantInput[]
    deleteMany?: ArmeeScalarWhereInput | ArmeeScalarWhereInput[]
  }

  export type PersonnageEquipementUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<PersonnageEquipementCreateWithoutPersonnageInput, PersonnageEquipementUncheckedCreateWithoutPersonnageInput> | PersonnageEquipementCreateWithoutPersonnageInput[] | PersonnageEquipementUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageEquipementCreateOrConnectWithoutPersonnageInput | PersonnageEquipementCreateOrConnectWithoutPersonnageInput[]
    upsert?: PersonnageEquipementUpsertWithWhereUniqueWithoutPersonnageInput | PersonnageEquipementUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: PersonnageEquipementCreateManyPersonnageInputEnvelope
    set?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    disconnect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    delete?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    connect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    update?: PersonnageEquipementUpdateWithWhereUniqueWithoutPersonnageInput | PersonnageEquipementUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: PersonnageEquipementUpdateManyWithWhereWithoutPersonnageInput | PersonnageEquipementUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: PersonnageEquipementScalarWhereInput | PersonnageEquipementScalarWhereInput[]
  }

  export type GuildeMembreUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<GuildeMembreCreateWithoutPersonnageInput, GuildeMembreUncheckedCreateWithoutPersonnageInput> | GuildeMembreCreateWithoutPersonnageInput[] | GuildeMembreUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: GuildeMembreCreateOrConnectWithoutPersonnageInput | GuildeMembreCreateOrConnectWithoutPersonnageInput[]
    upsert?: GuildeMembreUpsertWithWhereUniqueWithoutPersonnageInput | GuildeMembreUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: GuildeMembreCreateManyPersonnageInputEnvelope
    set?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    disconnect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    delete?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    connect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    update?: GuildeMembreUpdateWithWhereUniqueWithoutPersonnageInput | GuildeMembreUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: GuildeMembreUpdateManyWithWhereWithoutPersonnageInput | GuildeMembreUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: GuildeMembreScalarWhereInput | GuildeMembreScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonnageRoleUncheckedUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<PersonnageRoleCreateWithoutPersonnageInput, PersonnageRoleUncheckedCreateWithoutPersonnageInput> | PersonnageRoleCreateWithoutPersonnageInput[] | PersonnageRoleUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageRoleCreateOrConnectWithoutPersonnageInput | PersonnageRoleCreateOrConnectWithoutPersonnageInput[]
    upsert?: PersonnageRoleUpsertWithWhereUniqueWithoutPersonnageInput | PersonnageRoleUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: PersonnageRoleCreateManyPersonnageInputEnvelope
    set?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    disconnect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    delete?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    connect?: PersonnageRoleWhereUniqueInput | PersonnageRoleWhereUniqueInput[]
    update?: PersonnageRoleUpdateWithWhereUniqueWithoutPersonnageInput | PersonnageRoleUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: PersonnageRoleUpdateManyWithWhereWithoutPersonnageInput | PersonnageRoleUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: PersonnageRoleScalarWhereInput | PersonnageRoleScalarWhereInput[]
  }

  export type PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<PersonnageCompetenceCreateWithoutPersonnageInput, PersonnageCompetenceUncheckedCreateWithoutPersonnageInput> | PersonnageCompetenceCreateWithoutPersonnageInput[] | PersonnageCompetenceUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageCompetenceCreateOrConnectWithoutPersonnageInput | PersonnageCompetenceCreateOrConnectWithoutPersonnageInput[]
    upsert?: PersonnageCompetenceUpsertWithWhereUniqueWithoutPersonnageInput | PersonnageCompetenceUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: PersonnageCompetenceCreateManyPersonnageInputEnvelope
    set?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    disconnect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    delete?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    connect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    update?: PersonnageCompetenceUpdateWithWhereUniqueWithoutPersonnageInput | PersonnageCompetenceUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: PersonnageCompetenceUpdateManyWithWhereWithoutPersonnageInput | PersonnageCompetenceUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: PersonnageCompetenceScalarWhereInput | PersonnageCompetenceScalarWhereInput[]
  }

  export type PersonnageTitreUncheckedUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<PersonnageTitreCreateWithoutPersonnageInput, PersonnageTitreUncheckedCreateWithoutPersonnageInput> | PersonnageTitreCreateWithoutPersonnageInput[] | PersonnageTitreUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutPersonnageInput | PersonnageTitreCreateOrConnectWithoutPersonnageInput[]
    upsert?: PersonnageTitreUpsertWithWhereUniqueWithoutPersonnageInput | PersonnageTitreUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: PersonnageTitreCreateManyPersonnageInputEnvelope
    set?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    disconnect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    delete?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    update?: PersonnageTitreUpdateWithWhereUniqueWithoutPersonnageInput | PersonnageTitreUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: PersonnageTitreUpdateManyWithWhereWithoutPersonnageInput | PersonnageTitreUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: PersonnageTitreScalarWhereInput | PersonnageTitreScalarWhereInput[]
  }

  export type PersonnageMaladieUncheckedUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<PersonnageMaladieCreateWithoutPersonnageInput, PersonnageMaladieUncheckedCreateWithoutPersonnageInput> | PersonnageMaladieCreateWithoutPersonnageInput[] | PersonnageMaladieUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageMaladieCreateOrConnectWithoutPersonnageInput | PersonnageMaladieCreateOrConnectWithoutPersonnageInput[]
    upsert?: PersonnageMaladieUpsertWithWhereUniqueWithoutPersonnageInput | PersonnageMaladieUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: PersonnageMaladieCreateManyPersonnageInputEnvelope
    set?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    disconnect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    delete?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    connect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    update?: PersonnageMaladieUpdateWithWhereUniqueWithoutPersonnageInput | PersonnageMaladieUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: PersonnageMaladieUpdateManyWithWhereWithoutPersonnageInput | PersonnageMaladieUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: PersonnageMaladieScalarWhereInput | PersonnageMaladieScalarWhereInput[]
  }

  export type ArmeeUncheckedUpdateManyWithoutCommandantNestedInput = {
    create?: XOR<ArmeeCreateWithoutCommandantInput, ArmeeUncheckedCreateWithoutCommandantInput> | ArmeeCreateWithoutCommandantInput[] | ArmeeUncheckedCreateWithoutCommandantInput[]
    connectOrCreate?: ArmeeCreateOrConnectWithoutCommandantInput | ArmeeCreateOrConnectWithoutCommandantInput[]
    upsert?: ArmeeUpsertWithWhereUniqueWithoutCommandantInput | ArmeeUpsertWithWhereUniqueWithoutCommandantInput[]
    createMany?: ArmeeCreateManyCommandantInputEnvelope
    set?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    disconnect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    delete?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    connect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    update?: ArmeeUpdateWithWhereUniqueWithoutCommandantInput | ArmeeUpdateWithWhereUniqueWithoutCommandantInput[]
    updateMany?: ArmeeUpdateManyWithWhereWithoutCommandantInput | ArmeeUpdateManyWithWhereWithoutCommandantInput[]
    deleteMany?: ArmeeScalarWhereInput | ArmeeScalarWhereInput[]
  }

  export type PersonnageEquipementUncheckedUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<PersonnageEquipementCreateWithoutPersonnageInput, PersonnageEquipementUncheckedCreateWithoutPersonnageInput> | PersonnageEquipementCreateWithoutPersonnageInput[] | PersonnageEquipementUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: PersonnageEquipementCreateOrConnectWithoutPersonnageInput | PersonnageEquipementCreateOrConnectWithoutPersonnageInput[]
    upsert?: PersonnageEquipementUpsertWithWhereUniqueWithoutPersonnageInput | PersonnageEquipementUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: PersonnageEquipementCreateManyPersonnageInputEnvelope
    set?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    disconnect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    delete?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    connect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    update?: PersonnageEquipementUpdateWithWhereUniqueWithoutPersonnageInput | PersonnageEquipementUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: PersonnageEquipementUpdateManyWithWhereWithoutPersonnageInput | PersonnageEquipementUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: PersonnageEquipementScalarWhereInput | PersonnageEquipementScalarWhereInput[]
  }

  export type GuildeMembreUncheckedUpdateManyWithoutPersonnageNestedInput = {
    create?: XOR<GuildeMembreCreateWithoutPersonnageInput, GuildeMembreUncheckedCreateWithoutPersonnageInput> | GuildeMembreCreateWithoutPersonnageInput[] | GuildeMembreUncheckedCreateWithoutPersonnageInput[]
    connectOrCreate?: GuildeMembreCreateOrConnectWithoutPersonnageInput | GuildeMembreCreateOrConnectWithoutPersonnageInput[]
    upsert?: GuildeMembreUpsertWithWhereUniqueWithoutPersonnageInput | GuildeMembreUpsertWithWhereUniqueWithoutPersonnageInput[]
    createMany?: GuildeMembreCreateManyPersonnageInputEnvelope
    set?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    disconnect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    delete?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    connect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    update?: GuildeMembreUpdateWithWhereUniqueWithoutPersonnageInput | GuildeMembreUpdateWithWhereUniqueWithoutPersonnageInput[]
    updateMany?: GuildeMembreUpdateManyWithWhereWithoutPersonnageInput | GuildeMembreUpdateManyWithWhereWithoutPersonnageInput[]
    deleteMany?: GuildeMembreScalarWhereInput | GuildeMembreScalarWhereInput[]
  }

  export type PersonnageCreateNestedOneWithoutRolesInput = {
    create?: XOR<PersonnageCreateWithoutRolesInput, PersonnageUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutRolesInput
    connect?: PersonnageWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutPersonnagesInput = {
    create?: XOR<RoleCreateWithoutPersonnagesInput, RoleUncheckedCreateWithoutPersonnagesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPersonnagesInput
    connect?: RoleWhereUniqueInput
  }

  export type PersonnageUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PersonnageCreateWithoutRolesInput, PersonnageUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutRolesInput
    upsert?: PersonnageUpsertWithoutRolesInput
    connect?: PersonnageWhereUniqueInput
    update?: XOR<XOR<PersonnageUpdateToOneWithWhereWithoutRolesInput, PersonnageUpdateWithoutRolesInput>, PersonnageUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutPersonnagesNestedInput = {
    create?: XOR<RoleCreateWithoutPersonnagesInput, RoleUncheckedCreateWithoutPersonnagesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPersonnagesInput
    upsert?: RoleUpsertWithoutPersonnagesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPersonnagesInput, RoleUpdateWithoutPersonnagesInput>, RoleUncheckedUpdateWithoutPersonnagesInput>
  }

  export type RaceCreateNestedOneWithoutCompetencesInput = {
    create?: XOR<RaceCreateWithoutCompetencesInput, RaceUncheckedCreateWithoutCompetencesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutCompetencesInput
    connect?: RaceWhereUniqueInput
  }

  export type PersonnageCompetenceCreateNestedManyWithoutCompetenceInput = {
    create?: XOR<PersonnageCompetenceCreateWithoutCompetenceInput, PersonnageCompetenceUncheckedCreateWithoutCompetenceInput> | PersonnageCompetenceCreateWithoutCompetenceInput[] | PersonnageCompetenceUncheckedCreateWithoutCompetenceInput[]
    connectOrCreate?: PersonnageCompetenceCreateOrConnectWithoutCompetenceInput | PersonnageCompetenceCreateOrConnectWithoutCompetenceInput[]
    createMany?: PersonnageCompetenceCreateManyCompetenceInputEnvelope
    connect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
  }

  export type PersonnageCompetenceUncheckedCreateNestedManyWithoutCompetenceInput = {
    create?: XOR<PersonnageCompetenceCreateWithoutCompetenceInput, PersonnageCompetenceUncheckedCreateWithoutCompetenceInput> | PersonnageCompetenceCreateWithoutCompetenceInput[] | PersonnageCompetenceUncheckedCreateWithoutCompetenceInput[]
    connectOrCreate?: PersonnageCompetenceCreateOrConnectWithoutCompetenceInput | PersonnageCompetenceCreateOrConnectWithoutCompetenceInput[]
    createMany?: PersonnageCompetenceCreateManyCompetenceInputEnvelope
    connect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
  }

  export type RaceUpdateOneWithoutCompetencesNestedInput = {
    create?: XOR<RaceCreateWithoutCompetencesInput, RaceUncheckedCreateWithoutCompetencesInput>
    connectOrCreate?: RaceCreateOrConnectWithoutCompetencesInput
    upsert?: RaceUpsertWithoutCompetencesInput
    disconnect?: RaceWhereInput | boolean
    delete?: RaceWhereInput | boolean
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutCompetencesInput, RaceUpdateWithoutCompetencesInput>, RaceUncheckedUpdateWithoutCompetencesInput>
  }

  export type PersonnageCompetenceUpdateManyWithoutCompetenceNestedInput = {
    create?: XOR<PersonnageCompetenceCreateWithoutCompetenceInput, PersonnageCompetenceUncheckedCreateWithoutCompetenceInput> | PersonnageCompetenceCreateWithoutCompetenceInput[] | PersonnageCompetenceUncheckedCreateWithoutCompetenceInput[]
    connectOrCreate?: PersonnageCompetenceCreateOrConnectWithoutCompetenceInput | PersonnageCompetenceCreateOrConnectWithoutCompetenceInput[]
    upsert?: PersonnageCompetenceUpsertWithWhereUniqueWithoutCompetenceInput | PersonnageCompetenceUpsertWithWhereUniqueWithoutCompetenceInput[]
    createMany?: PersonnageCompetenceCreateManyCompetenceInputEnvelope
    set?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    disconnect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    delete?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    connect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    update?: PersonnageCompetenceUpdateWithWhereUniqueWithoutCompetenceInput | PersonnageCompetenceUpdateWithWhereUniqueWithoutCompetenceInput[]
    updateMany?: PersonnageCompetenceUpdateManyWithWhereWithoutCompetenceInput | PersonnageCompetenceUpdateManyWithWhereWithoutCompetenceInput[]
    deleteMany?: PersonnageCompetenceScalarWhereInput | PersonnageCompetenceScalarWhereInput[]
  }

  export type PersonnageCompetenceUncheckedUpdateManyWithoutCompetenceNestedInput = {
    create?: XOR<PersonnageCompetenceCreateWithoutCompetenceInput, PersonnageCompetenceUncheckedCreateWithoutCompetenceInput> | PersonnageCompetenceCreateWithoutCompetenceInput[] | PersonnageCompetenceUncheckedCreateWithoutCompetenceInput[]
    connectOrCreate?: PersonnageCompetenceCreateOrConnectWithoutCompetenceInput | PersonnageCompetenceCreateOrConnectWithoutCompetenceInput[]
    upsert?: PersonnageCompetenceUpsertWithWhereUniqueWithoutCompetenceInput | PersonnageCompetenceUpsertWithWhereUniqueWithoutCompetenceInput[]
    createMany?: PersonnageCompetenceCreateManyCompetenceInputEnvelope
    set?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    disconnect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    delete?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    connect?: PersonnageCompetenceWhereUniqueInput | PersonnageCompetenceWhereUniqueInput[]
    update?: PersonnageCompetenceUpdateWithWhereUniqueWithoutCompetenceInput | PersonnageCompetenceUpdateWithWhereUniqueWithoutCompetenceInput[]
    updateMany?: PersonnageCompetenceUpdateManyWithWhereWithoutCompetenceInput | PersonnageCompetenceUpdateManyWithWhereWithoutCompetenceInput[]
    deleteMany?: PersonnageCompetenceScalarWhereInput | PersonnageCompetenceScalarWhereInput[]
  }

  export type PersonnageCreateNestedOneWithoutCompetencesInput = {
    create?: XOR<PersonnageCreateWithoutCompetencesInput, PersonnageUncheckedCreateWithoutCompetencesInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutCompetencesInput
    connect?: PersonnageWhereUniqueInput
  }

  export type CompetenceCreateNestedOneWithoutPersonnagesInput = {
    create?: XOR<CompetenceCreateWithoutPersonnagesInput, CompetenceUncheckedCreateWithoutPersonnagesInput>
    connectOrCreate?: CompetenceCreateOrConnectWithoutPersonnagesInput
    connect?: CompetenceWhereUniqueInput
  }

  export type PersonnageUpdateOneRequiredWithoutCompetencesNestedInput = {
    create?: XOR<PersonnageCreateWithoutCompetencesInput, PersonnageUncheckedCreateWithoutCompetencesInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutCompetencesInput
    upsert?: PersonnageUpsertWithoutCompetencesInput
    connect?: PersonnageWhereUniqueInput
    update?: XOR<XOR<PersonnageUpdateToOneWithWhereWithoutCompetencesInput, PersonnageUpdateWithoutCompetencesInput>, PersonnageUncheckedUpdateWithoutCompetencesInput>
  }

  export type CompetenceUpdateOneRequiredWithoutPersonnagesNestedInput = {
    create?: XOR<CompetenceCreateWithoutPersonnagesInput, CompetenceUncheckedCreateWithoutPersonnagesInput>
    connectOrCreate?: CompetenceCreateOrConnectWithoutPersonnagesInput
    upsert?: CompetenceUpsertWithoutPersonnagesInput
    connect?: CompetenceWhereUniqueInput
    update?: XOR<XOR<CompetenceUpdateToOneWithWhereWithoutPersonnagesInput, CompetenceUpdateWithoutPersonnagesInput>, CompetenceUncheckedUpdateWithoutPersonnagesInput>
  }

  export type VillageCreateNestedManyWithoutDomaineInput = {
    create?: XOR<VillageCreateWithoutDomaineInput, VillageUncheckedCreateWithoutDomaineInput> | VillageCreateWithoutDomaineInput[] | VillageUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: VillageCreateOrConnectWithoutDomaineInput | VillageCreateOrConnectWithoutDomaineInput[]
    createMany?: VillageCreateManyDomaineInputEnvelope
    connect?: VillageWhereUniqueInput | VillageWhereUniqueInput[]
  }

  export type PersonnageTitreCreateNestedManyWithoutDomaineInput = {
    create?: XOR<PersonnageTitreCreateWithoutDomaineInput, PersonnageTitreUncheckedCreateWithoutDomaineInput> | PersonnageTitreCreateWithoutDomaineInput[] | PersonnageTitreUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutDomaineInput | PersonnageTitreCreateOrConnectWithoutDomaineInput[]
    createMany?: PersonnageTitreCreateManyDomaineInputEnvelope
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
  }

  export type ArmeeCreateNestedManyWithoutDomaineInput = {
    create?: XOR<ArmeeCreateWithoutDomaineInput, ArmeeUncheckedCreateWithoutDomaineInput> | ArmeeCreateWithoutDomaineInput[] | ArmeeUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: ArmeeCreateOrConnectWithoutDomaineInput | ArmeeCreateOrConnectWithoutDomaineInput[]
    createMany?: ArmeeCreateManyDomaineInputEnvelope
    connect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
  }

  export type RelationDiplomatiqueCreateNestedManyWithoutDomaineSourceInput = {
    create?: XOR<RelationDiplomatiqueCreateWithoutDomaineSourceInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput> | RelationDiplomatiqueCreateWithoutDomaineSourceInput[] | RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput[]
    connectOrCreate?: RelationDiplomatiqueCreateOrConnectWithoutDomaineSourceInput | RelationDiplomatiqueCreateOrConnectWithoutDomaineSourceInput[]
    createMany?: RelationDiplomatiqueCreateManyDomaineSourceInputEnvelope
    connect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
  }

  export type RelationDiplomatiqueCreateNestedManyWithoutDomaineCibleInput = {
    create?: XOR<RelationDiplomatiqueCreateWithoutDomaineCibleInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput> | RelationDiplomatiqueCreateWithoutDomaineCibleInput[] | RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput[]
    connectOrCreate?: RelationDiplomatiqueCreateOrConnectWithoutDomaineCibleInput | RelationDiplomatiqueCreateOrConnectWithoutDomaineCibleInput[]
    createMany?: RelationDiplomatiqueCreateManyDomaineCibleInputEnvelope
    connect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
  }

  export type LoiTerritoireCreateNestedManyWithoutDomaineInput = {
    create?: XOR<LoiTerritoireCreateWithoutDomaineInput, LoiTerritoireUncheckedCreateWithoutDomaineInput> | LoiTerritoireCreateWithoutDomaineInput[] | LoiTerritoireUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: LoiTerritoireCreateOrConnectWithoutDomaineInput | LoiTerritoireCreateOrConnectWithoutDomaineInput[]
    createMany?: LoiTerritoireCreateManyDomaineInputEnvelope
    connect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
  }

  export type VillageUncheckedCreateNestedManyWithoutDomaineInput = {
    create?: XOR<VillageCreateWithoutDomaineInput, VillageUncheckedCreateWithoutDomaineInput> | VillageCreateWithoutDomaineInput[] | VillageUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: VillageCreateOrConnectWithoutDomaineInput | VillageCreateOrConnectWithoutDomaineInput[]
    createMany?: VillageCreateManyDomaineInputEnvelope
    connect?: VillageWhereUniqueInput | VillageWhereUniqueInput[]
  }

  export type PersonnageTitreUncheckedCreateNestedManyWithoutDomaineInput = {
    create?: XOR<PersonnageTitreCreateWithoutDomaineInput, PersonnageTitreUncheckedCreateWithoutDomaineInput> | PersonnageTitreCreateWithoutDomaineInput[] | PersonnageTitreUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutDomaineInput | PersonnageTitreCreateOrConnectWithoutDomaineInput[]
    createMany?: PersonnageTitreCreateManyDomaineInputEnvelope
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
  }

  export type ArmeeUncheckedCreateNestedManyWithoutDomaineInput = {
    create?: XOR<ArmeeCreateWithoutDomaineInput, ArmeeUncheckedCreateWithoutDomaineInput> | ArmeeCreateWithoutDomaineInput[] | ArmeeUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: ArmeeCreateOrConnectWithoutDomaineInput | ArmeeCreateOrConnectWithoutDomaineInput[]
    createMany?: ArmeeCreateManyDomaineInputEnvelope
    connect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
  }

  export type RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineSourceInput = {
    create?: XOR<RelationDiplomatiqueCreateWithoutDomaineSourceInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput> | RelationDiplomatiqueCreateWithoutDomaineSourceInput[] | RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput[]
    connectOrCreate?: RelationDiplomatiqueCreateOrConnectWithoutDomaineSourceInput | RelationDiplomatiqueCreateOrConnectWithoutDomaineSourceInput[]
    createMany?: RelationDiplomatiqueCreateManyDomaineSourceInputEnvelope
    connect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
  }

  export type RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineCibleInput = {
    create?: XOR<RelationDiplomatiqueCreateWithoutDomaineCibleInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput> | RelationDiplomatiqueCreateWithoutDomaineCibleInput[] | RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput[]
    connectOrCreate?: RelationDiplomatiqueCreateOrConnectWithoutDomaineCibleInput | RelationDiplomatiqueCreateOrConnectWithoutDomaineCibleInput[]
    createMany?: RelationDiplomatiqueCreateManyDomaineCibleInputEnvelope
    connect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
  }

  export type LoiTerritoireUncheckedCreateNestedManyWithoutDomaineInput = {
    create?: XOR<LoiTerritoireCreateWithoutDomaineInput, LoiTerritoireUncheckedCreateWithoutDomaineInput> | LoiTerritoireCreateWithoutDomaineInput[] | LoiTerritoireUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: LoiTerritoireCreateOrConnectWithoutDomaineInput | LoiTerritoireCreateOrConnectWithoutDomaineInput[]
    createMany?: LoiTerritoireCreateManyDomaineInputEnvelope
    connect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type VillageUpdateManyWithoutDomaineNestedInput = {
    create?: XOR<VillageCreateWithoutDomaineInput, VillageUncheckedCreateWithoutDomaineInput> | VillageCreateWithoutDomaineInput[] | VillageUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: VillageCreateOrConnectWithoutDomaineInput | VillageCreateOrConnectWithoutDomaineInput[]
    upsert?: VillageUpsertWithWhereUniqueWithoutDomaineInput | VillageUpsertWithWhereUniqueWithoutDomaineInput[]
    createMany?: VillageCreateManyDomaineInputEnvelope
    set?: VillageWhereUniqueInput | VillageWhereUniqueInput[]
    disconnect?: VillageWhereUniqueInput | VillageWhereUniqueInput[]
    delete?: VillageWhereUniqueInput | VillageWhereUniqueInput[]
    connect?: VillageWhereUniqueInput | VillageWhereUniqueInput[]
    update?: VillageUpdateWithWhereUniqueWithoutDomaineInput | VillageUpdateWithWhereUniqueWithoutDomaineInput[]
    updateMany?: VillageUpdateManyWithWhereWithoutDomaineInput | VillageUpdateManyWithWhereWithoutDomaineInput[]
    deleteMany?: VillageScalarWhereInput | VillageScalarWhereInput[]
  }

  export type PersonnageTitreUpdateManyWithoutDomaineNestedInput = {
    create?: XOR<PersonnageTitreCreateWithoutDomaineInput, PersonnageTitreUncheckedCreateWithoutDomaineInput> | PersonnageTitreCreateWithoutDomaineInput[] | PersonnageTitreUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutDomaineInput | PersonnageTitreCreateOrConnectWithoutDomaineInput[]
    upsert?: PersonnageTitreUpsertWithWhereUniqueWithoutDomaineInput | PersonnageTitreUpsertWithWhereUniqueWithoutDomaineInput[]
    createMany?: PersonnageTitreCreateManyDomaineInputEnvelope
    set?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    disconnect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    delete?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    update?: PersonnageTitreUpdateWithWhereUniqueWithoutDomaineInput | PersonnageTitreUpdateWithWhereUniqueWithoutDomaineInput[]
    updateMany?: PersonnageTitreUpdateManyWithWhereWithoutDomaineInput | PersonnageTitreUpdateManyWithWhereWithoutDomaineInput[]
    deleteMany?: PersonnageTitreScalarWhereInput | PersonnageTitreScalarWhereInput[]
  }

  export type ArmeeUpdateManyWithoutDomaineNestedInput = {
    create?: XOR<ArmeeCreateWithoutDomaineInput, ArmeeUncheckedCreateWithoutDomaineInput> | ArmeeCreateWithoutDomaineInput[] | ArmeeUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: ArmeeCreateOrConnectWithoutDomaineInput | ArmeeCreateOrConnectWithoutDomaineInput[]
    upsert?: ArmeeUpsertWithWhereUniqueWithoutDomaineInput | ArmeeUpsertWithWhereUniqueWithoutDomaineInput[]
    createMany?: ArmeeCreateManyDomaineInputEnvelope
    set?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    disconnect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    delete?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    connect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    update?: ArmeeUpdateWithWhereUniqueWithoutDomaineInput | ArmeeUpdateWithWhereUniqueWithoutDomaineInput[]
    updateMany?: ArmeeUpdateManyWithWhereWithoutDomaineInput | ArmeeUpdateManyWithWhereWithoutDomaineInput[]
    deleteMany?: ArmeeScalarWhereInput | ArmeeScalarWhereInput[]
  }

  export type RelationDiplomatiqueUpdateManyWithoutDomaineSourceNestedInput = {
    create?: XOR<RelationDiplomatiqueCreateWithoutDomaineSourceInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput> | RelationDiplomatiqueCreateWithoutDomaineSourceInput[] | RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput[]
    connectOrCreate?: RelationDiplomatiqueCreateOrConnectWithoutDomaineSourceInput | RelationDiplomatiqueCreateOrConnectWithoutDomaineSourceInput[]
    upsert?: RelationDiplomatiqueUpsertWithWhereUniqueWithoutDomaineSourceInput | RelationDiplomatiqueUpsertWithWhereUniqueWithoutDomaineSourceInput[]
    createMany?: RelationDiplomatiqueCreateManyDomaineSourceInputEnvelope
    set?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    disconnect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    delete?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    connect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    update?: RelationDiplomatiqueUpdateWithWhereUniqueWithoutDomaineSourceInput | RelationDiplomatiqueUpdateWithWhereUniqueWithoutDomaineSourceInput[]
    updateMany?: RelationDiplomatiqueUpdateManyWithWhereWithoutDomaineSourceInput | RelationDiplomatiqueUpdateManyWithWhereWithoutDomaineSourceInput[]
    deleteMany?: RelationDiplomatiqueScalarWhereInput | RelationDiplomatiqueScalarWhereInput[]
  }

  export type RelationDiplomatiqueUpdateManyWithoutDomaineCibleNestedInput = {
    create?: XOR<RelationDiplomatiqueCreateWithoutDomaineCibleInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput> | RelationDiplomatiqueCreateWithoutDomaineCibleInput[] | RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput[]
    connectOrCreate?: RelationDiplomatiqueCreateOrConnectWithoutDomaineCibleInput | RelationDiplomatiqueCreateOrConnectWithoutDomaineCibleInput[]
    upsert?: RelationDiplomatiqueUpsertWithWhereUniqueWithoutDomaineCibleInput | RelationDiplomatiqueUpsertWithWhereUniqueWithoutDomaineCibleInput[]
    createMany?: RelationDiplomatiqueCreateManyDomaineCibleInputEnvelope
    set?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    disconnect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    delete?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    connect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    update?: RelationDiplomatiqueUpdateWithWhereUniqueWithoutDomaineCibleInput | RelationDiplomatiqueUpdateWithWhereUniqueWithoutDomaineCibleInput[]
    updateMany?: RelationDiplomatiqueUpdateManyWithWhereWithoutDomaineCibleInput | RelationDiplomatiqueUpdateManyWithWhereWithoutDomaineCibleInput[]
    deleteMany?: RelationDiplomatiqueScalarWhereInput | RelationDiplomatiqueScalarWhereInput[]
  }

  export type LoiTerritoireUpdateManyWithoutDomaineNestedInput = {
    create?: XOR<LoiTerritoireCreateWithoutDomaineInput, LoiTerritoireUncheckedCreateWithoutDomaineInput> | LoiTerritoireCreateWithoutDomaineInput[] | LoiTerritoireUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: LoiTerritoireCreateOrConnectWithoutDomaineInput | LoiTerritoireCreateOrConnectWithoutDomaineInput[]
    upsert?: LoiTerritoireUpsertWithWhereUniqueWithoutDomaineInput | LoiTerritoireUpsertWithWhereUniqueWithoutDomaineInput[]
    createMany?: LoiTerritoireCreateManyDomaineInputEnvelope
    set?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    disconnect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    delete?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    connect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    update?: LoiTerritoireUpdateWithWhereUniqueWithoutDomaineInput | LoiTerritoireUpdateWithWhereUniqueWithoutDomaineInput[]
    updateMany?: LoiTerritoireUpdateManyWithWhereWithoutDomaineInput | LoiTerritoireUpdateManyWithWhereWithoutDomaineInput[]
    deleteMany?: LoiTerritoireScalarWhereInput | LoiTerritoireScalarWhereInput[]
  }

  export type VillageUncheckedUpdateManyWithoutDomaineNestedInput = {
    create?: XOR<VillageCreateWithoutDomaineInput, VillageUncheckedCreateWithoutDomaineInput> | VillageCreateWithoutDomaineInput[] | VillageUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: VillageCreateOrConnectWithoutDomaineInput | VillageCreateOrConnectWithoutDomaineInput[]
    upsert?: VillageUpsertWithWhereUniqueWithoutDomaineInput | VillageUpsertWithWhereUniqueWithoutDomaineInput[]
    createMany?: VillageCreateManyDomaineInputEnvelope
    set?: VillageWhereUniqueInput | VillageWhereUniqueInput[]
    disconnect?: VillageWhereUniqueInput | VillageWhereUniqueInput[]
    delete?: VillageWhereUniqueInput | VillageWhereUniqueInput[]
    connect?: VillageWhereUniqueInput | VillageWhereUniqueInput[]
    update?: VillageUpdateWithWhereUniqueWithoutDomaineInput | VillageUpdateWithWhereUniqueWithoutDomaineInput[]
    updateMany?: VillageUpdateManyWithWhereWithoutDomaineInput | VillageUpdateManyWithWhereWithoutDomaineInput[]
    deleteMany?: VillageScalarWhereInput | VillageScalarWhereInput[]
  }

  export type PersonnageTitreUncheckedUpdateManyWithoutDomaineNestedInput = {
    create?: XOR<PersonnageTitreCreateWithoutDomaineInput, PersonnageTitreUncheckedCreateWithoutDomaineInput> | PersonnageTitreCreateWithoutDomaineInput[] | PersonnageTitreUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutDomaineInput | PersonnageTitreCreateOrConnectWithoutDomaineInput[]
    upsert?: PersonnageTitreUpsertWithWhereUniqueWithoutDomaineInput | PersonnageTitreUpsertWithWhereUniqueWithoutDomaineInput[]
    createMany?: PersonnageTitreCreateManyDomaineInputEnvelope
    set?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    disconnect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    delete?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    update?: PersonnageTitreUpdateWithWhereUniqueWithoutDomaineInput | PersonnageTitreUpdateWithWhereUniqueWithoutDomaineInput[]
    updateMany?: PersonnageTitreUpdateManyWithWhereWithoutDomaineInput | PersonnageTitreUpdateManyWithWhereWithoutDomaineInput[]
    deleteMany?: PersonnageTitreScalarWhereInput | PersonnageTitreScalarWhereInput[]
  }

  export type ArmeeUncheckedUpdateManyWithoutDomaineNestedInput = {
    create?: XOR<ArmeeCreateWithoutDomaineInput, ArmeeUncheckedCreateWithoutDomaineInput> | ArmeeCreateWithoutDomaineInput[] | ArmeeUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: ArmeeCreateOrConnectWithoutDomaineInput | ArmeeCreateOrConnectWithoutDomaineInput[]
    upsert?: ArmeeUpsertWithWhereUniqueWithoutDomaineInput | ArmeeUpsertWithWhereUniqueWithoutDomaineInput[]
    createMany?: ArmeeCreateManyDomaineInputEnvelope
    set?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    disconnect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    delete?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    connect?: ArmeeWhereUniqueInput | ArmeeWhereUniqueInput[]
    update?: ArmeeUpdateWithWhereUniqueWithoutDomaineInput | ArmeeUpdateWithWhereUniqueWithoutDomaineInput[]
    updateMany?: ArmeeUpdateManyWithWhereWithoutDomaineInput | ArmeeUpdateManyWithWhereWithoutDomaineInput[]
    deleteMany?: ArmeeScalarWhereInput | ArmeeScalarWhereInput[]
  }

  export type RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineSourceNestedInput = {
    create?: XOR<RelationDiplomatiqueCreateWithoutDomaineSourceInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput> | RelationDiplomatiqueCreateWithoutDomaineSourceInput[] | RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput[]
    connectOrCreate?: RelationDiplomatiqueCreateOrConnectWithoutDomaineSourceInput | RelationDiplomatiqueCreateOrConnectWithoutDomaineSourceInput[]
    upsert?: RelationDiplomatiqueUpsertWithWhereUniqueWithoutDomaineSourceInput | RelationDiplomatiqueUpsertWithWhereUniqueWithoutDomaineSourceInput[]
    createMany?: RelationDiplomatiqueCreateManyDomaineSourceInputEnvelope
    set?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    disconnect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    delete?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    connect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    update?: RelationDiplomatiqueUpdateWithWhereUniqueWithoutDomaineSourceInput | RelationDiplomatiqueUpdateWithWhereUniqueWithoutDomaineSourceInput[]
    updateMany?: RelationDiplomatiqueUpdateManyWithWhereWithoutDomaineSourceInput | RelationDiplomatiqueUpdateManyWithWhereWithoutDomaineSourceInput[]
    deleteMany?: RelationDiplomatiqueScalarWhereInput | RelationDiplomatiqueScalarWhereInput[]
  }

  export type RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineCibleNestedInput = {
    create?: XOR<RelationDiplomatiqueCreateWithoutDomaineCibleInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput> | RelationDiplomatiqueCreateWithoutDomaineCibleInput[] | RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput[]
    connectOrCreate?: RelationDiplomatiqueCreateOrConnectWithoutDomaineCibleInput | RelationDiplomatiqueCreateOrConnectWithoutDomaineCibleInput[]
    upsert?: RelationDiplomatiqueUpsertWithWhereUniqueWithoutDomaineCibleInput | RelationDiplomatiqueUpsertWithWhereUniqueWithoutDomaineCibleInput[]
    createMany?: RelationDiplomatiqueCreateManyDomaineCibleInputEnvelope
    set?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    disconnect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    delete?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    connect?: RelationDiplomatiqueWhereUniqueInput | RelationDiplomatiqueWhereUniqueInput[]
    update?: RelationDiplomatiqueUpdateWithWhereUniqueWithoutDomaineCibleInput | RelationDiplomatiqueUpdateWithWhereUniqueWithoutDomaineCibleInput[]
    updateMany?: RelationDiplomatiqueUpdateManyWithWhereWithoutDomaineCibleInput | RelationDiplomatiqueUpdateManyWithWhereWithoutDomaineCibleInput[]
    deleteMany?: RelationDiplomatiqueScalarWhereInput | RelationDiplomatiqueScalarWhereInput[]
  }

  export type LoiTerritoireUncheckedUpdateManyWithoutDomaineNestedInput = {
    create?: XOR<LoiTerritoireCreateWithoutDomaineInput, LoiTerritoireUncheckedCreateWithoutDomaineInput> | LoiTerritoireCreateWithoutDomaineInput[] | LoiTerritoireUncheckedCreateWithoutDomaineInput[]
    connectOrCreate?: LoiTerritoireCreateOrConnectWithoutDomaineInput | LoiTerritoireCreateOrConnectWithoutDomaineInput[]
    upsert?: LoiTerritoireUpsertWithWhereUniqueWithoutDomaineInput | LoiTerritoireUpsertWithWhereUniqueWithoutDomaineInput[]
    createMany?: LoiTerritoireCreateManyDomaineInputEnvelope
    set?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    disconnect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    delete?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    connect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    update?: LoiTerritoireUpdateWithWhereUniqueWithoutDomaineInput | LoiTerritoireUpdateWithWhereUniqueWithoutDomaineInput[]
    updateMany?: LoiTerritoireUpdateManyWithWhereWithoutDomaineInput | LoiTerritoireUpdateManyWithWhereWithoutDomaineInput[]
    deleteMany?: LoiTerritoireScalarWhereInput | LoiTerritoireScalarWhereInput[]
  }

  export type PersonnageTitreCreateNestedManyWithoutTitreInput = {
    create?: XOR<PersonnageTitreCreateWithoutTitreInput, PersonnageTitreUncheckedCreateWithoutTitreInput> | PersonnageTitreCreateWithoutTitreInput[] | PersonnageTitreUncheckedCreateWithoutTitreInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutTitreInput | PersonnageTitreCreateOrConnectWithoutTitreInput[]
    createMany?: PersonnageTitreCreateManyTitreInputEnvelope
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
  }

  export type PersonnageTitreUncheckedCreateNestedManyWithoutTitreInput = {
    create?: XOR<PersonnageTitreCreateWithoutTitreInput, PersonnageTitreUncheckedCreateWithoutTitreInput> | PersonnageTitreCreateWithoutTitreInput[] | PersonnageTitreUncheckedCreateWithoutTitreInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutTitreInput | PersonnageTitreCreateOrConnectWithoutTitreInput[]
    createMany?: PersonnageTitreCreateManyTitreInputEnvelope
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
  }

  export type PersonnageTitreUpdateManyWithoutTitreNestedInput = {
    create?: XOR<PersonnageTitreCreateWithoutTitreInput, PersonnageTitreUncheckedCreateWithoutTitreInput> | PersonnageTitreCreateWithoutTitreInput[] | PersonnageTitreUncheckedCreateWithoutTitreInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutTitreInput | PersonnageTitreCreateOrConnectWithoutTitreInput[]
    upsert?: PersonnageTitreUpsertWithWhereUniqueWithoutTitreInput | PersonnageTitreUpsertWithWhereUniqueWithoutTitreInput[]
    createMany?: PersonnageTitreCreateManyTitreInputEnvelope
    set?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    disconnect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    delete?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    update?: PersonnageTitreUpdateWithWhereUniqueWithoutTitreInput | PersonnageTitreUpdateWithWhereUniqueWithoutTitreInput[]
    updateMany?: PersonnageTitreUpdateManyWithWhereWithoutTitreInput | PersonnageTitreUpdateManyWithWhereWithoutTitreInput[]
    deleteMany?: PersonnageTitreScalarWhereInput | PersonnageTitreScalarWhereInput[]
  }

  export type PersonnageTitreUncheckedUpdateManyWithoutTitreNestedInput = {
    create?: XOR<PersonnageTitreCreateWithoutTitreInput, PersonnageTitreUncheckedCreateWithoutTitreInput> | PersonnageTitreCreateWithoutTitreInput[] | PersonnageTitreUncheckedCreateWithoutTitreInput[]
    connectOrCreate?: PersonnageTitreCreateOrConnectWithoutTitreInput | PersonnageTitreCreateOrConnectWithoutTitreInput[]
    upsert?: PersonnageTitreUpsertWithWhereUniqueWithoutTitreInput | PersonnageTitreUpsertWithWhereUniqueWithoutTitreInput[]
    createMany?: PersonnageTitreCreateManyTitreInputEnvelope
    set?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    disconnect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    delete?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    connect?: PersonnageTitreWhereUniqueInput | PersonnageTitreWhereUniqueInput[]
    update?: PersonnageTitreUpdateWithWhereUniqueWithoutTitreInput | PersonnageTitreUpdateWithWhereUniqueWithoutTitreInput[]
    updateMany?: PersonnageTitreUpdateManyWithWhereWithoutTitreInput | PersonnageTitreUpdateManyWithWhereWithoutTitreInput[]
    deleteMany?: PersonnageTitreScalarWhereInput | PersonnageTitreScalarWhereInput[]
  }

  export type PersonnageCreateNestedOneWithoutTitresInput = {
    create?: XOR<PersonnageCreateWithoutTitresInput, PersonnageUncheckedCreateWithoutTitresInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutTitresInput
    connect?: PersonnageWhereUniqueInput
  }

  export type TitreCreateNestedOneWithoutAttributionsInput = {
    create?: XOR<TitreCreateWithoutAttributionsInput, TitreUncheckedCreateWithoutAttributionsInput>
    connectOrCreate?: TitreCreateOrConnectWithoutAttributionsInput
    connect?: TitreWhereUniqueInput
  }

  export type DomaineCreateNestedOneWithoutTitresInput = {
    create?: XOR<DomaineCreateWithoutTitresInput, DomaineUncheckedCreateWithoutTitresInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutTitresInput
    connect?: DomaineWhereUniqueInput
  }

  export type LigneeCreateNestedOneWithoutTitresInput = {
    create?: XOR<LigneeCreateWithoutTitresInput, LigneeUncheckedCreateWithoutTitresInput>
    connectOrCreate?: LigneeCreateOrConnectWithoutTitresInput
    connect?: LigneeWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PersonnageUpdateOneRequiredWithoutTitresNestedInput = {
    create?: XOR<PersonnageCreateWithoutTitresInput, PersonnageUncheckedCreateWithoutTitresInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutTitresInput
    upsert?: PersonnageUpsertWithoutTitresInput
    connect?: PersonnageWhereUniqueInput
    update?: XOR<XOR<PersonnageUpdateToOneWithWhereWithoutTitresInput, PersonnageUpdateWithoutTitresInput>, PersonnageUncheckedUpdateWithoutTitresInput>
  }

  export type TitreUpdateOneRequiredWithoutAttributionsNestedInput = {
    create?: XOR<TitreCreateWithoutAttributionsInput, TitreUncheckedCreateWithoutAttributionsInput>
    connectOrCreate?: TitreCreateOrConnectWithoutAttributionsInput
    upsert?: TitreUpsertWithoutAttributionsInput
    connect?: TitreWhereUniqueInput
    update?: XOR<XOR<TitreUpdateToOneWithWhereWithoutAttributionsInput, TitreUpdateWithoutAttributionsInput>, TitreUncheckedUpdateWithoutAttributionsInput>
  }

  export type DomaineUpdateOneWithoutTitresNestedInput = {
    create?: XOR<DomaineCreateWithoutTitresInput, DomaineUncheckedCreateWithoutTitresInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutTitresInput
    upsert?: DomaineUpsertWithoutTitresInput
    disconnect?: DomaineWhereInput | boolean
    delete?: DomaineWhereInput | boolean
    connect?: DomaineWhereUniqueInput
    update?: XOR<XOR<DomaineUpdateToOneWithWhereWithoutTitresInput, DomaineUpdateWithoutTitresInput>, DomaineUncheckedUpdateWithoutTitresInput>
  }

  export type LigneeUpdateOneWithoutTitresNestedInput = {
    create?: XOR<LigneeCreateWithoutTitresInput, LigneeUncheckedCreateWithoutTitresInput>
    connectOrCreate?: LigneeCreateOrConnectWithoutTitresInput
    upsert?: LigneeUpsertWithoutTitresInput
    disconnect?: LigneeWhereInput | boolean
    delete?: LigneeWhereInput | boolean
    connect?: LigneeWhereUniqueInput
    update?: XOR<XOR<LigneeUpdateToOneWithWhereWithoutTitresInput, LigneeUpdateWithoutTitresInput>, LigneeUncheckedUpdateWithoutTitresInput>
  }

  export type DomaineCreateNestedOneWithoutVillagesInput = {
    create?: XOR<DomaineCreateWithoutVillagesInput, DomaineUncheckedCreateWithoutVillagesInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutVillagesInput
    connect?: DomaineWhereUniqueInput
  }

  export type InventaireCreateNestedManyWithoutVillageInput = {
    create?: XOR<InventaireCreateWithoutVillageInput, InventaireUncheckedCreateWithoutVillageInput> | InventaireCreateWithoutVillageInput[] | InventaireUncheckedCreateWithoutVillageInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutVillageInput | InventaireCreateOrConnectWithoutVillageInput[]
    createMany?: InventaireCreateManyVillageInputEnvelope
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
  }

  export type InventaireUncheckedCreateNestedManyWithoutVillageInput = {
    create?: XOR<InventaireCreateWithoutVillageInput, InventaireUncheckedCreateWithoutVillageInput> | InventaireCreateWithoutVillageInput[] | InventaireUncheckedCreateWithoutVillageInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutVillageInput | InventaireCreateOrConnectWithoutVillageInput[]
    createMany?: InventaireCreateManyVillageInputEnvelope
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
  }

  export type DomaineUpdateOneWithoutVillagesNestedInput = {
    create?: XOR<DomaineCreateWithoutVillagesInput, DomaineUncheckedCreateWithoutVillagesInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutVillagesInput
    upsert?: DomaineUpsertWithoutVillagesInput
    disconnect?: DomaineWhereInput | boolean
    delete?: DomaineWhereInput | boolean
    connect?: DomaineWhereUniqueInput
    update?: XOR<XOR<DomaineUpdateToOneWithWhereWithoutVillagesInput, DomaineUpdateWithoutVillagesInput>, DomaineUncheckedUpdateWithoutVillagesInput>
  }

  export type InventaireUpdateManyWithoutVillageNestedInput = {
    create?: XOR<InventaireCreateWithoutVillageInput, InventaireUncheckedCreateWithoutVillageInput> | InventaireCreateWithoutVillageInput[] | InventaireUncheckedCreateWithoutVillageInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutVillageInput | InventaireCreateOrConnectWithoutVillageInput[]
    upsert?: InventaireUpsertWithWhereUniqueWithoutVillageInput | InventaireUpsertWithWhereUniqueWithoutVillageInput[]
    createMany?: InventaireCreateManyVillageInputEnvelope
    set?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    disconnect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    delete?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    update?: InventaireUpdateWithWhereUniqueWithoutVillageInput | InventaireUpdateWithWhereUniqueWithoutVillageInput[]
    updateMany?: InventaireUpdateManyWithWhereWithoutVillageInput | InventaireUpdateManyWithWhereWithoutVillageInput[]
    deleteMany?: InventaireScalarWhereInput | InventaireScalarWhereInput[]
  }

  export type InventaireUncheckedUpdateManyWithoutVillageNestedInput = {
    create?: XOR<InventaireCreateWithoutVillageInput, InventaireUncheckedCreateWithoutVillageInput> | InventaireCreateWithoutVillageInput[] | InventaireUncheckedCreateWithoutVillageInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutVillageInput | InventaireCreateOrConnectWithoutVillageInput[]
    upsert?: InventaireUpsertWithWhereUniqueWithoutVillageInput | InventaireUpsertWithWhereUniqueWithoutVillageInput[]
    createMany?: InventaireCreateManyVillageInputEnvelope
    set?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    disconnect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    delete?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    update?: InventaireUpdateWithWhereUniqueWithoutVillageInput | InventaireUpdateWithWhereUniqueWithoutVillageInput[]
    updateMany?: InventaireUpdateManyWithWhereWithoutVillageInput | InventaireUpdateManyWithWhereWithoutVillageInput[]
    deleteMany?: InventaireScalarWhereInput | InventaireScalarWhereInput[]
  }

  export type GuildeMembreCreateNestedManyWithoutGuildeInput = {
    create?: XOR<GuildeMembreCreateWithoutGuildeInput, GuildeMembreUncheckedCreateWithoutGuildeInput> | GuildeMembreCreateWithoutGuildeInput[] | GuildeMembreUncheckedCreateWithoutGuildeInput[]
    connectOrCreate?: GuildeMembreCreateOrConnectWithoutGuildeInput | GuildeMembreCreateOrConnectWithoutGuildeInput[]
    createMany?: GuildeMembreCreateManyGuildeInputEnvelope
    connect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
  }

  export type GuildeBatailleCreateNestedManyWithoutGuildeInput = {
    create?: XOR<GuildeBatailleCreateWithoutGuildeInput, GuildeBatailleUncheckedCreateWithoutGuildeInput> | GuildeBatailleCreateWithoutGuildeInput[] | GuildeBatailleUncheckedCreateWithoutGuildeInput[]
    connectOrCreate?: GuildeBatailleCreateOrConnectWithoutGuildeInput | GuildeBatailleCreateOrConnectWithoutGuildeInput[]
    createMany?: GuildeBatailleCreateManyGuildeInputEnvelope
    connect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
  }

  export type GuildeMembreUncheckedCreateNestedManyWithoutGuildeInput = {
    create?: XOR<GuildeMembreCreateWithoutGuildeInput, GuildeMembreUncheckedCreateWithoutGuildeInput> | GuildeMembreCreateWithoutGuildeInput[] | GuildeMembreUncheckedCreateWithoutGuildeInput[]
    connectOrCreate?: GuildeMembreCreateOrConnectWithoutGuildeInput | GuildeMembreCreateOrConnectWithoutGuildeInput[]
    createMany?: GuildeMembreCreateManyGuildeInputEnvelope
    connect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
  }

  export type GuildeBatailleUncheckedCreateNestedManyWithoutGuildeInput = {
    create?: XOR<GuildeBatailleCreateWithoutGuildeInput, GuildeBatailleUncheckedCreateWithoutGuildeInput> | GuildeBatailleCreateWithoutGuildeInput[] | GuildeBatailleUncheckedCreateWithoutGuildeInput[]
    connectOrCreate?: GuildeBatailleCreateOrConnectWithoutGuildeInput | GuildeBatailleCreateOrConnectWithoutGuildeInput[]
    createMany?: GuildeBatailleCreateManyGuildeInputEnvelope
    connect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
  }

  export type GuildeMembreUpdateManyWithoutGuildeNestedInput = {
    create?: XOR<GuildeMembreCreateWithoutGuildeInput, GuildeMembreUncheckedCreateWithoutGuildeInput> | GuildeMembreCreateWithoutGuildeInput[] | GuildeMembreUncheckedCreateWithoutGuildeInput[]
    connectOrCreate?: GuildeMembreCreateOrConnectWithoutGuildeInput | GuildeMembreCreateOrConnectWithoutGuildeInput[]
    upsert?: GuildeMembreUpsertWithWhereUniqueWithoutGuildeInput | GuildeMembreUpsertWithWhereUniqueWithoutGuildeInput[]
    createMany?: GuildeMembreCreateManyGuildeInputEnvelope
    set?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    disconnect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    delete?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    connect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    update?: GuildeMembreUpdateWithWhereUniqueWithoutGuildeInput | GuildeMembreUpdateWithWhereUniqueWithoutGuildeInput[]
    updateMany?: GuildeMembreUpdateManyWithWhereWithoutGuildeInput | GuildeMembreUpdateManyWithWhereWithoutGuildeInput[]
    deleteMany?: GuildeMembreScalarWhereInput | GuildeMembreScalarWhereInput[]
  }

  export type GuildeBatailleUpdateManyWithoutGuildeNestedInput = {
    create?: XOR<GuildeBatailleCreateWithoutGuildeInput, GuildeBatailleUncheckedCreateWithoutGuildeInput> | GuildeBatailleCreateWithoutGuildeInput[] | GuildeBatailleUncheckedCreateWithoutGuildeInput[]
    connectOrCreate?: GuildeBatailleCreateOrConnectWithoutGuildeInput | GuildeBatailleCreateOrConnectWithoutGuildeInput[]
    upsert?: GuildeBatailleUpsertWithWhereUniqueWithoutGuildeInput | GuildeBatailleUpsertWithWhereUniqueWithoutGuildeInput[]
    createMany?: GuildeBatailleCreateManyGuildeInputEnvelope
    set?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    disconnect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    delete?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    connect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    update?: GuildeBatailleUpdateWithWhereUniqueWithoutGuildeInput | GuildeBatailleUpdateWithWhereUniqueWithoutGuildeInput[]
    updateMany?: GuildeBatailleUpdateManyWithWhereWithoutGuildeInput | GuildeBatailleUpdateManyWithWhereWithoutGuildeInput[]
    deleteMany?: GuildeBatailleScalarWhereInput | GuildeBatailleScalarWhereInput[]
  }

  export type GuildeMembreUncheckedUpdateManyWithoutGuildeNestedInput = {
    create?: XOR<GuildeMembreCreateWithoutGuildeInput, GuildeMembreUncheckedCreateWithoutGuildeInput> | GuildeMembreCreateWithoutGuildeInput[] | GuildeMembreUncheckedCreateWithoutGuildeInput[]
    connectOrCreate?: GuildeMembreCreateOrConnectWithoutGuildeInput | GuildeMembreCreateOrConnectWithoutGuildeInput[]
    upsert?: GuildeMembreUpsertWithWhereUniqueWithoutGuildeInput | GuildeMembreUpsertWithWhereUniqueWithoutGuildeInput[]
    createMany?: GuildeMembreCreateManyGuildeInputEnvelope
    set?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    disconnect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    delete?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    connect?: GuildeMembreWhereUniqueInput | GuildeMembreWhereUniqueInput[]
    update?: GuildeMembreUpdateWithWhereUniqueWithoutGuildeInput | GuildeMembreUpdateWithWhereUniqueWithoutGuildeInput[]
    updateMany?: GuildeMembreUpdateManyWithWhereWithoutGuildeInput | GuildeMembreUpdateManyWithWhereWithoutGuildeInput[]
    deleteMany?: GuildeMembreScalarWhereInput | GuildeMembreScalarWhereInput[]
  }

  export type GuildeBatailleUncheckedUpdateManyWithoutGuildeNestedInput = {
    create?: XOR<GuildeBatailleCreateWithoutGuildeInput, GuildeBatailleUncheckedCreateWithoutGuildeInput> | GuildeBatailleCreateWithoutGuildeInput[] | GuildeBatailleUncheckedCreateWithoutGuildeInput[]
    connectOrCreate?: GuildeBatailleCreateOrConnectWithoutGuildeInput | GuildeBatailleCreateOrConnectWithoutGuildeInput[]
    upsert?: GuildeBatailleUpsertWithWhereUniqueWithoutGuildeInput | GuildeBatailleUpsertWithWhereUniqueWithoutGuildeInput[]
    createMany?: GuildeBatailleCreateManyGuildeInputEnvelope
    set?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    disconnect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    delete?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    connect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    update?: GuildeBatailleUpdateWithWhereUniqueWithoutGuildeInput | GuildeBatailleUpdateWithWhereUniqueWithoutGuildeInput[]
    updateMany?: GuildeBatailleUpdateManyWithWhereWithoutGuildeInput | GuildeBatailleUpdateManyWithWhereWithoutGuildeInput[]
    deleteMany?: GuildeBatailleScalarWhereInput | GuildeBatailleScalarWhereInput[]
  }

  export type PersonnageCreateNestedOneWithoutGuildesInput = {
    create?: XOR<PersonnageCreateWithoutGuildesInput, PersonnageUncheckedCreateWithoutGuildesInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutGuildesInput
    connect?: PersonnageWhereUniqueInput
  }

  export type GuildeCreateNestedOneWithoutMembresInput = {
    create?: XOR<GuildeCreateWithoutMembresInput, GuildeUncheckedCreateWithoutMembresInput>
    connectOrCreate?: GuildeCreateOrConnectWithoutMembresInput
    connect?: GuildeWhereUniqueInput
  }

  export type PersonnageUpdateOneRequiredWithoutGuildesNestedInput = {
    create?: XOR<PersonnageCreateWithoutGuildesInput, PersonnageUncheckedCreateWithoutGuildesInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutGuildesInput
    upsert?: PersonnageUpsertWithoutGuildesInput
    connect?: PersonnageWhereUniqueInput
    update?: XOR<XOR<PersonnageUpdateToOneWithWhereWithoutGuildesInput, PersonnageUpdateWithoutGuildesInput>, PersonnageUncheckedUpdateWithoutGuildesInput>
  }

  export type GuildeUpdateOneRequiredWithoutMembresNestedInput = {
    create?: XOR<GuildeCreateWithoutMembresInput, GuildeUncheckedCreateWithoutMembresInput>
    connectOrCreate?: GuildeCreateOrConnectWithoutMembresInput
    upsert?: GuildeUpsertWithoutMembresInput
    connect?: GuildeWhereUniqueInput
    update?: XOR<XOR<GuildeUpdateToOneWithWhereWithoutMembresInput, GuildeUpdateWithoutMembresInput>, GuildeUncheckedUpdateWithoutMembresInput>
  }

  export type CreatureBatailleCreateNestedManyWithoutCreatureInput = {
    create?: XOR<CreatureBatailleCreateWithoutCreatureInput, CreatureBatailleUncheckedCreateWithoutCreatureInput> | CreatureBatailleCreateWithoutCreatureInput[] | CreatureBatailleUncheckedCreateWithoutCreatureInput[]
    connectOrCreate?: CreatureBatailleCreateOrConnectWithoutCreatureInput | CreatureBatailleCreateOrConnectWithoutCreatureInput[]
    createMany?: CreatureBatailleCreateManyCreatureInputEnvelope
    connect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
  }

  export type CreatureBatailleUncheckedCreateNestedManyWithoutCreatureInput = {
    create?: XOR<CreatureBatailleCreateWithoutCreatureInput, CreatureBatailleUncheckedCreateWithoutCreatureInput> | CreatureBatailleCreateWithoutCreatureInput[] | CreatureBatailleUncheckedCreateWithoutCreatureInput[]
    connectOrCreate?: CreatureBatailleCreateOrConnectWithoutCreatureInput | CreatureBatailleCreateOrConnectWithoutCreatureInput[]
    createMany?: CreatureBatailleCreateManyCreatureInputEnvelope
    connect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
  }

  export type CreatureBatailleUpdateManyWithoutCreatureNestedInput = {
    create?: XOR<CreatureBatailleCreateWithoutCreatureInput, CreatureBatailleUncheckedCreateWithoutCreatureInput> | CreatureBatailleCreateWithoutCreatureInput[] | CreatureBatailleUncheckedCreateWithoutCreatureInput[]
    connectOrCreate?: CreatureBatailleCreateOrConnectWithoutCreatureInput | CreatureBatailleCreateOrConnectWithoutCreatureInput[]
    upsert?: CreatureBatailleUpsertWithWhereUniqueWithoutCreatureInput | CreatureBatailleUpsertWithWhereUniqueWithoutCreatureInput[]
    createMany?: CreatureBatailleCreateManyCreatureInputEnvelope
    set?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    disconnect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    delete?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    connect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    update?: CreatureBatailleUpdateWithWhereUniqueWithoutCreatureInput | CreatureBatailleUpdateWithWhereUniqueWithoutCreatureInput[]
    updateMany?: CreatureBatailleUpdateManyWithWhereWithoutCreatureInput | CreatureBatailleUpdateManyWithWhereWithoutCreatureInput[]
    deleteMany?: CreatureBatailleScalarWhereInput | CreatureBatailleScalarWhereInput[]
  }

  export type CreatureBatailleUncheckedUpdateManyWithoutCreatureNestedInput = {
    create?: XOR<CreatureBatailleCreateWithoutCreatureInput, CreatureBatailleUncheckedCreateWithoutCreatureInput> | CreatureBatailleCreateWithoutCreatureInput[] | CreatureBatailleUncheckedCreateWithoutCreatureInput[]
    connectOrCreate?: CreatureBatailleCreateOrConnectWithoutCreatureInput | CreatureBatailleCreateOrConnectWithoutCreatureInput[]
    upsert?: CreatureBatailleUpsertWithWhereUniqueWithoutCreatureInput | CreatureBatailleUpsertWithWhereUniqueWithoutCreatureInput[]
    createMany?: CreatureBatailleCreateManyCreatureInputEnvelope
    set?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    disconnect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    delete?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    connect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    update?: CreatureBatailleUpdateWithWhereUniqueWithoutCreatureInput | CreatureBatailleUpdateWithWhereUniqueWithoutCreatureInput[]
    updateMany?: CreatureBatailleUpdateManyWithWhereWithoutCreatureInput | CreatureBatailleUpdateManyWithWhereWithoutCreatureInput[]
    deleteMany?: CreatureBatailleScalarWhereInput | CreatureBatailleScalarWhereInput[]
  }

  export type SortCreateNestedManyWithoutEcoleInput = {
    create?: XOR<SortCreateWithoutEcoleInput, SortUncheckedCreateWithoutEcoleInput> | SortCreateWithoutEcoleInput[] | SortUncheckedCreateWithoutEcoleInput[]
    connectOrCreate?: SortCreateOrConnectWithoutEcoleInput | SortCreateOrConnectWithoutEcoleInput[]
    createMany?: SortCreateManyEcoleInputEnvelope
    connect?: SortWhereUniqueInput | SortWhereUniqueInput[]
  }

  export type SortUncheckedCreateNestedManyWithoutEcoleInput = {
    create?: XOR<SortCreateWithoutEcoleInput, SortUncheckedCreateWithoutEcoleInput> | SortCreateWithoutEcoleInput[] | SortUncheckedCreateWithoutEcoleInput[]
    connectOrCreate?: SortCreateOrConnectWithoutEcoleInput | SortCreateOrConnectWithoutEcoleInput[]
    createMany?: SortCreateManyEcoleInputEnvelope
    connect?: SortWhereUniqueInput | SortWhereUniqueInput[]
  }

  export type SortUpdateManyWithoutEcoleNestedInput = {
    create?: XOR<SortCreateWithoutEcoleInput, SortUncheckedCreateWithoutEcoleInput> | SortCreateWithoutEcoleInput[] | SortUncheckedCreateWithoutEcoleInput[]
    connectOrCreate?: SortCreateOrConnectWithoutEcoleInput | SortCreateOrConnectWithoutEcoleInput[]
    upsert?: SortUpsertWithWhereUniqueWithoutEcoleInput | SortUpsertWithWhereUniqueWithoutEcoleInput[]
    createMany?: SortCreateManyEcoleInputEnvelope
    set?: SortWhereUniqueInput | SortWhereUniqueInput[]
    disconnect?: SortWhereUniqueInput | SortWhereUniqueInput[]
    delete?: SortWhereUniqueInput | SortWhereUniqueInput[]
    connect?: SortWhereUniqueInput | SortWhereUniqueInput[]
    update?: SortUpdateWithWhereUniqueWithoutEcoleInput | SortUpdateWithWhereUniqueWithoutEcoleInput[]
    updateMany?: SortUpdateManyWithWhereWithoutEcoleInput | SortUpdateManyWithWhereWithoutEcoleInput[]
    deleteMany?: SortScalarWhereInput | SortScalarWhereInput[]
  }

  export type SortUncheckedUpdateManyWithoutEcoleNestedInput = {
    create?: XOR<SortCreateWithoutEcoleInput, SortUncheckedCreateWithoutEcoleInput> | SortCreateWithoutEcoleInput[] | SortUncheckedCreateWithoutEcoleInput[]
    connectOrCreate?: SortCreateOrConnectWithoutEcoleInput | SortCreateOrConnectWithoutEcoleInput[]
    upsert?: SortUpsertWithWhereUniqueWithoutEcoleInput | SortUpsertWithWhereUniqueWithoutEcoleInput[]
    createMany?: SortCreateManyEcoleInputEnvelope
    set?: SortWhereUniqueInput | SortWhereUniqueInput[]
    disconnect?: SortWhereUniqueInput | SortWhereUniqueInput[]
    delete?: SortWhereUniqueInput | SortWhereUniqueInput[]
    connect?: SortWhereUniqueInput | SortWhereUniqueInput[]
    update?: SortUpdateWithWhereUniqueWithoutEcoleInput | SortUpdateWithWhereUniqueWithoutEcoleInput[]
    updateMany?: SortUpdateManyWithWhereWithoutEcoleInput | SortUpdateManyWithWhereWithoutEcoleInput[]
    deleteMany?: SortScalarWhereInput | SortScalarWhereInput[]
  }

  export type EcoleMagieCreateNestedOneWithoutSortsInput = {
    create?: XOR<EcoleMagieCreateWithoutSortsInput, EcoleMagieUncheckedCreateWithoutSortsInput>
    connectOrCreate?: EcoleMagieCreateOrConnectWithoutSortsInput
    connect?: EcoleMagieWhereUniqueInput
  }

  export type EcoleMagieUpdateOneWithoutSortsNestedInput = {
    create?: XOR<EcoleMagieCreateWithoutSortsInput, EcoleMagieUncheckedCreateWithoutSortsInput>
    connectOrCreate?: EcoleMagieCreateOrConnectWithoutSortsInput
    upsert?: EcoleMagieUpsertWithoutSortsInput
    disconnect?: EcoleMagieWhereInput | boolean
    delete?: EcoleMagieWhereInput | boolean
    connect?: EcoleMagieWhereUniqueInput
    update?: XOR<XOR<EcoleMagieUpdateToOneWithWhereWithoutSortsInput, EcoleMagieUpdateWithoutSortsInput>, EcoleMagieUncheckedUpdateWithoutSortsInput>
  }

  export type PersonnageMaladieCreateNestedManyWithoutMaladieInput = {
    create?: XOR<PersonnageMaladieCreateWithoutMaladieInput, PersonnageMaladieUncheckedCreateWithoutMaladieInput> | PersonnageMaladieCreateWithoutMaladieInput[] | PersonnageMaladieUncheckedCreateWithoutMaladieInput[]
    connectOrCreate?: PersonnageMaladieCreateOrConnectWithoutMaladieInput | PersonnageMaladieCreateOrConnectWithoutMaladieInput[]
    createMany?: PersonnageMaladieCreateManyMaladieInputEnvelope
    connect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
  }

  export type PersonnageMaladieUncheckedCreateNestedManyWithoutMaladieInput = {
    create?: XOR<PersonnageMaladieCreateWithoutMaladieInput, PersonnageMaladieUncheckedCreateWithoutMaladieInput> | PersonnageMaladieCreateWithoutMaladieInput[] | PersonnageMaladieUncheckedCreateWithoutMaladieInput[]
    connectOrCreate?: PersonnageMaladieCreateOrConnectWithoutMaladieInput | PersonnageMaladieCreateOrConnectWithoutMaladieInput[]
    createMany?: PersonnageMaladieCreateManyMaladieInputEnvelope
    connect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonnageMaladieUpdateManyWithoutMaladieNestedInput = {
    create?: XOR<PersonnageMaladieCreateWithoutMaladieInput, PersonnageMaladieUncheckedCreateWithoutMaladieInput> | PersonnageMaladieCreateWithoutMaladieInput[] | PersonnageMaladieUncheckedCreateWithoutMaladieInput[]
    connectOrCreate?: PersonnageMaladieCreateOrConnectWithoutMaladieInput | PersonnageMaladieCreateOrConnectWithoutMaladieInput[]
    upsert?: PersonnageMaladieUpsertWithWhereUniqueWithoutMaladieInput | PersonnageMaladieUpsertWithWhereUniqueWithoutMaladieInput[]
    createMany?: PersonnageMaladieCreateManyMaladieInputEnvelope
    set?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    disconnect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    delete?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    connect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    update?: PersonnageMaladieUpdateWithWhereUniqueWithoutMaladieInput | PersonnageMaladieUpdateWithWhereUniqueWithoutMaladieInput[]
    updateMany?: PersonnageMaladieUpdateManyWithWhereWithoutMaladieInput | PersonnageMaladieUpdateManyWithWhereWithoutMaladieInput[]
    deleteMany?: PersonnageMaladieScalarWhereInput | PersonnageMaladieScalarWhereInput[]
  }

  export type PersonnageMaladieUncheckedUpdateManyWithoutMaladieNestedInput = {
    create?: XOR<PersonnageMaladieCreateWithoutMaladieInput, PersonnageMaladieUncheckedCreateWithoutMaladieInput> | PersonnageMaladieCreateWithoutMaladieInput[] | PersonnageMaladieUncheckedCreateWithoutMaladieInput[]
    connectOrCreate?: PersonnageMaladieCreateOrConnectWithoutMaladieInput | PersonnageMaladieCreateOrConnectWithoutMaladieInput[]
    upsert?: PersonnageMaladieUpsertWithWhereUniqueWithoutMaladieInput | PersonnageMaladieUpsertWithWhereUniqueWithoutMaladieInput[]
    createMany?: PersonnageMaladieCreateManyMaladieInputEnvelope
    set?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    disconnect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    delete?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    connect?: PersonnageMaladieWhereUniqueInput | PersonnageMaladieWhereUniqueInput[]
    update?: PersonnageMaladieUpdateWithWhereUniqueWithoutMaladieInput | PersonnageMaladieUpdateWithWhereUniqueWithoutMaladieInput[]
    updateMany?: PersonnageMaladieUpdateManyWithWhereWithoutMaladieInput | PersonnageMaladieUpdateManyWithWhereWithoutMaladieInput[]
    deleteMany?: PersonnageMaladieScalarWhereInput | PersonnageMaladieScalarWhereInput[]
  }

  export type PersonnageCreateNestedOneWithoutMaladiesInput = {
    create?: XOR<PersonnageCreateWithoutMaladiesInput, PersonnageUncheckedCreateWithoutMaladiesInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutMaladiesInput
    connect?: PersonnageWhereUniqueInput
  }

  export type MaladieCreateNestedOneWithoutCasInput = {
    create?: XOR<MaladieCreateWithoutCasInput, MaladieUncheckedCreateWithoutCasInput>
    connectOrCreate?: MaladieCreateOrConnectWithoutCasInput
    connect?: MaladieWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PersonnageUpdateOneRequiredWithoutMaladiesNestedInput = {
    create?: XOR<PersonnageCreateWithoutMaladiesInput, PersonnageUncheckedCreateWithoutMaladiesInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutMaladiesInput
    upsert?: PersonnageUpsertWithoutMaladiesInput
    connect?: PersonnageWhereUniqueInput
    update?: XOR<XOR<PersonnageUpdateToOneWithWhereWithoutMaladiesInput, PersonnageUpdateWithoutMaladiesInput>, PersonnageUncheckedUpdateWithoutMaladiesInput>
  }

  export type MaladieUpdateOneRequiredWithoutCasNestedInput = {
    create?: XOR<MaladieCreateWithoutCasInput, MaladieUncheckedCreateWithoutCasInput>
    connectOrCreate?: MaladieCreateOrConnectWithoutCasInput
    upsert?: MaladieUpsertWithoutCasInput
    connect?: MaladieWhereUniqueInput
    update?: XOR<XOR<MaladieUpdateToOneWithWhereWithoutCasInput, MaladieUpdateWithoutCasInput>, MaladieUncheckedUpdateWithoutCasInput>
  }

  export type DomaineCreateNestedOneWithoutArmeesInput = {
    create?: XOR<DomaineCreateWithoutArmeesInput, DomaineUncheckedCreateWithoutArmeesInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutArmeesInput
    connect?: DomaineWhereUniqueInput
  }

  export type PersonnageCreateNestedOneWithoutCommandementsInput = {
    create?: XOR<PersonnageCreateWithoutCommandementsInput, PersonnageUncheckedCreateWithoutCommandementsInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutCommandementsInput
    connect?: PersonnageWhereUniqueInput
  }

  export type ArmeeBatailleCreateNestedManyWithoutArmeeInput = {
    create?: XOR<ArmeeBatailleCreateWithoutArmeeInput, ArmeeBatailleUncheckedCreateWithoutArmeeInput> | ArmeeBatailleCreateWithoutArmeeInput[] | ArmeeBatailleUncheckedCreateWithoutArmeeInput[]
    connectOrCreate?: ArmeeBatailleCreateOrConnectWithoutArmeeInput | ArmeeBatailleCreateOrConnectWithoutArmeeInput[]
    createMany?: ArmeeBatailleCreateManyArmeeInputEnvelope
    connect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
  }

  export type InventaireCreateNestedManyWithoutArmeeInput = {
    create?: XOR<InventaireCreateWithoutArmeeInput, InventaireUncheckedCreateWithoutArmeeInput> | InventaireCreateWithoutArmeeInput[] | InventaireUncheckedCreateWithoutArmeeInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutArmeeInput | InventaireCreateOrConnectWithoutArmeeInput[]
    createMany?: InventaireCreateManyArmeeInputEnvelope
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
  }

  export type ArmeeBatailleUncheckedCreateNestedManyWithoutArmeeInput = {
    create?: XOR<ArmeeBatailleCreateWithoutArmeeInput, ArmeeBatailleUncheckedCreateWithoutArmeeInput> | ArmeeBatailleCreateWithoutArmeeInput[] | ArmeeBatailleUncheckedCreateWithoutArmeeInput[]
    connectOrCreate?: ArmeeBatailleCreateOrConnectWithoutArmeeInput | ArmeeBatailleCreateOrConnectWithoutArmeeInput[]
    createMany?: ArmeeBatailleCreateManyArmeeInputEnvelope
    connect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
  }

  export type InventaireUncheckedCreateNestedManyWithoutArmeeInput = {
    create?: XOR<InventaireCreateWithoutArmeeInput, InventaireUncheckedCreateWithoutArmeeInput> | InventaireCreateWithoutArmeeInput[] | InventaireUncheckedCreateWithoutArmeeInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutArmeeInput | InventaireCreateOrConnectWithoutArmeeInput[]
    createMany?: InventaireCreateManyArmeeInputEnvelope
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
  }

  export type DomaineUpdateOneWithoutArmeesNestedInput = {
    create?: XOR<DomaineCreateWithoutArmeesInput, DomaineUncheckedCreateWithoutArmeesInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutArmeesInput
    upsert?: DomaineUpsertWithoutArmeesInput
    disconnect?: DomaineWhereInput | boolean
    delete?: DomaineWhereInput | boolean
    connect?: DomaineWhereUniqueInput
    update?: XOR<XOR<DomaineUpdateToOneWithWhereWithoutArmeesInput, DomaineUpdateWithoutArmeesInput>, DomaineUncheckedUpdateWithoutArmeesInput>
  }

  export type PersonnageUpdateOneWithoutCommandementsNestedInput = {
    create?: XOR<PersonnageCreateWithoutCommandementsInput, PersonnageUncheckedCreateWithoutCommandementsInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutCommandementsInput
    upsert?: PersonnageUpsertWithoutCommandementsInput
    disconnect?: PersonnageWhereInput | boolean
    delete?: PersonnageWhereInput | boolean
    connect?: PersonnageWhereUniqueInput
    update?: XOR<XOR<PersonnageUpdateToOneWithWhereWithoutCommandementsInput, PersonnageUpdateWithoutCommandementsInput>, PersonnageUncheckedUpdateWithoutCommandementsInput>
  }

  export type ArmeeBatailleUpdateManyWithoutArmeeNestedInput = {
    create?: XOR<ArmeeBatailleCreateWithoutArmeeInput, ArmeeBatailleUncheckedCreateWithoutArmeeInput> | ArmeeBatailleCreateWithoutArmeeInput[] | ArmeeBatailleUncheckedCreateWithoutArmeeInput[]
    connectOrCreate?: ArmeeBatailleCreateOrConnectWithoutArmeeInput | ArmeeBatailleCreateOrConnectWithoutArmeeInput[]
    upsert?: ArmeeBatailleUpsertWithWhereUniqueWithoutArmeeInput | ArmeeBatailleUpsertWithWhereUniqueWithoutArmeeInput[]
    createMany?: ArmeeBatailleCreateManyArmeeInputEnvelope
    set?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    disconnect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    delete?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    connect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    update?: ArmeeBatailleUpdateWithWhereUniqueWithoutArmeeInput | ArmeeBatailleUpdateWithWhereUniqueWithoutArmeeInput[]
    updateMany?: ArmeeBatailleUpdateManyWithWhereWithoutArmeeInput | ArmeeBatailleUpdateManyWithWhereWithoutArmeeInput[]
    deleteMany?: ArmeeBatailleScalarWhereInput | ArmeeBatailleScalarWhereInput[]
  }

  export type InventaireUpdateManyWithoutArmeeNestedInput = {
    create?: XOR<InventaireCreateWithoutArmeeInput, InventaireUncheckedCreateWithoutArmeeInput> | InventaireCreateWithoutArmeeInput[] | InventaireUncheckedCreateWithoutArmeeInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutArmeeInput | InventaireCreateOrConnectWithoutArmeeInput[]
    upsert?: InventaireUpsertWithWhereUniqueWithoutArmeeInput | InventaireUpsertWithWhereUniqueWithoutArmeeInput[]
    createMany?: InventaireCreateManyArmeeInputEnvelope
    set?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    disconnect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    delete?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    update?: InventaireUpdateWithWhereUniqueWithoutArmeeInput | InventaireUpdateWithWhereUniqueWithoutArmeeInput[]
    updateMany?: InventaireUpdateManyWithWhereWithoutArmeeInput | InventaireUpdateManyWithWhereWithoutArmeeInput[]
    deleteMany?: InventaireScalarWhereInput | InventaireScalarWhereInput[]
  }

  export type ArmeeBatailleUncheckedUpdateManyWithoutArmeeNestedInput = {
    create?: XOR<ArmeeBatailleCreateWithoutArmeeInput, ArmeeBatailleUncheckedCreateWithoutArmeeInput> | ArmeeBatailleCreateWithoutArmeeInput[] | ArmeeBatailleUncheckedCreateWithoutArmeeInput[]
    connectOrCreate?: ArmeeBatailleCreateOrConnectWithoutArmeeInput | ArmeeBatailleCreateOrConnectWithoutArmeeInput[]
    upsert?: ArmeeBatailleUpsertWithWhereUniqueWithoutArmeeInput | ArmeeBatailleUpsertWithWhereUniqueWithoutArmeeInput[]
    createMany?: ArmeeBatailleCreateManyArmeeInputEnvelope
    set?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    disconnect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    delete?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    connect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    update?: ArmeeBatailleUpdateWithWhereUniqueWithoutArmeeInput | ArmeeBatailleUpdateWithWhereUniqueWithoutArmeeInput[]
    updateMany?: ArmeeBatailleUpdateManyWithWhereWithoutArmeeInput | ArmeeBatailleUpdateManyWithWhereWithoutArmeeInput[]
    deleteMany?: ArmeeBatailleScalarWhereInput | ArmeeBatailleScalarWhereInput[]
  }

  export type InventaireUncheckedUpdateManyWithoutArmeeNestedInput = {
    create?: XOR<InventaireCreateWithoutArmeeInput, InventaireUncheckedCreateWithoutArmeeInput> | InventaireCreateWithoutArmeeInput[] | InventaireUncheckedCreateWithoutArmeeInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutArmeeInput | InventaireCreateOrConnectWithoutArmeeInput[]
    upsert?: InventaireUpsertWithWhereUniqueWithoutArmeeInput | InventaireUpsertWithWhereUniqueWithoutArmeeInput[]
    createMany?: InventaireCreateManyArmeeInputEnvelope
    set?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    disconnect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    delete?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    update?: InventaireUpdateWithWhereUniqueWithoutArmeeInput | InventaireUpdateWithWhereUniqueWithoutArmeeInput[]
    updateMany?: InventaireUpdateManyWithWhereWithoutArmeeInput | InventaireUpdateManyWithWhereWithoutArmeeInput[]
    deleteMany?: InventaireScalarWhereInput | InventaireScalarWhereInput[]
  }

  export type ArmeeBatailleCreateNestedManyWithoutBatailleInput = {
    create?: XOR<ArmeeBatailleCreateWithoutBatailleInput, ArmeeBatailleUncheckedCreateWithoutBatailleInput> | ArmeeBatailleCreateWithoutBatailleInput[] | ArmeeBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: ArmeeBatailleCreateOrConnectWithoutBatailleInput | ArmeeBatailleCreateOrConnectWithoutBatailleInput[]
    createMany?: ArmeeBatailleCreateManyBatailleInputEnvelope
    connect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
  }

  export type GuildeBatailleCreateNestedManyWithoutBatailleInput = {
    create?: XOR<GuildeBatailleCreateWithoutBatailleInput, GuildeBatailleUncheckedCreateWithoutBatailleInput> | GuildeBatailleCreateWithoutBatailleInput[] | GuildeBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: GuildeBatailleCreateOrConnectWithoutBatailleInput | GuildeBatailleCreateOrConnectWithoutBatailleInput[]
    createMany?: GuildeBatailleCreateManyBatailleInputEnvelope
    connect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
  }

  export type CreatureBatailleCreateNestedManyWithoutBatailleInput = {
    create?: XOR<CreatureBatailleCreateWithoutBatailleInput, CreatureBatailleUncheckedCreateWithoutBatailleInput> | CreatureBatailleCreateWithoutBatailleInput[] | CreatureBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: CreatureBatailleCreateOrConnectWithoutBatailleInput | CreatureBatailleCreateOrConnectWithoutBatailleInput[]
    createMany?: CreatureBatailleCreateManyBatailleInputEnvelope
    connect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
  }

  export type ArmeeBatailleUncheckedCreateNestedManyWithoutBatailleInput = {
    create?: XOR<ArmeeBatailleCreateWithoutBatailleInput, ArmeeBatailleUncheckedCreateWithoutBatailleInput> | ArmeeBatailleCreateWithoutBatailleInput[] | ArmeeBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: ArmeeBatailleCreateOrConnectWithoutBatailleInput | ArmeeBatailleCreateOrConnectWithoutBatailleInput[]
    createMany?: ArmeeBatailleCreateManyBatailleInputEnvelope
    connect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
  }

  export type GuildeBatailleUncheckedCreateNestedManyWithoutBatailleInput = {
    create?: XOR<GuildeBatailleCreateWithoutBatailleInput, GuildeBatailleUncheckedCreateWithoutBatailleInput> | GuildeBatailleCreateWithoutBatailleInput[] | GuildeBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: GuildeBatailleCreateOrConnectWithoutBatailleInput | GuildeBatailleCreateOrConnectWithoutBatailleInput[]
    createMany?: GuildeBatailleCreateManyBatailleInputEnvelope
    connect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
  }

  export type CreatureBatailleUncheckedCreateNestedManyWithoutBatailleInput = {
    create?: XOR<CreatureBatailleCreateWithoutBatailleInput, CreatureBatailleUncheckedCreateWithoutBatailleInput> | CreatureBatailleCreateWithoutBatailleInput[] | CreatureBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: CreatureBatailleCreateOrConnectWithoutBatailleInput | CreatureBatailleCreateOrConnectWithoutBatailleInput[]
    createMany?: CreatureBatailleCreateManyBatailleInputEnvelope
    connect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
  }

  export type ArmeeBatailleUpdateManyWithoutBatailleNestedInput = {
    create?: XOR<ArmeeBatailleCreateWithoutBatailleInput, ArmeeBatailleUncheckedCreateWithoutBatailleInput> | ArmeeBatailleCreateWithoutBatailleInput[] | ArmeeBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: ArmeeBatailleCreateOrConnectWithoutBatailleInput | ArmeeBatailleCreateOrConnectWithoutBatailleInput[]
    upsert?: ArmeeBatailleUpsertWithWhereUniqueWithoutBatailleInput | ArmeeBatailleUpsertWithWhereUniqueWithoutBatailleInput[]
    createMany?: ArmeeBatailleCreateManyBatailleInputEnvelope
    set?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    disconnect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    delete?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    connect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    update?: ArmeeBatailleUpdateWithWhereUniqueWithoutBatailleInput | ArmeeBatailleUpdateWithWhereUniqueWithoutBatailleInput[]
    updateMany?: ArmeeBatailleUpdateManyWithWhereWithoutBatailleInput | ArmeeBatailleUpdateManyWithWhereWithoutBatailleInput[]
    deleteMany?: ArmeeBatailleScalarWhereInput | ArmeeBatailleScalarWhereInput[]
  }

  export type GuildeBatailleUpdateManyWithoutBatailleNestedInput = {
    create?: XOR<GuildeBatailleCreateWithoutBatailleInput, GuildeBatailleUncheckedCreateWithoutBatailleInput> | GuildeBatailleCreateWithoutBatailleInput[] | GuildeBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: GuildeBatailleCreateOrConnectWithoutBatailleInput | GuildeBatailleCreateOrConnectWithoutBatailleInput[]
    upsert?: GuildeBatailleUpsertWithWhereUniqueWithoutBatailleInput | GuildeBatailleUpsertWithWhereUniqueWithoutBatailleInput[]
    createMany?: GuildeBatailleCreateManyBatailleInputEnvelope
    set?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    disconnect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    delete?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    connect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    update?: GuildeBatailleUpdateWithWhereUniqueWithoutBatailleInput | GuildeBatailleUpdateWithWhereUniqueWithoutBatailleInput[]
    updateMany?: GuildeBatailleUpdateManyWithWhereWithoutBatailleInput | GuildeBatailleUpdateManyWithWhereWithoutBatailleInput[]
    deleteMany?: GuildeBatailleScalarWhereInput | GuildeBatailleScalarWhereInput[]
  }

  export type CreatureBatailleUpdateManyWithoutBatailleNestedInput = {
    create?: XOR<CreatureBatailleCreateWithoutBatailleInput, CreatureBatailleUncheckedCreateWithoutBatailleInput> | CreatureBatailleCreateWithoutBatailleInput[] | CreatureBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: CreatureBatailleCreateOrConnectWithoutBatailleInput | CreatureBatailleCreateOrConnectWithoutBatailleInput[]
    upsert?: CreatureBatailleUpsertWithWhereUniqueWithoutBatailleInput | CreatureBatailleUpsertWithWhereUniqueWithoutBatailleInput[]
    createMany?: CreatureBatailleCreateManyBatailleInputEnvelope
    set?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    disconnect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    delete?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    connect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    update?: CreatureBatailleUpdateWithWhereUniqueWithoutBatailleInput | CreatureBatailleUpdateWithWhereUniqueWithoutBatailleInput[]
    updateMany?: CreatureBatailleUpdateManyWithWhereWithoutBatailleInput | CreatureBatailleUpdateManyWithWhereWithoutBatailleInput[]
    deleteMany?: CreatureBatailleScalarWhereInput | CreatureBatailleScalarWhereInput[]
  }

  export type ArmeeBatailleUncheckedUpdateManyWithoutBatailleNestedInput = {
    create?: XOR<ArmeeBatailleCreateWithoutBatailleInput, ArmeeBatailleUncheckedCreateWithoutBatailleInput> | ArmeeBatailleCreateWithoutBatailleInput[] | ArmeeBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: ArmeeBatailleCreateOrConnectWithoutBatailleInput | ArmeeBatailleCreateOrConnectWithoutBatailleInput[]
    upsert?: ArmeeBatailleUpsertWithWhereUniqueWithoutBatailleInput | ArmeeBatailleUpsertWithWhereUniqueWithoutBatailleInput[]
    createMany?: ArmeeBatailleCreateManyBatailleInputEnvelope
    set?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    disconnect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    delete?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    connect?: ArmeeBatailleWhereUniqueInput | ArmeeBatailleWhereUniqueInput[]
    update?: ArmeeBatailleUpdateWithWhereUniqueWithoutBatailleInput | ArmeeBatailleUpdateWithWhereUniqueWithoutBatailleInput[]
    updateMany?: ArmeeBatailleUpdateManyWithWhereWithoutBatailleInput | ArmeeBatailleUpdateManyWithWhereWithoutBatailleInput[]
    deleteMany?: ArmeeBatailleScalarWhereInput | ArmeeBatailleScalarWhereInput[]
  }

  export type GuildeBatailleUncheckedUpdateManyWithoutBatailleNestedInput = {
    create?: XOR<GuildeBatailleCreateWithoutBatailleInput, GuildeBatailleUncheckedCreateWithoutBatailleInput> | GuildeBatailleCreateWithoutBatailleInput[] | GuildeBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: GuildeBatailleCreateOrConnectWithoutBatailleInput | GuildeBatailleCreateOrConnectWithoutBatailleInput[]
    upsert?: GuildeBatailleUpsertWithWhereUniqueWithoutBatailleInput | GuildeBatailleUpsertWithWhereUniqueWithoutBatailleInput[]
    createMany?: GuildeBatailleCreateManyBatailleInputEnvelope
    set?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    disconnect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    delete?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    connect?: GuildeBatailleWhereUniqueInput | GuildeBatailleWhereUniqueInput[]
    update?: GuildeBatailleUpdateWithWhereUniqueWithoutBatailleInput | GuildeBatailleUpdateWithWhereUniqueWithoutBatailleInput[]
    updateMany?: GuildeBatailleUpdateManyWithWhereWithoutBatailleInput | GuildeBatailleUpdateManyWithWhereWithoutBatailleInput[]
    deleteMany?: GuildeBatailleScalarWhereInput | GuildeBatailleScalarWhereInput[]
  }

  export type CreatureBatailleUncheckedUpdateManyWithoutBatailleNestedInput = {
    create?: XOR<CreatureBatailleCreateWithoutBatailleInput, CreatureBatailleUncheckedCreateWithoutBatailleInput> | CreatureBatailleCreateWithoutBatailleInput[] | CreatureBatailleUncheckedCreateWithoutBatailleInput[]
    connectOrCreate?: CreatureBatailleCreateOrConnectWithoutBatailleInput | CreatureBatailleCreateOrConnectWithoutBatailleInput[]
    upsert?: CreatureBatailleUpsertWithWhereUniqueWithoutBatailleInput | CreatureBatailleUpsertWithWhereUniqueWithoutBatailleInput[]
    createMany?: CreatureBatailleCreateManyBatailleInputEnvelope
    set?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    disconnect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    delete?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    connect?: CreatureBatailleWhereUniqueInput | CreatureBatailleWhereUniqueInput[]
    update?: CreatureBatailleUpdateWithWhereUniqueWithoutBatailleInput | CreatureBatailleUpdateWithWhereUniqueWithoutBatailleInput[]
    updateMany?: CreatureBatailleUpdateManyWithWhereWithoutBatailleInput | CreatureBatailleUpdateManyWithWhereWithoutBatailleInput[]
    deleteMany?: CreatureBatailleScalarWhereInput | CreatureBatailleScalarWhereInput[]
  }

  export type ArmeeCreateNestedOneWithoutBataillesInput = {
    create?: XOR<ArmeeCreateWithoutBataillesInput, ArmeeUncheckedCreateWithoutBataillesInput>
    connectOrCreate?: ArmeeCreateOrConnectWithoutBataillesInput
    connect?: ArmeeWhereUniqueInput
  }

  export type BatailleCreateNestedOneWithoutArmeesInput = {
    create?: XOR<BatailleCreateWithoutArmeesInput, BatailleUncheckedCreateWithoutArmeesInput>
    connectOrCreate?: BatailleCreateOrConnectWithoutArmeesInput
    connect?: BatailleWhereUniqueInput
  }

  export type ArmeeUpdateOneRequiredWithoutBataillesNestedInput = {
    create?: XOR<ArmeeCreateWithoutBataillesInput, ArmeeUncheckedCreateWithoutBataillesInput>
    connectOrCreate?: ArmeeCreateOrConnectWithoutBataillesInput
    upsert?: ArmeeUpsertWithoutBataillesInput
    connect?: ArmeeWhereUniqueInput
    update?: XOR<XOR<ArmeeUpdateToOneWithWhereWithoutBataillesInput, ArmeeUpdateWithoutBataillesInput>, ArmeeUncheckedUpdateWithoutBataillesInput>
  }

  export type BatailleUpdateOneRequiredWithoutArmeesNestedInput = {
    create?: XOR<BatailleCreateWithoutArmeesInput, BatailleUncheckedCreateWithoutArmeesInput>
    connectOrCreate?: BatailleCreateOrConnectWithoutArmeesInput
    upsert?: BatailleUpsertWithoutArmeesInput
    connect?: BatailleWhereUniqueInput
    update?: XOR<XOR<BatailleUpdateToOneWithWhereWithoutArmeesInput, BatailleUpdateWithoutArmeesInput>, BatailleUncheckedUpdateWithoutArmeesInput>
  }

  export type GuildeCreateNestedOneWithoutBataillesInput = {
    create?: XOR<GuildeCreateWithoutBataillesInput, GuildeUncheckedCreateWithoutBataillesInput>
    connectOrCreate?: GuildeCreateOrConnectWithoutBataillesInput
    connect?: GuildeWhereUniqueInput
  }

  export type BatailleCreateNestedOneWithoutGuildesInput = {
    create?: XOR<BatailleCreateWithoutGuildesInput, BatailleUncheckedCreateWithoutGuildesInput>
    connectOrCreate?: BatailleCreateOrConnectWithoutGuildesInput
    connect?: BatailleWhereUniqueInput
  }

  export type GuildeUpdateOneRequiredWithoutBataillesNestedInput = {
    create?: XOR<GuildeCreateWithoutBataillesInput, GuildeUncheckedCreateWithoutBataillesInput>
    connectOrCreate?: GuildeCreateOrConnectWithoutBataillesInput
    upsert?: GuildeUpsertWithoutBataillesInput
    connect?: GuildeWhereUniqueInput
    update?: XOR<XOR<GuildeUpdateToOneWithWhereWithoutBataillesInput, GuildeUpdateWithoutBataillesInput>, GuildeUncheckedUpdateWithoutBataillesInput>
  }

  export type BatailleUpdateOneRequiredWithoutGuildesNestedInput = {
    create?: XOR<BatailleCreateWithoutGuildesInput, BatailleUncheckedCreateWithoutGuildesInput>
    connectOrCreate?: BatailleCreateOrConnectWithoutGuildesInput
    upsert?: BatailleUpsertWithoutGuildesInput
    connect?: BatailleWhereUniqueInput
    update?: XOR<XOR<BatailleUpdateToOneWithWhereWithoutGuildesInput, BatailleUpdateWithoutGuildesInput>, BatailleUncheckedUpdateWithoutGuildesInput>
  }

  export type CreatureCreateNestedOneWithoutBataillesInput = {
    create?: XOR<CreatureCreateWithoutBataillesInput, CreatureUncheckedCreateWithoutBataillesInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutBataillesInput
    connect?: CreatureWhereUniqueInput
  }

  export type BatailleCreateNestedOneWithoutCreaturesInput = {
    create?: XOR<BatailleCreateWithoutCreaturesInput, BatailleUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: BatailleCreateOrConnectWithoutCreaturesInput
    connect?: BatailleWhereUniqueInput
  }

  export type CreatureUpdateOneRequiredWithoutBataillesNestedInput = {
    create?: XOR<CreatureCreateWithoutBataillesInput, CreatureUncheckedCreateWithoutBataillesInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutBataillesInput
    upsert?: CreatureUpsertWithoutBataillesInput
    connect?: CreatureWhereUniqueInput
    update?: XOR<XOR<CreatureUpdateToOneWithWhereWithoutBataillesInput, CreatureUpdateWithoutBataillesInput>, CreatureUncheckedUpdateWithoutBataillesInput>
  }

  export type BatailleUpdateOneRequiredWithoutCreaturesNestedInput = {
    create?: XOR<BatailleCreateWithoutCreaturesInput, BatailleUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: BatailleCreateOrConnectWithoutCreaturesInput
    upsert?: BatailleUpsertWithoutCreaturesInput
    connect?: BatailleWhereUniqueInput
    update?: XOR<XOR<BatailleUpdateToOneWithWhereWithoutCreaturesInput, BatailleUpdateWithoutCreaturesInput>, BatailleUncheckedUpdateWithoutCreaturesInput>
  }

  export type PersonnageEquipementCreateNestedManyWithoutEquipementInput = {
    create?: XOR<PersonnageEquipementCreateWithoutEquipementInput, PersonnageEquipementUncheckedCreateWithoutEquipementInput> | PersonnageEquipementCreateWithoutEquipementInput[] | PersonnageEquipementUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: PersonnageEquipementCreateOrConnectWithoutEquipementInput | PersonnageEquipementCreateOrConnectWithoutEquipementInput[]
    createMany?: PersonnageEquipementCreateManyEquipementInputEnvelope
    connect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
  }

  export type PersonnageEquipementUncheckedCreateNestedManyWithoutEquipementInput = {
    create?: XOR<PersonnageEquipementCreateWithoutEquipementInput, PersonnageEquipementUncheckedCreateWithoutEquipementInput> | PersonnageEquipementCreateWithoutEquipementInput[] | PersonnageEquipementUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: PersonnageEquipementCreateOrConnectWithoutEquipementInput | PersonnageEquipementCreateOrConnectWithoutEquipementInput[]
    createMany?: PersonnageEquipementCreateManyEquipementInputEnvelope
    connect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
  }

  export type PersonnageEquipementUpdateManyWithoutEquipementNestedInput = {
    create?: XOR<PersonnageEquipementCreateWithoutEquipementInput, PersonnageEquipementUncheckedCreateWithoutEquipementInput> | PersonnageEquipementCreateWithoutEquipementInput[] | PersonnageEquipementUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: PersonnageEquipementCreateOrConnectWithoutEquipementInput | PersonnageEquipementCreateOrConnectWithoutEquipementInput[]
    upsert?: PersonnageEquipementUpsertWithWhereUniqueWithoutEquipementInput | PersonnageEquipementUpsertWithWhereUniqueWithoutEquipementInput[]
    createMany?: PersonnageEquipementCreateManyEquipementInputEnvelope
    set?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    disconnect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    delete?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    connect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    update?: PersonnageEquipementUpdateWithWhereUniqueWithoutEquipementInput | PersonnageEquipementUpdateWithWhereUniqueWithoutEquipementInput[]
    updateMany?: PersonnageEquipementUpdateManyWithWhereWithoutEquipementInput | PersonnageEquipementUpdateManyWithWhereWithoutEquipementInput[]
    deleteMany?: PersonnageEquipementScalarWhereInput | PersonnageEquipementScalarWhereInput[]
  }

  export type PersonnageEquipementUncheckedUpdateManyWithoutEquipementNestedInput = {
    create?: XOR<PersonnageEquipementCreateWithoutEquipementInput, PersonnageEquipementUncheckedCreateWithoutEquipementInput> | PersonnageEquipementCreateWithoutEquipementInput[] | PersonnageEquipementUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: PersonnageEquipementCreateOrConnectWithoutEquipementInput | PersonnageEquipementCreateOrConnectWithoutEquipementInput[]
    upsert?: PersonnageEquipementUpsertWithWhereUniqueWithoutEquipementInput | PersonnageEquipementUpsertWithWhereUniqueWithoutEquipementInput[]
    createMany?: PersonnageEquipementCreateManyEquipementInputEnvelope
    set?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    disconnect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    delete?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    connect?: PersonnageEquipementWhereUniqueInput | PersonnageEquipementWhereUniqueInput[]
    update?: PersonnageEquipementUpdateWithWhereUniqueWithoutEquipementInput | PersonnageEquipementUpdateWithWhereUniqueWithoutEquipementInput[]
    updateMany?: PersonnageEquipementUpdateManyWithWhereWithoutEquipementInput | PersonnageEquipementUpdateManyWithWhereWithoutEquipementInput[]
    deleteMany?: PersonnageEquipementScalarWhereInput | PersonnageEquipementScalarWhereInput[]
  }

  export type PersonnageCreateNestedOneWithoutEquipementsInput = {
    create?: XOR<PersonnageCreateWithoutEquipementsInput, PersonnageUncheckedCreateWithoutEquipementsInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutEquipementsInput
    connect?: PersonnageWhereUniqueInput
  }

  export type EquipementCreateNestedOneWithoutPossesseursInput = {
    create?: XOR<EquipementCreateWithoutPossesseursInput, EquipementUncheckedCreateWithoutPossesseursInput>
    connectOrCreate?: EquipementCreateOrConnectWithoutPossesseursInput
    connect?: EquipementWhereUniqueInput
  }

  export type PersonnageUpdateOneRequiredWithoutEquipementsNestedInput = {
    create?: XOR<PersonnageCreateWithoutEquipementsInput, PersonnageUncheckedCreateWithoutEquipementsInput>
    connectOrCreate?: PersonnageCreateOrConnectWithoutEquipementsInput
    upsert?: PersonnageUpsertWithoutEquipementsInput
    connect?: PersonnageWhereUniqueInput
    update?: XOR<XOR<PersonnageUpdateToOneWithWhereWithoutEquipementsInput, PersonnageUpdateWithoutEquipementsInput>, PersonnageUncheckedUpdateWithoutEquipementsInput>
  }

  export type EquipementUpdateOneRequiredWithoutPossesseursNestedInput = {
    create?: XOR<EquipementCreateWithoutPossesseursInput, EquipementUncheckedCreateWithoutPossesseursInput>
    connectOrCreate?: EquipementCreateOrConnectWithoutPossesseursInput
    upsert?: EquipementUpsertWithoutPossesseursInput
    connect?: EquipementWhereUniqueInput
    update?: XOR<XOR<EquipementUpdateToOneWithWhereWithoutPossesseursInput, EquipementUpdateWithoutPossesseursInput>, EquipementUncheckedUpdateWithoutPossesseursInput>
  }

  export type MarchandRouteCreateNestedManyWithoutMarchandInput = {
    create?: XOR<MarchandRouteCreateWithoutMarchandInput, MarchandRouteUncheckedCreateWithoutMarchandInput> | MarchandRouteCreateWithoutMarchandInput[] | MarchandRouteUncheckedCreateWithoutMarchandInput[]
    connectOrCreate?: MarchandRouteCreateOrConnectWithoutMarchandInput | MarchandRouteCreateOrConnectWithoutMarchandInput[]
    createMany?: MarchandRouteCreateManyMarchandInputEnvelope
    connect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
  }

  export type MarchandRouteUncheckedCreateNestedManyWithoutMarchandInput = {
    create?: XOR<MarchandRouteCreateWithoutMarchandInput, MarchandRouteUncheckedCreateWithoutMarchandInput> | MarchandRouteCreateWithoutMarchandInput[] | MarchandRouteUncheckedCreateWithoutMarchandInput[]
    connectOrCreate?: MarchandRouteCreateOrConnectWithoutMarchandInput | MarchandRouteCreateOrConnectWithoutMarchandInput[]
    createMany?: MarchandRouteCreateManyMarchandInputEnvelope
    connect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
  }

  export type MarchandRouteUpdateManyWithoutMarchandNestedInput = {
    create?: XOR<MarchandRouteCreateWithoutMarchandInput, MarchandRouteUncheckedCreateWithoutMarchandInput> | MarchandRouteCreateWithoutMarchandInput[] | MarchandRouteUncheckedCreateWithoutMarchandInput[]
    connectOrCreate?: MarchandRouteCreateOrConnectWithoutMarchandInput | MarchandRouteCreateOrConnectWithoutMarchandInput[]
    upsert?: MarchandRouteUpsertWithWhereUniqueWithoutMarchandInput | MarchandRouteUpsertWithWhereUniqueWithoutMarchandInput[]
    createMany?: MarchandRouteCreateManyMarchandInputEnvelope
    set?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    disconnect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    delete?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    connect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    update?: MarchandRouteUpdateWithWhereUniqueWithoutMarchandInput | MarchandRouteUpdateWithWhereUniqueWithoutMarchandInput[]
    updateMany?: MarchandRouteUpdateManyWithWhereWithoutMarchandInput | MarchandRouteUpdateManyWithWhereWithoutMarchandInput[]
    deleteMany?: MarchandRouteScalarWhereInput | MarchandRouteScalarWhereInput[]
  }

  export type MarchandRouteUncheckedUpdateManyWithoutMarchandNestedInput = {
    create?: XOR<MarchandRouteCreateWithoutMarchandInput, MarchandRouteUncheckedCreateWithoutMarchandInput> | MarchandRouteCreateWithoutMarchandInput[] | MarchandRouteUncheckedCreateWithoutMarchandInput[]
    connectOrCreate?: MarchandRouteCreateOrConnectWithoutMarchandInput | MarchandRouteCreateOrConnectWithoutMarchandInput[]
    upsert?: MarchandRouteUpsertWithWhereUniqueWithoutMarchandInput | MarchandRouteUpsertWithWhereUniqueWithoutMarchandInput[]
    createMany?: MarchandRouteCreateManyMarchandInputEnvelope
    set?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    disconnect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    delete?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    connect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    update?: MarchandRouteUpdateWithWhereUniqueWithoutMarchandInput | MarchandRouteUpdateWithWhereUniqueWithoutMarchandInput[]
    updateMany?: MarchandRouteUpdateManyWithWhereWithoutMarchandInput | MarchandRouteUpdateManyWithWhereWithoutMarchandInput[]
    deleteMany?: MarchandRouteScalarWhereInput | MarchandRouteScalarWhereInput[]
  }

  export type RouteSegmentCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteSegmentCreateWithoutRouteInput, RouteSegmentUncheckedCreateWithoutRouteInput> | RouteSegmentCreateWithoutRouteInput[] | RouteSegmentUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteSegmentCreateOrConnectWithoutRouteInput | RouteSegmentCreateOrConnectWithoutRouteInput[]
    createMany?: RouteSegmentCreateManyRouteInputEnvelope
    connect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
  }

  export type MarchandRouteCreateNestedManyWithoutRouteInput = {
    create?: XOR<MarchandRouteCreateWithoutRouteInput, MarchandRouteUncheckedCreateWithoutRouteInput> | MarchandRouteCreateWithoutRouteInput[] | MarchandRouteUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: MarchandRouteCreateOrConnectWithoutRouteInput | MarchandRouteCreateOrConnectWithoutRouteInput[]
    createMany?: MarchandRouteCreateManyRouteInputEnvelope
    connect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
  }

  export type RouteSegmentUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteSegmentCreateWithoutRouteInput, RouteSegmentUncheckedCreateWithoutRouteInput> | RouteSegmentCreateWithoutRouteInput[] | RouteSegmentUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteSegmentCreateOrConnectWithoutRouteInput | RouteSegmentCreateOrConnectWithoutRouteInput[]
    createMany?: RouteSegmentCreateManyRouteInputEnvelope
    connect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
  }

  export type MarchandRouteUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<MarchandRouteCreateWithoutRouteInput, MarchandRouteUncheckedCreateWithoutRouteInput> | MarchandRouteCreateWithoutRouteInput[] | MarchandRouteUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: MarchandRouteCreateOrConnectWithoutRouteInput | MarchandRouteCreateOrConnectWithoutRouteInput[]
    createMany?: MarchandRouteCreateManyRouteInputEnvelope
    connect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
  }

  export type RouteSegmentUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteSegmentCreateWithoutRouteInput, RouteSegmentUncheckedCreateWithoutRouteInput> | RouteSegmentCreateWithoutRouteInput[] | RouteSegmentUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteSegmentCreateOrConnectWithoutRouteInput | RouteSegmentCreateOrConnectWithoutRouteInput[]
    upsert?: RouteSegmentUpsertWithWhereUniqueWithoutRouteInput | RouteSegmentUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteSegmentCreateManyRouteInputEnvelope
    set?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    disconnect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    delete?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    connect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    update?: RouteSegmentUpdateWithWhereUniqueWithoutRouteInput | RouteSegmentUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteSegmentUpdateManyWithWhereWithoutRouteInput | RouteSegmentUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteSegmentScalarWhereInput | RouteSegmentScalarWhereInput[]
  }

  export type MarchandRouteUpdateManyWithoutRouteNestedInput = {
    create?: XOR<MarchandRouteCreateWithoutRouteInput, MarchandRouteUncheckedCreateWithoutRouteInput> | MarchandRouteCreateWithoutRouteInput[] | MarchandRouteUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: MarchandRouteCreateOrConnectWithoutRouteInput | MarchandRouteCreateOrConnectWithoutRouteInput[]
    upsert?: MarchandRouteUpsertWithWhereUniqueWithoutRouteInput | MarchandRouteUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: MarchandRouteCreateManyRouteInputEnvelope
    set?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    disconnect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    delete?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    connect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    update?: MarchandRouteUpdateWithWhereUniqueWithoutRouteInput | MarchandRouteUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: MarchandRouteUpdateManyWithWhereWithoutRouteInput | MarchandRouteUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: MarchandRouteScalarWhereInput | MarchandRouteScalarWhereInput[]
  }

  export type RouteSegmentUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteSegmentCreateWithoutRouteInput, RouteSegmentUncheckedCreateWithoutRouteInput> | RouteSegmentCreateWithoutRouteInput[] | RouteSegmentUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteSegmentCreateOrConnectWithoutRouteInput | RouteSegmentCreateOrConnectWithoutRouteInput[]
    upsert?: RouteSegmentUpsertWithWhereUniqueWithoutRouteInput | RouteSegmentUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteSegmentCreateManyRouteInputEnvelope
    set?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    disconnect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    delete?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    connect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    update?: RouteSegmentUpdateWithWhereUniqueWithoutRouteInput | RouteSegmentUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteSegmentUpdateManyWithWhereWithoutRouteInput | RouteSegmentUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteSegmentScalarWhereInput | RouteSegmentScalarWhereInput[]
  }

  export type MarchandRouteUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<MarchandRouteCreateWithoutRouteInput, MarchandRouteUncheckedCreateWithoutRouteInput> | MarchandRouteCreateWithoutRouteInput[] | MarchandRouteUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: MarchandRouteCreateOrConnectWithoutRouteInput | MarchandRouteCreateOrConnectWithoutRouteInput[]
    upsert?: MarchandRouteUpsertWithWhereUniqueWithoutRouteInput | MarchandRouteUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: MarchandRouteCreateManyRouteInputEnvelope
    set?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    disconnect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    delete?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    connect?: MarchandRouteWhereUniqueInput | MarchandRouteWhereUniqueInput[]
    update?: MarchandRouteUpdateWithWhereUniqueWithoutRouteInput | MarchandRouteUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: MarchandRouteUpdateManyWithWhereWithoutRouteInput | MarchandRouteUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: MarchandRouteScalarWhereInput | MarchandRouteScalarWhereInput[]
  }

  export type RouteSegmentCreateNestedManyWithoutLieuInput = {
    create?: XOR<RouteSegmentCreateWithoutLieuInput, RouteSegmentUncheckedCreateWithoutLieuInput> | RouteSegmentCreateWithoutLieuInput[] | RouteSegmentUncheckedCreateWithoutLieuInput[]
    connectOrCreate?: RouteSegmentCreateOrConnectWithoutLieuInput | RouteSegmentCreateOrConnectWithoutLieuInput[]
    createMany?: RouteSegmentCreateManyLieuInputEnvelope
    connect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
  }

  export type InventaireCreateNestedManyWithoutLieuInput = {
    create?: XOR<InventaireCreateWithoutLieuInput, InventaireUncheckedCreateWithoutLieuInput> | InventaireCreateWithoutLieuInput[] | InventaireUncheckedCreateWithoutLieuInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutLieuInput | InventaireCreateOrConnectWithoutLieuInput[]
    createMany?: InventaireCreateManyLieuInputEnvelope
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
  }

  export type RouteSegmentUncheckedCreateNestedManyWithoutLieuInput = {
    create?: XOR<RouteSegmentCreateWithoutLieuInput, RouteSegmentUncheckedCreateWithoutLieuInput> | RouteSegmentCreateWithoutLieuInput[] | RouteSegmentUncheckedCreateWithoutLieuInput[]
    connectOrCreate?: RouteSegmentCreateOrConnectWithoutLieuInput | RouteSegmentCreateOrConnectWithoutLieuInput[]
    createMany?: RouteSegmentCreateManyLieuInputEnvelope
    connect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
  }

  export type InventaireUncheckedCreateNestedManyWithoutLieuInput = {
    create?: XOR<InventaireCreateWithoutLieuInput, InventaireUncheckedCreateWithoutLieuInput> | InventaireCreateWithoutLieuInput[] | InventaireUncheckedCreateWithoutLieuInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutLieuInput | InventaireCreateOrConnectWithoutLieuInput[]
    createMany?: InventaireCreateManyLieuInputEnvelope
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
  }

  export type RouteSegmentUpdateManyWithoutLieuNestedInput = {
    create?: XOR<RouteSegmentCreateWithoutLieuInput, RouteSegmentUncheckedCreateWithoutLieuInput> | RouteSegmentCreateWithoutLieuInput[] | RouteSegmentUncheckedCreateWithoutLieuInput[]
    connectOrCreate?: RouteSegmentCreateOrConnectWithoutLieuInput | RouteSegmentCreateOrConnectWithoutLieuInput[]
    upsert?: RouteSegmentUpsertWithWhereUniqueWithoutLieuInput | RouteSegmentUpsertWithWhereUniqueWithoutLieuInput[]
    createMany?: RouteSegmentCreateManyLieuInputEnvelope
    set?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    disconnect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    delete?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    connect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    update?: RouteSegmentUpdateWithWhereUniqueWithoutLieuInput | RouteSegmentUpdateWithWhereUniqueWithoutLieuInput[]
    updateMany?: RouteSegmentUpdateManyWithWhereWithoutLieuInput | RouteSegmentUpdateManyWithWhereWithoutLieuInput[]
    deleteMany?: RouteSegmentScalarWhereInput | RouteSegmentScalarWhereInput[]
  }

  export type InventaireUpdateManyWithoutLieuNestedInput = {
    create?: XOR<InventaireCreateWithoutLieuInput, InventaireUncheckedCreateWithoutLieuInput> | InventaireCreateWithoutLieuInput[] | InventaireUncheckedCreateWithoutLieuInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutLieuInput | InventaireCreateOrConnectWithoutLieuInput[]
    upsert?: InventaireUpsertWithWhereUniqueWithoutLieuInput | InventaireUpsertWithWhereUniqueWithoutLieuInput[]
    createMany?: InventaireCreateManyLieuInputEnvelope
    set?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    disconnect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    delete?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    update?: InventaireUpdateWithWhereUniqueWithoutLieuInput | InventaireUpdateWithWhereUniqueWithoutLieuInput[]
    updateMany?: InventaireUpdateManyWithWhereWithoutLieuInput | InventaireUpdateManyWithWhereWithoutLieuInput[]
    deleteMany?: InventaireScalarWhereInput | InventaireScalarWhereInput[]
  }

  export type RouteSegmentUncheckedUpdateManyWithoutLieuNestedInput = {
    create?: XOR<RouteSegmentCreateWithoutLieuInput, RouteSegmentUncheckedCreateWithoutLieuInput> | RouteSegmentCreateWithoutLieuInput[] | RouteSegmentUncheckedCreateWithoutLieuInput[]
    connectOrCreate?: RouteSegmentCreateOrConnectWithoutLieuInput | RouteSegmentCreateOrConnectWithoutLieuInput[]
    upsert?: RouteSegmentUpsertWithWhereUniqueWithoutLieuInput | RouteSegmentUpsertWithWhereUniqueWithoutLieuInput[]
    createMany?: RouteSegmentCreateManyLieuInputEnvelope
    set?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    disconnect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    delete?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    connect?: RouteSegmentWhereUniqueInput | RouteSegmentWhereUniqueInput[]
    update?: RouteSegmentUpdateWithWhereUniqueWithoutLieuInput | RouteSegmentUpdateWithWhereUniqueWithoutLieuInput[]
    updateMany?: RouteSegmentUpdateManyWithWhereWithoutLieuInput | RouteSegmentUpdateManyWithWhereWithoutLieuInput[]
    deleteMany?: RouteSegmentScalarWhereInput | RouteSegmentScalarWhereInput[]
  }

  export type InventaireUncheckedUpdateManyWithoutLieuNestedInput = {
    create?: XOR<InventaireCreateWithoutLieuInput, InventaireUncheckedCreateWithoutLieuInput> | InventaireCreateWithoutLieuInput[] | InventaireUncheckedCreateWithoutLieuInput[]
    connectOrCreate?: InventaireCreateOrConnectWithoutLieuInput | InventaireCreateOrConnectWithoutLieuInput[]
    upsert?: InventaireUpsertWithWhereUniqueWithoutLieuInput | InventaireUpsertWithWhereUniqueWithoutLieuInput[]
    createMany?: InventaireCreateManyLieuInputEnvelope
    set?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    disconnect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    delete?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    connect?: InventaireWhereUniqueInput | InventaireWhereUniqueInput[]
    update?: InventaireUpdateWithWhereUniqueWithoutLieuInput | InventaireUpdateWithWhereUniqueWithoutLieuInput[]
    updateMany?: InventaireUpdateManyWithWhereWithoutLieuInput | InventaireUpdateManyWithWhereWithoutLieuInput[]
    deleteMany?: InventaireScalarWhereInput | InventaireScalarWhereInput[]
  }

  export type RouteCommercialeCreateNestedOneWithoutSegmentsInput = {
    create?: XOR<RouteCommercialeCreateWithoutSegmentsInput, RouteCommercialeUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: RouteCommercialeCreateOrConnectWithoutSegmentsInput
    connect?: RouteCommercialeWhereUniqueInput
  }

  export type LieuCreateNestedOneWithoutSegmentsInput = {
    create?: XOR<LieuCreateWithoutSegmentsInput, LieuUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: LieuCreateOrConnectWithoutSegmentsInput
    connect?: LieuWhereUniqueInput
  }

  export type RouteCommercialeUpdateOneRequiredWithoutSegmentsNestedInput = {
    create?: XOR<RouteCommercialeCreateWithoutSegmentsInput, RouteCommercialeUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: RouteCommercialeCreateOrConnectWithoutSegmentsInput
    upsert?: RouteCommercialeUpsertWithoutSegmentsInput
    connect?: RouteCommercialeWhereUniqueInput
    update?: XOR<XOR<RouteCommercialeUpdateToOneWithWhereWithoutSegmentsInput, RouteCommercialeUpdateWithoutSegmentsInput>, RouteCommercialeUncheckedUpdateWithoutSegmentsInput>
  }

  export type LieuUpdateOneRequiredWithoutSegmentsNestedInput = {
    create?: XOR<LieuCreateWithoutSegmentsInput, LieuUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: LieuCreateOrConnectWithoutSegmentsInput
    upsert?: LieuUpsertWithoutSegmentsInput
    connect?: LieuWhereUniqueInput
    update?: XOR<XOR<LieuUpdateToOneWithWhereWithoutSegmentsInput, LieuUpdateWithoutSegmentsInput>, LieuUncheckedUpdateWithoutSegmentsInput>
  }

  export type MarchandCreateNestedOneWithoutRoutesInput = {
    create?: XOR<MarchandCreateWithoutRoutesInput, MarchandUncheckedCreateWithoutRoutesInput>
    connectOrCreate?: MarchandCreateOrConnectWithoutRoutesInput
    connect?: MarchandWhereUniqueInput
  }

  export type RouteCommercialeCreateNestedOneWithoutMarchandsInput = {
    create?: XOR<RouteCommercialeCreateWithoutMarchandsInput, RouteCommercialeUncheckedCreateWithoutMarchandsInput>
    connectOrCreate?: RouteCommercialeCreateOrConnectWithoutMarchandsInput
    connect?: RouteCommercialeWhereUniqueInput
  }

  export type MarchandUpdateOneRequiredWithoutRoutesNestedInput = {
    create?: XOR<MarchandCreateWithoutRoutesInput, MarchandUncheckedCreateWithoutRoutesInput>
    connectOrCreate?: MarchandCreateOrConnectWithoutRoutesInput
    upsert?: MarchandUpsertWithoutRoutesInput
    connect?: MarchandWhereUniqueInput
    update?: XOR<XOR<MarchandUpdateToOneWithWhereWithoutRoutesInput, MarchandUpdateWithoutRoutesInput>, MarchandUncheckedUpdateWithoutRoutesInput>
  }

  export type RouteCommercialeUpdateOneRequiredWithoutMarchandsNestedInput = {
    create?: XOR<RouteCommercialeCreateWithoutMarchandsInput, RouteCommercialeUncheckedCreateWithoutMarchandsInput>
    connectOrCreate?: RouteCommercialeCreateOrConnectWithoutMarchandsInput
    upsert?: RouteCommercialeUpsertWithoutMarchandsInput
    connect?: RouteCommercialeWhereUniqueInput
    update?: XOR<XOR<RouteCommercialeUpdateToOneWithWhereWithoutMarchandsInput, RouteCommercialeUpdateWithoutMarchandsInput>, RouteCommercialeUncheckedUpdateWithoutMarchandsInput>
  }

  export type HistoireCreateNestedManyWithoutBardeInput = {
    create?: XOR<HistoireCreateWithoutBardeInput, HistoireUncheckedCreateWithoutBardeInput> | HistoireCreateWithoutBardeInput[] | HistoireUncheckedCreateWithoutBardeInput[]
    connectOrCreate?: HistoireCreateOrConnectWithoutBardeInput | HistoireCreateOrConnectWithoutBardeInput[]
    createMany?: HistoireCreateManyBardeInputEnvelope
    connect?: HistoireWhereUniqueInput | HistoireWhereUniqueInput[]
  }

  export type HistoireUncheckedCreateNestedManyWithoutBardeInput = {
    create?: XOR<HistoireCreateWithoutBardeInput, HistoireUncheckedCreateWithoutBardeInput> | HistoireCreateWithoutBardeInput[] | HistoireUncheckedCreateWithoutBardeInput[]
    connectOrCreate?: HistoireCreateOrConnectWithoutBardeInput | HistoireCreateOrConnectWithoutBardeInput[]
    createMany?: HistoireCreateManyBardeInputEnvelope
    connect?: HistoireWhereUniqueInput | HistoireWhereUniqueInput[]
  }

  export type HistoireUpdateManyWithoutBardeNestedInput = {
    create?: XOR<HistoireCreateWithoutBardeInput, HistoireUncheckedCreateWithoutBardeInput> | HistoireCreateWithoutBardeInput[] | HistoireUncheckedCreateWithoutBardeInput[]
    connectOrCreate?: HistoireCreateOrConnectWithoutBardeInput | HistoireCreateOrConnectWithoutBardeInput[]
    upsert?: HistoireUpsertWithWhereUniqueWithoutBardeInput | HistoireUpsertWithWhereUniqueWithoutBardeInput[]
    createMany?: HistoireCreateManyBardeInputEnvelope
    set?: HistoireWhereUniqueInput | HistoireWhereUniqueInput[]
    disconnect?: HistoireWhereUniqueInput | HistoireWhereUniqueInput[]
    delete?: HistoireWhereUniqueInput | HistoireWhereUniqueInput[]
    connect?: HistoireWhereUniqueInput | HistoireWhereUniqueInput[]
    update?: HistoireUpdateWithWhereUniqueWithoutBardeInput | HistoireUpdateWithWhereUniqueWithoutBardeInput[]
    updateMany?: HistoireUpdateManyWithWhereWithoutBardeInput | HistoireUpdateManyWithWhereWithoutBardeInput[]
    deleteMany?: HistoireScalarWhereInput | HistoireScalarWhereInput[]
  }

  export type HistoireUncheckedUpdateManyWithoutBardeNestedInput = {
    create?: XOR<HistoireCreateWithoutBardeInput, HistoireUncheckedCreateWithoutBardeInput> | HistoireCreateWithoutBardeInput[] | HistoireUncheckedCreateWithoutBardeInput[]
    connectOrCreate?: HistoireCreateOrConnectWithoutBardeInput | HistoireCreateOrConnectWithoutBardeInput[]
    upsert?: HistoireUpsertWithWhereUniqueWithoutBardeInput | HistoireUpsertWithWhereUniqueWithoutBardeInput[]
    createMany?: HistoireCreateManyBardeInputEnvelope
    set?: HistoireWhereUniqueInput | HistoireWhereUniqueInput[]
    disconnect?: HistoireWhereUniqueInput | HistoireWhereUniqueInput[]
    delete?: HistoireWhereUniqueInput | HistoireWhereUniqueInput[]
    connect?: HistoireWhereUniqueInput | HistoireWhereUniqueInput[]
    update?: HistoireUpdateWithWhereUniqueWithoutBardeInput | HistoireUpdateWithWhereUniqueWithoutBardeInput[]
    updateMany?: HistoireUpdateManyWithWhereWithoutBardeInput | HistoireUpdateManyWithWhereWithoutBardeInput[]
    deleteMany?: HistoireScalarWhereInput | HistoireScalarWhereInput[]
  }

  export type BardeCreateNestedOneWithoutHistoiresInput = {
    create?: XOR<BardeCreateWithoutHistoiresInput, BardeUncheckedCreateWithoutHistoiresInput>
    connectOrCreate?: BardeCreateOrConnectWithoutHistoiresInput
    connect?: BardeWhereUniqueInput
  }

  export type BardeUpdateOneWithoutHistoiresNestedInput = {
    create?: XOR<BardeCreateWithoutHistoiresInput, BardeUncheckedCreateWithoutHistoiresInput>
    connectOrCreate?: BardeCreateOrConnectWithoutHistoiresInput
    upsert?: BardeUpsertWithoutHistoiresInput
    disconnect?: BardeWhereInput | boolean
    delete?: BardeWhereInput | boolean
    connect?: BardeWhereUniqueInput
    update?: XOR<XOR<BardeUpdateToOneWithWhereWithoutHistoiresInput, BardeUpdateWithoutHistoiresInput>, BardeUncheckedUpdateWithoutHistoiresInput>
  }

  export type LieuCreateNestedOneWithoutInventairesInput = {
    create?: XOR<LieuCreateWithoutInventairesInput, LieuUncheckedCreateWithoutInventairesInput>
    connectOrCreate?: LieuCreateOrConnectWithoutInventairesInput
    connect?: LieuWhereUniqueInput
  }

  export type ArmeeCreateNestedOneWithoutInventairesInput = {
    create?: XOR<ArmeeCreateWithoutInventairesInput, ArmeeUncheckedCreateWithoutInventairesInput>
    connectOrCreate?: ArmeeCreateOrConnectWithoutInventairesInput
    connect?: ArmeeWhereUniqueInput
  }

  export type VillageCreateNestedOneWithoutInventairesInput = {
    create?: XOR<VillageCreateWithoutInventairesInput, VillageUncheckedCreateWithoutInventairesInput>
    connectOrCreate?: VillageCreateOrConnectWithoutInventairesInput
    connect?: VillageWhereUniqueInput
  }

  export type LieuUpdateOneWithoutInventairesNestedInput = {
    create?: XOR<LieuCreateWithoutInventairesInput, LieuUncheckedCreateWithoutInventairesInput>
    connectOrCreate?: LieuCreateOrConnectWithoutInventairesInput
    upsert?: LieuUpsertWithoutInventairesInput
    disconnect?: LieuWhereInput | boolean
    delete?: LieuWhereInput | boolean
    connect?: LieuWhereUniqueInput
    update?: XOR<XOR<LieuUpdateToOneWithWhereWithoutInventairesInput, LieuUpdateWithoutInventairesInput>, LieuUncheckedUpdateWithoutInventairesInput>
  }

  export type ArmeeUpdateOneWithoutInventairesNestedInput = {
    create?: XOR<ArmeeCreateWithoutInventairesInput, ArmeeUncheckedCreateWithoutInventairesInput>
    connectOrCreate?: ArmeeCreateOrConnectWithoutInventairesInput
    upsert?: ArmeeUpsertWithoutInventairesInput
    disconnect?: ArmeeWhereInput | boolean
    delete?: ArmeeWhereInput | boolean
    connect?: ArmeeWhereUniqueInput
    update?: XOR<XOR<ArmeeUpdateToOneWithWhereWithoutInventairesInput, ArmeeUpdateWithoutInventairesInput>, ArmeeUncheckedUpdateWithoutInventairesInput>
  }

  export type VillageUpdateOneWithoutInventairesNestedInput = {
    create?: XOR<VillageCreateWithoutInventairesInput, VillageUncheckedCreateWithoutInventairesInput>
    connectOrCreate?: VillageCreateOrConnectWithoutInventairesInput
    upsert?: VillageUpsertWithoutInventairesInput
    disconnect?: VillageWhereInput | boolean
    delete?: VillageWhereInput | boolean
    connect?: VillageWhereUniqueInput
    update?: XOR<XOR<VillageUpdateToOneWithWhereWithoutInventairesInput, VillageUpdateWithoutInventairesInput>, VillageUncheckedUpdateWithoutInventairesInput>
  }

  export type DomaineCreateNestedOneWithoutRelationsSourceInput = {
    create?: XOR<DomaineCreateWithoutRelationsSourceInput, DomaineUncheckedCreateWithoutRelationsSourceInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutRelationsSourceInput
    connect?: DomaineWhereUniqueInput
  }

  export type DomaineCreateNestedOneWithoutRelationsCibleInput = {
    create?: XOR<DomaineCreateWithoutRelationsCibleInput, DomaineUncheckedCreateWithoutRelationsCibleInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutRelationsCibleInput
    connect?: DomaineWhereUniqueInput
  }

  export type DomaineUpdateOneRequiredWithoutRelationsSourceNestedInput = {
    create?: XOR<DomaineCreateWithoutRelationsSourceInput, DomaineUncheckedCreateWithoutRelationsSourceInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutRelationsSourceInput
    upsert?: DomaineUpsertWithoutRelationsSourceInput
    connect?: DomaineWhereUniqueInput
    update?: XOR<XOR<DomaineUpdateToOneWithWhereWithoutRelationsSourceInput, DomaineUpdateWithoutRelationsSourceInput>, DomaineUncheckedUpdateWithoutRelationsSourceInput>
  }

  export type DomaineUpdateOneRequiredWithoutRelationsCibleNestedInput = {
    create?: XOR<DomaineCreateWithoutRelationsCibleInput, DomaineUncheckedCreateWithoutRelationsCibleInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutRelationsCibleInput
    upsert?: DomaineUpsertWithoutRelationsCibleInput
    connect?: DomaineWhereUniqueInput
    update?: XOR<XOR<DomaineUpdateToOneWithWhereWithoutRelationsCibleInput, DomaineUpdateWithoutRelationsCibleInput>, DomaineUncheckedUpdateWithoutRelationsCibleInput>
  }

  export type LoiTerritoireCreateNestedManyWithoutLoiInput = {
    create?: XOR<LoiTerritoireCreateWithoutLoiInput, LoiTerritoireUncheckedCreateWithoutLoiInput> | LoiTerritoireCreateWithoutLoiInput[] | LoiTerritoireUncheckedCreateWithoutLoiInput[]
    connectOrCreate?: LoiTerritoireCreateOrConnectWithoutLoiInput | LoiTerritoireCreateOrConnectWithoutLoiInput[]
    createMany?: LoiTerritoireCreateManyLoiInputEnvelope
    connect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
  }

  export type LoiTerritoireUncheckedCreateNestedManyWithoutLoiInput = {
    create?: XOR<LoiTerritoireCreateWithoutLoiInput, LoiTerritoireUncheckedCreateWithoutLoiInput> | LoiTerritoireCreateWithoutLoiInput[] | LoiTerritoireUncheckedCreateWithoutLoiInput[]
    connectOrCreate?: LoiTerritoireCreateOrConnectWithoutLoiInput | LoiTerritoireCreateOrConnectWithoutLoiInput[]
    createMany?: LoiTerritoireCreateManyLoiInputEnvelope
    connect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
  }

  export type LoiTerritoireUpdateManyWithoutLoiNestedInput = {
    create?: XOR<LoiTerritoireCreateWithoutLoiInput, LoiTerritoireUncheckedCreateWithoutLoiInput> | LoiTerritoireCreateWithoutLoiInput[] | LoiTerritoireUncheckedCreateWithoutLoiInput[]
    connectOrCreate?: LoiTerritoireCreateOrConnectWithoutLoiInput | LoiTerritoireCreateOrConnectWithoutLoiInput[]
    upsert?: LoiTerritoireUpsertWithWhereUniqueWithoutLoiInput | LoiTerritoireUpsertWithWhereUniqueWithoutLoiInput[]
    createMany?: LoiTerritoireCreateManyLoiInputEnvelope
    set?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    disconnect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    delete?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    connect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    update?: LoiTerritoireUpdateWithWhereUniqueWithoutLoiInput | LoiTerritoireUpdateWithWhereUniqueWithoutLoiInput[]
    updateMany?: LoiTerritoireUpdateManyWithWhereWithoutLoiInput | LoiTerritoireUpdateManyWithWhereWithoutLoiInput[]
    deleteMany?: LoiTerritoireScalarWhereInput | LoiTerritoireScalarWhereInput[]
  }

  export type LoiTerritoireUncheckedUpdateManyWithoutLoiNestedInput = {
    create?: XOR<LoiTerritoireCreateWithoutLoiInput, LoiTerritoireUncheckedCreateWithoutLoiInput> | LoiTerritoireCreateWithoutLoiInput[] | LoiTerritoireUncheckedCreateWithoutLoiInput[]
    connectOrCreate?: LoiTerritoireCreateOrConnectWithoutLoiInput | LoiTerritoireCreateOrConnectWithoutLoiInput[]
    upsert?: LoiTerritoireUpsertWithWhereUniqueWithoutLoiInput | LoiTerritoireUpsertWithWhereUniqueWithoutLoiInput[]
    createMany?: LoiTerritoireCreateManyLoiInputEnvelope
    set?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    disconnect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    delete?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    connect?: LoiTerritoireWhereUniqueInput | LoiTerritoireWhereUniqueInput[]
    update?: LoiTerritoireUpdateWithWhereUniqueWithoutLoiInput | LoiTerritoireUpdateWithWhereUniqueWithoutLoiInput[]
    updateMany?: LoiTerritoireUpdateManyWithWhereWithoutLoiInput | LoiTerritoireUpdateManyWithWhereWithoutLoiInput[]
    deleteMany?: LoiTerritoireScalarWhereInput | LoiTerritoireScalarWhereInput[]
  }

  export type LoiCreateNestedOneWithoutDomainesInput = {
    create?: XOR<LoiCreateWithoutDomainesInput, LoiUncheckedCreateWithoutDomainesInput>
    connectOrCreate?: LoiCreateOrConnectWithoutDomainesInput
    connect?: LoiWhereUniqueInput
  }

  export type DomaineCreateNestedOneWithoutLoisInput = {
    create?: XOR<DomaineCreateWithoutLoisInput, DomaineUncheckedCreateWithoutLoisInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutLoisInput
    connect?: DomaineWhereUniqueInput
  }

  export type LoiUpdateOneRequiredWithoutDomainesNestedInput = {
    create?: XOR<LoiCreateWithoutDomainesInput, LoiUncheckedCreateWithoutDomainesInput>
    connectOrCreate?: LoiCreateOrConnectWithoutDomainesInput
    upsert?: LoiUpsertWithoutDomainesInput
    connect?: LoiWhereUniqueInput
    update?: XOR<XOR<LoiUpdateToOneWithWhereWithoutDomainesInput, LoiUpdateWithoutDomainesInput>, LoiUncheckedUpdateWithoutDomainesInput>
  }

  export type DomaineUpdateOneRequiredWithoutLoisNestedInput = {
    create?: XOR<DomaineCreateWithoutLoisInput, DomaineUncheckedCreateWithoutLoisInput>
    connectOrCreate?: DomaineCreateOrConnectWithoutLoisInput
    upsert?: DomaineUpsertWithoutLoisInput
    connect?: DomaineWhereUniqueInput
    update?: XOR<XOR<DomaineUpdateToOneWithWhereWithoutLoisInput, DomaineUpdateWithoutLoisInput>, DomaineUncheckedUpdateWithoutLoisInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PersonnageCreateWithoutRaceInput = {
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    lignee?: LigneeCreateNestedOneWithoutPersonnagesInput
    roles?: PersonnageRoleCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUncheckedCreateWithoutRaceInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    ligneeId?: number | null
    roles?: PersonnageRoleUncheckedCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceUncheckedCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieUncheckedCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeUncheckedCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementUncheckedCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreUncheckedCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageCreateOrConnectWithoutRaceInput = {
    where: PersonnageWhereUniqueInput
    create: XOR<PersonnageCreateWithoutRaceInput, PersonnageUncheckedCreateWithoutRaceInput>
  }

  export type PersonnageCreateManyRaceInputEnvelope = {
    data: PersonnageCreateManyRaceInput | PersonnageCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type CompetenceCreateWithoutExigenceRaceInput = {
    nom: string
    exigenceFormation?: string | null
    personnages?: PersonnageCompetenceCreateNestedManyWithoutCompetenceInput
  }

  export type CompetenceUncheckedCreateWithoutExigenceRaceInput = {
    id?: number
    nom: string
    exigenceFormation?: string | null
    personnages?: PersonnageCompetenceUncheckedCreateNestedManyWithoutCompetenceInput
  }

  export type CompetenceCreateOrConnectWithoutExigenceRaceInput = {
    where: CompetenceWhereUniqueInput
    create: XOR<CompetenceCreateWithoutExigenceRaceInput, CompetenceUncheckedCreateWithoutExigenceRaceInput>
  }

  export type CompetenceCreateManyExigenceRaceInputEnvelope = {
    data: CompetenceCreateManyExigenceRaceInput | CompetenceCreateManyExigenceRaceInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageUpsertWithWhereUniqueWithoutRaceInput = {
    where: PersonnageWhereUniqueInput
    update: XOR<PersonnageUpdateWithoutRaceInput, PersonnageUncheckedUpdateWithoutRaceInput>
    create: XOR<PersonnageCreateWithoutRaceInput, PersonnageUncheckedCreateWithoutRaceInput>
  }

  export type PersonnageUpdateWithWhereUniqueWithoutRaceInput = {
    where: PersonnageWhereUniqueInput
    data: XOR<PersonnageUpdateWithoutRaceInput, PersonnageUncheckedUpdateWithoutRaceInput>
  }

  export type PersonnageUpdateManyWithWhereWithoutRaceInput = {
    where: PersonnageScalarWhereInput
    data: XOR<PersonnageUpdateManyMutationInput, PersonnageUncheckedUpdateManyWithoutRaceInput>
  }

  export type PersonnageScalarWhereInput = {
    AND?: PersonnageScalarWhereInput | PersonnageScalarWhereInput[]
    OR?: PersonnageScalarWhereInput[]
    NOT?: PersonnageScalarWhereInput | PersonnageScalarWhereInput[]
    id?: IntFilter<"Personnage"> | number
    nom?: StringFilter<"Personnage"> | string
    dateNaissance?: DateTimeNullableFilter<"Personnage"> | Date | string | null
    statutVie?: StringNullableFilter<"Personnage"> | string | null
    dateDeces?: DateTimeNullableFilter<"Personnage"> | Date | string | null
    causeDeces?: StringNullableFilter<"Personnage"> | string | null
    raceId?: IntNullableFilter<"Personnage"> | number | null
    ligneeId?: IntNullableFilter<"Personnage"> | number | null
  }

  export type CompetenceUpsertWithWhereUniqueWithoutExigenceRaceInput = {
    where: CompetenceWhereUniqueInput
    update: XOR<CompetenceUpdateWithoutExigenceRaceInput, CompetenceUncheckedUpdateWithoutExigenceRaceInput>
    create: XOR<CompetenceCreateWithoutExigenceRaceInput, CompetenceUncheckedCreateWithoutExigenceRaceInput>
  }

  export type CompetenceUpdateWithWhereUniqueWithoutExigenceRaceInput = {
    where: CompetenceWhereUniqueInput
    data: XOR<CompetenceUpdateWithoutExigenceRaceInput, CompetenceUncheckedUpdateWithoutExigenceRaceInput>
  }

  export type CompetenceUpdateManyWithWhereWithoutExigenceRaceInput = {
    where: CompetenceScalarWhereInput
    data: XOR<CompetenceUpdateManyMutationInput, CompetenceUncheckedUpdateManyWithoutExigenceRaceInput>
  }

  export type CompetenceScalarWhereInput = {
    AND?: CompetenceScalarWhereInput | CompetenceScalarWhereInput[]
    OR?: CompetenceScalarWhereInput[]
    NOT?: CompetenceScalarWhereInput | CompetenceScalarWhereInput[]
    id?: IntFilter<"Competence"> | number
    nom?: StringFilter<"Competence"> | string
    exigenceFormation?: StringNullableFilter<"Competence"> | string | null
    exigenceRaceId?: IntNullableFilter<"Competence"> | number | null
  }

  export type PersonnageRoleCreateWithoutRoleInput = {
    personnage: PersonnageCreateNestedOneWithoutRolesInput
  }

  export type PersonnageRoleUncheckedCreateWithoutRoleInput = {
    personnageId: number
  }

  export type PersonnageRoleCreateOrConnectWithoutRoleInput = {
    where: PersonnageRoleWhereUniqueInput
    create: XOR<PersonnageRoleCreateWithoutRoleInput, PersonnageRoleUncheckedCreateWithoutRoleInput>
  }

  export type PersonnageRoleCreateManyRoleInputEnvelope = {
    data: PersonnageRoleCreateManyRoleInput | PersonnageRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: PersonnageRoleWhereUniqueInput
    update: XOR<PersonnageRoleUpdateWithoutRoleInput, PersonnageRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<PersonnageRoleCreateWithoutRoleInput, PersonnageRoleUncheckedCreateWithoutRoleInput>
  }

  export type PersonnageRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: PersonnageRoleWhereUniqueInput
    data: XOR<PersonnageRoleUpdateWithoutRoleInput, PersonnageRoleUncheckedUpdateWithoutRoleInput>
  }

  export type PersonnageRoleUpdateManyWithWhereWithoutRoleInput = {
    where: PersonnageRoleScalarWhereInput
    data: XOR<PersonnageRoleUpdateManyMutationInput, PersonnageRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type PersonnageRoleScalarWhereInput = {
    AND?: PersonnageRoleScalarWhereInput | PersonnageRoleScalarWhereInput[]
    OR?: PersonnageRoleScalarWhereInput[]
    NOT?: PersonnageRoleScalarWhereInput | PersonnageRoleScalarWhereInput[]
    personnageId?: IntFilter<"PersonnageRole"> | number
    roleId?: IntFilter<"PersonnageRole"> | number
  }

  export type PersonnageCreateWithoutLigneeInput = {
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    race?: RaceCreateNestedOneWithoutPersonnagesInput
    roles?: PersonnageRoleCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUncheckedCreateWithoutLigneeInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
    roles?: PersonnageRoleUncheckedCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceUncheckedCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieUncheckedCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeUncheckedCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementUncheckedCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreUncheckedCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageCreateOrConnectWithoutLigneeInput = {
    where: PersonnageWhereUniqueInput
    create: XOR<PersonnageCreateWithoutLigneeInput, PersonnageUncheckedCreateWithoutLigneeInput>
  }

  export type PersonnageCreateManyLigneeInputEnvelope = {
    data: PersonnageCreateManyLigneeInput | PersonnageCreateManyLigneeInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageTitreCreateWithoutLigneeInput = {
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnage: PersonnageCreateNestedOneWithoutTitresInput
    titre: TitreCreateNestedOneWithoutAttributionsInput
    domaine?: DomaineCreateNestedOneWithoutTitresInput
  }

  export type PersonnageTitreUncheckedCreateWithoutLigneeInput = {
    id?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnageId: number
    titreId: number
    domaineId?: number | null
  }

  export type PersonnageTitreCreateOrConnectWithoutLigneeInput = {
    where: PersonnageTitreWhereUniqueInput
    create: XOR<PersonnageTitreCreateWithoutLigneeInput, PersonnageTitreUncheckedCreateWithoutLigneeInput>
  }

  export type PersonnageTitreCreateManyLigneeInputEnvelope = {
    data: PersonnageTitreCreateManyLigneeInput | PersonnageTitreCreateManyLigneeInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageUpsertWithWhereUniqueWithoutLigneeInput = {
    where: PersonnageWhereUniqueInput
    update: XOR<PersonnageUpdateWithoutLigneeInput, PersonnageUncheckedUpdateWithoutLigneeInput>
    create: XOR<PersonnageCreateWithoutLigneeInput, PersonnageUncheckedCreateWithoutLigneeInput>
  }

  export type PersonnageUpdateWithWhereUniqueWithoutLigneeInput = {
    where: PersonnageWhereUniqueInput
    data: XOR<PersonnageUpdateWithoutLigneeInput, PersonnageUncheckedUpdateWithoutLigneeInput>
  }

  export type PersonnageUpdateManyWithWhereWithoutLigneeInput = {
    where: PersonnageScalarWhereInput
    data: XOR<PersonnageUpdateManyMutationInput, PersonnageUncheckedUpdateManyWithoutLigneeInput>
  }

  export type PersonnageTitreUpsertWithWhereUniqueWithoutLigneeInput = {
    where: PersonnageTitreWhereUniqueInput
    update: XOR<PersonnageTitreUpdateWithoutLigneeInput, PersonnageTitreUncheckedUpdateWithoutLigneeInput>
    create: XOR<PersonnageTitreCreateWithoutLigneeInput, PersonnageTitreUncheckedCreateWithoutLigneeInput>
  }

  export type PersonnageTitreUpdateWithWhereUniqueWithoutLigneeInput = {
    where: PersonnageTitreWhereUniqueInput
    data: XOR<PersonnageTitreUpdateWithoutLigneeInput, PersonnageTitreUncheckedUpdateWithoutLigneeInput>
  }

  export type PersonnageTitreUpdateManyWithWhereWithoutLigneeInput = {
    where: PersonnageTitreScalarWhereInput
    data: XOR<PersonnageTitreUpdateManyMutationInput, PersonnageTitreUncheckedUpdateManyWithoutLigneeInput>
  }

  export type PersonnageTitreScalarWhereInput = {
    AND?: PersonnageTitreScalarWhereInput | PersonnageTitreScalarWhereInput[]
    OR?: PersonnageTitreScalarWhereInput[]
    NOT?: PersonnageTitreScalarWhereInput | PersonnageTitreScalarWhereInput[]
    id?: IntFilter<"PersonnageTitre"> | number
    dateDebut?: DateTimeNullableFilter<"PersonnageTitre"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"PersonnageTitre"> | Date | string | null
    estActif?: BoolFilter<"PersonnageTitre"> | boolean
    personnageId?: IntFilter<"PersonnageTitre"> | number
    titreId?: IntFilter<"PersonnageTitre"> | number
    domaineId?: IntNullableFilter<"PersonnageTitre"> | number | null
    ligneeId?: IntNullableFilter<"PersonnageTitre"> | number | null
  }

  export type RaceCreateWithoutPersonnagesInput = {
    libelle: string
    competences?: CompetenceCreateNestedManyWithoutExigenceRaceInput
  }

  export type RaceUncheckedCreateWithoutPersonnagesInput = {
    id?: number
    libelle: string
    competences?: CompetenceUncheckedCreateNestedManyWithoutExigenceRaceInput
  }

  export type RaceCreateOrConnectWithoutPersonnagesInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutPersonnagesInput, RaceUncheckedCreateWithoutPersonnagesInput>
  }

  export type LigneeCreateWithoutPersonnagesInput = {
    nom: string
    titres?: PersonnageTitreCreateNestedManyWithoutLigneeInput
  }

  export type LigneeUncheckedCreateWithoutPersonnagesInput = {
    id?: number
    nom: string
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutLigneeInput
  }

  export type LigneeCreateOrConnectWithoutPersonnagesInput = {
    where: LigneeWhereUniqueInput
    create: XOR<LigneeCreateWithoutPersonnagesInput, LigneeUncheckedCreateWithoutPersonnagesInput>
  }

  export type PersonnageRoleCreateWithoutPersonnageInput = {
    role: RoleCreateNestedOneWithoutPersonnagesInput
  }

  export type PersonnageRoleUncheckedCreateWithoutPersonnageInput = {
    roleId: number
  }

  export type PersonnageRoleCreateOrConnectWithoutPersonnageInput = {
    where: PersonnageRoleWhereUniqueInput
    create: XOR<PersonnageRoleCreateWithoutPersonnageInput, PersonnageRoleUncheckedCreateWithoutPersonnageInput>
  }

  export type PersonnageRoleCreateManyPersonnageInputEnvelope = {
    data: PersonnageRoleCreateManyPersonnageInput | PersonnageRoleCreateManyPersonnageInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageCompetenceCreateWithoutPersonnageInput = {
    niveau: number
    competence: CompetenceCreateNestedOneWithoutPersonnagesInput
  }

  export type PersonnageCompetenceUncheckedCreateWithoutPersonnageInput = {
    competenceId: number
    niveau: number
  }

  export type PersonnageCompetenceCreateOrConnectWithoutPersonnageInput = {
    where: PersonnageCompetenceWhereUniqueInput
    create: XOR<PersonnageCompetenceCreateWithoutPersonnageInput, PersonnageCompetenceUncheckedCreateWithoutPersonnageInput>
  }

  export type PersonnageCompetenceCreateManyPersonnageInputEnvelope = {
    data: PersonnageCompetenceCreateManyPersonnageInput | PersonnageCompetenceCreateManyPersonnageInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageTitreCreateWithoutPersonnageInput = {
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    titre: TitreCreateNestedOneWithoutAttributionsInput
    domaine?: DomaineCreateNestedOneWithoutTitresInput
    lignee?: LigneeCreateNestedOneWithoutTitresInput
  }

  export type PersonnageTitreUncheckedCreateWithoutPersonnageInput = {
    id?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    titreId: number
    domaineId?: number | null
    ligneeId?: number | null
  }

  export type PersonnageTitreCreateOrConnectWithoutPersonnageInput = {
    where: PersonnageTitreWhereUniqueInput
    create: XOR<PersonnageTitreCreateWithoutPersonnageInput, PersonnageTitreUncheckedCreateWithoutPersonnageInput>
  }

  export type PersonnageTitreCreateManyPersonnageInputEnvelope = {
    data: PersonnageTitreCreateManyPersonnageInput | PersonnageTitreCreateManyPersonnageInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageMaladieCreateWithoutPersonnageInput = {
    dateDebut: Date | string
    dateFin?: Date | string | null
    issue?: string | null
    maladie: MaladieCreateNestedOneWithoutCasInput
  }

  export type PersonnageMaladieUncheckedCreateWithoutPersonnageInput = {
    maladieId: number
    dateDebut: Date | string
    dateFin?: Date | string | null
    issue?: string | null
  }

  export type PersonnageMaladieCreateOrConnectWithoutPersonnageInput = {
    where: PersonnageMaladieWhereUniqueInput
    create: XOR<PersonnageMaladieCreateWithoutPersonnageInput, PersonnageMaladieUncheckedCreateWithoutPersonnageInput>
  }

  export type PersonnageMaladieCreateManyPersonnageInputEnvelope = {
    data: PersonnageMaladieCreateManyPersonnageInput | PersonnageMaladieCreateManyPersonnageInput[]
    skipDuplicates?: boolean
  }

  export type ArmeeCreateWithoutCommandantInput = {
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    domaine?: DomaineCreateNestedOneWithoutArmeesInput
    batailles?: ArmeeBatailleCreateNestedManyWithoutArmeeInput
    inventaires?: InventaireCreateNestedManyWithoutArmeeInput
  }

  export type ArmeeUncheckedCreateWithoutCommandantInput = {
    id?: number
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    domaineId?: number | null
    batailles?: ArmeeBatailleUncheckedCreateNestedManyWithoutArmeeInput
    inventaires?: InventaireUncheckedCreateNestedManyWithoutArmeeInput
  }

  export type ArmeeCreateOrConnectWithoutCommandantInput = {
    where: ArmeeWhereUniqueInput
    create: XOR<ArmeeCreateWithoutCommandantInput, ArmeeUncheckedCreateWithoutCommandantInput>
  }

  export type ArmeeCreateManyCommandantInputEnvelope = {
    data: ArmeeCreateManyCommandantInput | ArmeeCreateManyCommandantInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageEquipementCreateWithoutPersonnageInput = {
    dateAcquisition?: Date | string | null
    source?: string | null
    equipement: EquipementCreateNestedOneWithoutPossesseursInput
  }

  export type PersonnageEquipementUncheckedCreateWithoutPersonnageInput = {
    equipementId: number
    dateAcquisition?: Date | string | null
    source?: string | null
  }

  export type PersonnageEquipementCreateOrConnectWithoutPersonnageInput = {
    where: PersonnageEquipementWhereUniqueInput
    create: XOR<PersonnageEquipementCreateWithoutPersonnageInput, PersonnageEquipementUncheckedCreateWithoutPersonnageInput>
  }

  export type PersonnageEquipementCreateManyPersonnageInputEnvelope = {
    data: PersonnageEquipementCreateManyPersonnageInput | PersonnageEquipementCreateManyPersonnageInput[]
    skipDuplicates?: boolean
  }

  export type GuildeMembreCreateWithoutPersonnageInput = {
    dateEntree?: Date | string | null
    dateSortie?: Date | string | null
    guilde: GuildeCreateNestedOneWithoutMembresInput
  }

  export type GuildeMembreUncheckedCreateWithoutPersonnageInput = {
    guildeId: number
    dateEntree?: Date | string | null
    dateSortie?: Date | string | null
  }

  export type GuildeMembreCreateOrConnectWithoutPersonnageInput = {
    where: GuildeMembreWhereUniqueInput
    create: XOR<GuildeMembreCreateWithoutPersonnageInput, GuildeMembreUncheckedCreateWithoutPersonnageInput>
  }

  export type GuildeMembreCreateManyPersonnageInputEnvelope = {
    data: GuildeMembreCreateManyPersonnageInput | GuildeMembreCreateManyPersonnageInput[]
    skipDuplicates?: boolean
  }

  export type RaceUpsertWithoutPersonnagesInput = {
    update: XOR<RaceUpdateWithoutPersonnagesInput, RaceUncheckedUpdateWithoutPersonnagesInput>
    create: XOR<RaceCreateWithoutPersonnagesInput, RaceUncheckedCreateWithoutPersonnagesInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutPersonnagesInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutPersonnagesInput, RaceUncheckedUpdateWithoutPersonnagesInput>
  }

  export type RaceUpdateWithoutPersonnagesInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    competences?: CompetenceUpdateManyWithoutExigenceRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutPersonnagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    competences?: CompetenceUncheckedUpdateManyWithoutExigenceRaceNestedInput
  }

  export type LigneeUpsertWithoutPersonnagesInput = {
    update: XOR<LigneeUpdateWithoutPersonnagesInput, LigneeUncheckedUpdateWithoutPersonnagesInput>
    create: XOR<LigneeCreateWithoutPersonnagesInput, LigneeUncheckedCreateWithoutPersonnagesInput>
    where?: LigneeWhereInput
  }

  export type LigneeUpdateToOneWithWhereWithoutPersonnagesInput = {
    where?: LigneeWhereInput
    data: XOR<LigneeUpdateWithoutPersonnagesInput, LigneeUncheckedUpdateWithoutPersonnagesInput>
  }

  export type LigneeUpdateWithoutPersonnagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    titres?: PersonnageTitreUpdateManyWithoutLigneeNestedInput
  }

  export type LigneeUncheckedUpdateWithoutPersonnagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    titres?: PersonnageTitreUncheckedUpdateManyWithoutLigneeNestedInput
  }

  export type PersonnageRoleUpsertWithWhereUniqueWithoutPersonnageInput = {
    where: PersonnageRoleWhereUniqueInput
    update: XOR<PersonnageRoleUpdateWithoutPersonnageInput, PersonnageRoleUncheckedUpdateWithoutPersonnageInput>
    create: XOR<PersonnageRoleCreateWithoutPersonnageInput, PersonnageRoleUncheckedCreateWithoutPersonnageInput>
  }

  export type PersonnageRoleUpdateWithWhereUniqueWithoutPersonnageInput = {
    where: PersonnageRoleWhereUniqueInput
    data: XOR<PersonnageRoleUpdateWithoutPersonnageInput, PersonnageRoleUncheckedUpdateWithoutPersonnageInput>
  }

  export type PersonnageRoleUpdateManyWithWhereWithoutPersonnageInput = {
    where: PersonnageRoleScalarWhereInput
    data: XOR<PersonnageRoleUpdateManyMutationInput, PersonnageRoleUncheckedUpdateManyWithoutPersonnageInput>
  }

  export type PersonnageCompetenceUpsertWithWhereUniqueWithoutPersonnageInput = {
    where: PersonnageCompetenceWhereUniqueInput
    update: XOR<PersonnageCompetenceUpdateWithoutPersonnageInput, PersonnageCompetenceUncheckedUpdateWithoutPersonnageInput>
    create: XOR<PersonnageCompetenceCreateWithoutPersonnageInput, PersonnageCompetenceUncheckedCreateWithoutPersonnageInput>
  }

  export type PersonnageCompetenceUpdateWithWhereUniqueWithoutPersonnageInput = {
    where: PersonnageCompetenceWhereUniqueInput
    data: XOR<PersonnageCompetenceUpdateWithoutPersonnageInput, PersonnageCompetenceUncheckedUpdateWithoutPersonnageInput>
  }

  export type PersonnageCompetenceUpdateManyWithWhereWithoutPersonnageInput = {
    where: PersonnageCompetenceScalarWhereInput
    data: XOR<PersonnageCompetenceUpdateManyMutationInput, PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageInput>
  }

  export type PersonnageCompetenceScalarWhereInput = {
    AND?: PersonnageCompetenceScalarWhereInput | PersonnageCompetenceScalarWhereInput[]
    OR?: PersonnageCompetenceScalarWhereInput[]
    NOT?: PersonnageCompetenceScalarWhereInput | PersonnageCompetenceScalarWhereInput[]
    personnageId?: IntFilter<"PersonnageCompetence"> | number
    competenceId?: IntFilter<"PersonnageCompetence"> | number
    niveau?: IntFilter<"PersonnageCompetence"> | number
  }

  export type PersonnageTitreUpsertWithWhereUniqueWithoutPersonnageInput = {
    where: PersonnageTitreWhereUniqueInput
    update: XOR<PersonnageTitreUpdateWithoutPersonnageInput, PersonnageTitreUncheckedUpdateWithoutPersonnageInput>
    create: XOR<PersonnageTitreCreateWithoutPersonnageInput, PersonnageTitreUncheckedCreateWithoutPersonnageInput>
  }

  export type PersonnageTitreUpdateWithWhereUniqueWithoutPersonnageInput = {
    where: PersonnageTitreWhereUniqueInput
    data: XOR<PersonnageTitreUpdateWithoutPersonnageInput, PersonnageTitreUncheckedUpdateWithoutPersonnageInput>
  }

  export type PersonnageTitreUpdateManyWithWhereWithoutPersonnageInput = {
    where: PersonnageTitreScalarWhereInput
    data: XOR<PersonnageTitreUpdateManyMutationInput, PersonnageTitreUncheckedUpdateManyWithoutPersonnageInput>
  }

  export type PersonnageMaladieUpsertWithWhereUniqueWithoutPersonnageInput = {
    where: PersonnageMaladieWhereUniqueInput
    update: XOR<PersonnageMaladieUpdateWithoutPersonnageInput, PersonnageMaladieUncheckedUpdateWithoutPersonnageInput>
    create: XOR<PersonnageMaladieCreateWithoutPersonnageInput, PersonnageMaladieUncheckedCreateWithoutPersonnageInput>
  }

  export type PersonnageMaladieUpdateWithWhereUniqueWithoutPersonnageInput = {
    where: PersonnageMaladieWhereUniqueInput
    data: XOR<PersonnageMaladieUpdateWithoutPersonnageInput, PersonnageMaladieUncheckedUpdateWithoutPersonnageInput>
  }

  export type PersonnageMaladieUpdateManyWithWhereWithoutPersonnageInput = {
    where: PersonnageMaladieScalarWhereInput
    data: XOR<PersonnageMaladieUpdateManyMutationInput, PersonnageMaladieUncheckedUpdateManyWithoutPersonnageInput>
  }

  export type PersonnageMaladieScalarWhereInput = {
    AND?: PersonnageMaladieScalarWhereInput | PersonnageMaladieScalarWhereInput[]
    OR?: PersonnageMaladieScalarWhereInput[]
    NOT?: PersonnageMaladieScalarWhereInput | PersonnageMaladieScalarWhereInput[]
    personnageId?: IntFilter<"PersonnageMaladie"> | number
    maladieId?: IntFilter<"PersonnageMaladie"> | number
    dateDebut?: DateTimeFilter<"PersonnageMaladie"> | Date | string
    dateFin?: DateTimeNullableFilter<"PersonnageMaladie"> | Date | string | null
    issue?: StringNullableFilter<"PersonnageMaladie"> | string | null
  }

  export type ArmeeUpsertWithWhereUniqueWithoutCommandantInput = {
    where: ArmeeWhereUniqueInput
    update: XOR<ArmeeUpdateWithoutCommandantInput, ArmeeUncheckedUpdateWithoutCommandantInput>
    create: XOR<ArmeeCreateWithoutCommandantInput, ArmeeUncheckedCreateWithoutCommandantInput>
  }

  export type ArmeeUpdateWithWhereUniqueWithoutCommandantInput = {
    where: ArmeeWhereUniqueInput
    data: XOR<ArmeeUpdateWithoutCommandantInput, ArmeeUncheckedUpdateWithoutCommandantInput>
  }

  export type ArmeeUpdateManyWithWhereWithoutCommandantInput = {
    where: ArmeeScalarWhereInput
    data: XOR<ArmeeUpdateManyMutationInput, ArmeeUncheckedUpdateManyWithoutCommandantInput>
  }

  export type ArmeeScalarWhereInput = {
    AND?: ArmeeScalarWhereInput | ArmeeScalarWhereInput[]
    OR?: ArmeeScalarWhereInput[]
    NOT?: ArmeeScalarWhereInput | ArmeeScalarWhereInput[]
    id?: IntFilter<"Armee"> | number
    nom?: StringNullableFilter<"Armee"> | string | null
    effectif?: IntNullableFilter<"Armee"> | number | null
    composition?: StringNullableFilter<"Armee"> | string | null
    moral?: StringNullableFilter<"Armee"> | string | null
    etatApprovisionnement?: StringNullableFilter<"Armee"> | string | null
    domaineId?: IntNullableFilter<"Armee"> | number | null
    commandantId?: IntNullableFilter<"Armee"> | number | null
  }

  export type PersonnageEquipementUpsertWithWhereUniqueWithoutPersonnageInput = {
    where: PersonnageEquipementWhereUniqueInput
    update: XOR<PersonnageEquipementUpdateWithoutPersonnageInput, PersonnageEquipementUncheckedUpdateWithoutPersonnageInput>
    create: XOR<PersonnageEquipementCreateWithoutPersonnageInput, PersonnageEquipementUncheckedCreateWithoutPersonnageInput>
  }

  export type PersonnageEquipementUpdateWithWhereUniqueWithoutPersonnageInput = {
    where: PersonnageEquipementWhereUniqueInput
    data: XOR<PersonnageEquipementUpdateWithoutPersonnageInput, PersonnageEquipementUncheckedUpdateWithoutPersonnageInput>
  }

  export type PersonnageEquipementUpdateManyWithWhereWithoutPersonnageInput = {
    where: PersonnageEquipementScalarWhereInput
    data: XOR<PersonnageEquipementUpdateManyMutationInput, PersonnageEquipementUncheckedUpdateManyWithoutPersonnageInput>
  }

  export type PersonnageEquipementScalarWhereInput = {
    AND?: PersonnageEquipementScalarWhereInput | PersonnageEquipementScalarWhereInput[]
    OR?: PersonnageEquipementScalarWhereInput[]
    NOT?: PersonnageEquipementScalarWhereInput | PersonnageEquipementScalarWhereInput[]
    personnageId?: IntFilter<"PersonnageEquipement"> | number
    equipementId?: IntFilter<"PersonnageEquipement"> | number
    dateAcquisition?: DateTimeNullableFilter<"PersonnageEquipement"> | Date | string | null
    source?: StringNullableFilter<"PersonnageEquipement"> | string | null
  }

  export type GuildeMembreUpsertWithWhereUniqueWithoutPersonnageInput = {
    where: GuildeMembreWhereUniqueInput
    update: XOR<GuildeMembreUpdateWithoutPersonnageInput, GuildeMembreUncheckedUpdateWithoutPersonnageInput>
    create: XOR<GuildeMembreCreateWithoutPersonnageInput, GuildeMembreUncheckedCreateWithoutPersonnageInput>
  }

  export type GuildeMembreUpdateWithWhereUniqueWithoutPersonnageInput = {
    where: GuildeMembreWhereUniqueInput
    data: XOR<GuildeMembreUpdateWithoutPersonnageInput, GuildeMembreUncheckedUpdateWithoutPersonnageInput>
  }

  export type GuildeMembreUpdateManyWithWhereWithoutPersonnageInput = {
    where: GuildeMembreScalarWhereInput
    data: XOR<GuildeMembreUpdateManyMutationInput, GuildeMembreUncheckedUpdateManyWithoutPersonnageInput>
  }

  export type GuildeMembreScalarWhereInput = {
    AND?: GuildeMembreScalarWhereInput | GuildeMembreScalarWhereInput[]
    OR?: GuildeMembreScalarWhereInput[]
    NOT?: GuildeMembreScalarWhereInput | GuildeMembreScalarWhereInput[]
    personnageId?: IntFilter<"GuildeMembre"> | number
    guildeId?: IntFilter<"GuildeMembre"> | number
    dateEntree?: DateTimeNullableFilter<"GuildeMembre"> | Date | string | null
    dateSortie?: DateTimeNullableFilter<"GuildeMembre"> | Date | string | null
  }

  export type PersonnageCreateWithoutRolesInput = {
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    race?: RaceCreateNestedOneWithoutPersonnagesInput
    lignee?: LigneeCreateNestedOneWithoutPersonnagesInput
    competences?: PersonnageCompetenceCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUncheckedCreateWithoutRolesInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
    ligneeId?: number | null
    competences?: PersonnageCompetenceUncheckedCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieUncheckedCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeUncheckedCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementUncheckedCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreUncheckedCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageCreateOrConnectWithoutRolesInput = {
    where: PersonnageWhereUniqueInput
    create: XOR<PersonnageCreateWithoutRolesInput, PersonnageUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutPersonnagesInput = {
    libelle: string
  }

  export type RoleUncheckedCreateWithoutPersonnagesInput = {
    id?: number
    libelle: string
  }

  export type RoleCreateOrConnectWithoutPersonnagesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPersonnagesInput, RoleUncheckedCreateWithoutPersonnagesInput>
  }

  export type PersonnageUpsertWithoutRolesInput = {
    update: XOR<PersonnageUpdateWithoutRolesInput, PersonnageUncheckedUpdateWithoutRolesInput>
    create: XOR<PersonnageCreateWithoutRolesInput, PersonnageUncheckedCreateWithoutRolesInput>
    where?: PersonnageWhereInput
  }

  export type PersonnageUpdateToOneWithWhereWithoutRolesInput = {
    where?: PersonnageWhereInput
    data: XOR<PersonnageUpdateWithoutRolesInput, PersonnageUncheckedUpdateWithoutRolesInput>
  }

  export type PersonnageUpdateWithoutRolesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneWithoutPersonnagesNestedInput
    lignee?: LigneeUpdateOneWithoutPersonnagesNestedInput
    competences?: PersonnageCompetenceUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
    competences?: PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUncheckedUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUncheckedUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUncheckedUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUncheckedUpdateManyWithoutPersonnageNestedInput
  }

  export type RoleUpsertWithoutPersonnagesInput = {
    update: XOR<RoleUpdateWithoutPersonnagesInput, RoleUncheckedUpdateWithoutPersonnagesInput>
    create: XOR<RoleCreateWithoutPersonnagesInput, RoleUncheckedCreateWithoutPersonnagesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPersonnagesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPersonnagesInput, RoleUncheckedUpdateWithoutPersonnagesInput>
  }

  export type RoleUpdateWithoutPersonnagesInput = {
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutPersonnagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type RaceCreateWithoutCompetencesInput = {
    libelle: string
    personnages?: PersonnageCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutCompetencesInput = {
    id?: number
    libelle: string
    personnages?: PersonnageUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutCompetencesInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutCompetencesInput, RaceUncheckedCreateWithoutCompetencesInput>
  }

  export type PersonnageCompetenceCreateWithoutCompetenceInput = {
    niveau: number
    personnage: PersonnageCreateNestedOneWithoutCompetencesInput
  }

  export type PersonnageCompetenceUncheckedCreateWithoutCompetenceInput = {
    personnageId: number
    niveau: number
  }

  export type PersonnageCompetenceCreateOrConnectWithoutCompetenceInput = {
    where: PersonnageCompetenceWhereUniqueInput
    create: XOR<PersonnageCompetenceCreateWithoutCompetenceInput, PersonnageCompetenceUncheckedCreateWithoutCompetenceInput>
  }

  export type PersonnageCompetenceCreateManyCompetenceInputEnvelope = {
    data: PersonnageCompetenceCreateManyCompetenceInput | PersonnageCompetenceCreateManyCompetenceInput[]
    skipDuplicates?: boolean
  }

  export type RaceUpsertWithoutCompetencesInput = {
    update: XOR<RaceUpdateWithoutCompetencesInput, RaceUncheckedUpdateWithoutCompetencesInput>
    create: XOR<RaceCreateWithoutCompetencesInput, RaceUncheckedCreateWithoutCompetencesInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutCompetencesInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutCompetencesInput, RaceUncheckedUpdateWithoutCompetencesInput>
  }

  export type RaceUpdateWithoutCompetencesInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    personnages?: PersonnageUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutCompetencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    personnages?: PersonnageUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type PersonnageCompetenceUpsertWithWhereUniqueWithoutCompetenceInput = {
    where: PersonnageCompetenceWhereUniqueInput
    update: XOR<PersonnageCompetenceUpdateWithoutCompetenceInput, PersonnageCompetenceUncheckedUpdateWithoutCompetenceInput>
    create: XOR<PersonnageCompetenceCreateWithoutCompetenceInput, PersonnageCompetenceUncheckedCreateWithoutCompetenceInput>
  }

  export type PersonnageCompetenceUpdateWithWhereUniqueWithoutCompetenceInput = {
    where: PersonnageCompetenceWhereUniqueInput
    data: XOR<PersonnageCompetenceUpdateWithoutCompetenceInput, PersonnageCompetenceUncheckedUpdateWithoutCompetenceInput>
  }

  export type PersonnageCompetenceUpdateManyWithWhereWithoutCompetenceInput = {
    where: PersonnageCompetenceScalarWhereInput
    data: XOR<PersonnageCompetenceUpdateManyMutationInput, PersonnageCompetenceUncheckedUpdateManyWithoutCompetenceInput>
  }

  export type PersonnageCreateWithoutCompetencesInput = {
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    race?: RaceCreateNestedOneWithoutPersonnagesInput
    lignee?: LigneeCreateNestedOneWithoutPersonnagesInput
    roles?: PersonnageRoleCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUncheckedCreateWithoutCompetencesInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
    ligneeId?: number | null
    roles?: PersonnageRoleUncheckedCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieUncheckedCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeUncheckedCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementUncheckedCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreUncheckedCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageCreateOrConnectWithoutCompetencesInput = {
    where: PersonnageWhereUniqueInput
    create: XOR<PersonnageCreateWithoutCompetencesInput, PersonnageUncheckedCreateWithoutCompetencesInput>
  }

  export type CompetenceCreateWithoutPersonnagesInput = {
    nom: string
    exigenceFormation?: string | null
    exigenceRace?: RaceCreateNestedOneWithoutCompetencesInput
  }

  export type CompetenceUncheckedCreateWithoutPersonnagesInput = {
    id?: number
    nom: string
    exigenceFormation?: string | null
    exigenceRaceId?: number | null
  }

  export type CompetenceCreateOrConnectWithoutPersonnagesInput = {
    where: CompetenceWhereUniqueInput
    create: XOR<CompetenceCreateWithoutPersonnagesInput, CompetenceUncheckedCreateWithoutPersonnagesInput>
  }

  export type PersonnageUpsertWithoutCompetencesInput = {
    update: XOR<PersonnageUpdateWithoutCompetencesInput, PersonnageUncheckedUpdateWithoutCompetencesInput>
    create: XOR<PersonnageCreateWithoutCompetencesInput, PersonnageUncheckedCreateWithoutCompetencesInput>
    where?: PersonnageWhereInput
  }

  export type PersonnageUpdateToOneWithWhereWithoutCompetencesInput = {
    where?: PersonnageWhereInput
    data: XOR<PersonnageUpdateWithoutCompetencesInput, PersonnageUncheckedUpdateWithoutCompetencesInput>
  }

  export type PersonnageUpdateWithoutCompetencesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneWithoutPersonnagesNestedInput
    lignee?: LigneeUpdateOneWithoutPersonnagesNestedInput
    roles?: PersonnageRoleUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateWithoutCompetencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
    roles?: PersonnageRoleUncheckedUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUncheckedUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUncheckedUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUncheckedUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUncheckedUpdateManyWithoutPersonnageNestedInput
  }

  export type CompetenceUpsertWithoutPersonnagesInput = {
    update: XOR<CompetenceUpdateWithoutPersonnagesInput, CompetenceUncheckedUpdateWithoutPersonnagesInput>
    create: XOR<CompetenceCreateWithoutPersonnagesInput, CompetenceUncheckedCreateWithoutPersonnagesInput>
    where?: CompetenceWhereInput
  }

  export type CompetenceUpdateToOneWithWhereWithoutPersonnagesInput = {
    where?: CompetenceWhereInput
    data: XOR<CompetenceUpdateWithoutPersonnagesInput, CompetenceUncheckedUpdateWithoutPersonnagesInput>
  }

  export type CompetenceUpdateWithoutPersonnagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    exigenceFormation?: NullableStringFieldUpdateOperationsInput | string | null
    exigenceRace?: RaceUpdateOneWithoutCompetencesNestedInput
  }

  export type CompetenceUncheckedUpdateWithoutPersonnagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    exigenceFormation?: NullableStringFieldUpdateOperationsInput | string | null
    exigenceRaceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VillageCreateWithoutDomaineInput = {
    nom: string
    localisation?: string | null
    population?: number | null
    ressourcePrincipale?: string | null
    inventaires?: InventaireCreateNestedManyWithoutVillageInput
  }

  export type VillageUncheckedCreateWithoutDomaineInput = {
    id?: number
    nom: string
    localisation?: string | null
    population?: number | null
    ressourcePrincipale?: string | null
    inventaires?: InventaireUncheckedCreateNestedManyWithoutVillageInput
  }

  export type VillageCreateOrConnectWithoutDomaineInput = {
    where: VillageWhereUniqueInput
    create: XOR<VillageCreateWithoutDomaineInput, VillageUncheckedCreateWithoutDomaineInput>
  }

  export type VillageCreateManyDomaineInputEnvelope = {
    data: VillageCreateManyDomaineInput | VillageCreateManyDomaineInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageTitreCreateWithoutDomaineInput = {
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnage: PersonnageCreateNestedOneWithoutTitresInput
    titre: TitreCreateNestedOneWithoutAttributionsInput
    lignee?: LigneeCreateNestedOneWithoutTitresInput
  }

  export type PersonnageTitreUncheckedCreateWithoutDomaineInput = {
    id?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnageId: number
    titreId: number
    ligneeId?: number | null
  }

  export type PersonnageTitreCreateOrConnectWithoutDomaineInput = {
    where: PersonnageTitreWhereUniqueInput
    create: XOR<PersonnageTitreCreateWithoutDomaineInput, PersonnageTitreUncheckedCreateWithoutDomaineInput>
  }

  export type PersonnageTitreCreateManyDomaineInputEnvelope = {
    data: PersonnageTitreCreateManyDomaineInput | PersonnageTitreCreateManyDomaineInput[]
    skipDuplicates?: boolean
  }

  export type ArmeeCreateWithoutDomaineInput = {
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    commandant?: PersonnageCreateNestedOneWithoutCommandementsInput
    batailles?: ArmeeBatailleCreateNestedManyWithoutArmeeInput
    inventaires?: InventaireCreateNestedManyWithoutArmeeInput
  }

  export type ArmeeUncheckedCreateWithoutDomaineInput = {
    id?: number
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    commandantId?: number | null
    batailles?: ArmeeBatailleUncheckedCreateNestedManyWithoutArmeeInput
    inventaires?: InventaireUncheckedCreateNestedManyWithoutArmeeInput
  }

  export type ArmeeCreateOrConnectWithoutDomaineInput = {
    where: ArmeeWhereUniqueInput
    create: XOR<ArmeeCreateWithoutDomaineInput, ArmeeUncheckedCreateWithoutDomaineInput>
  }

  export type ArmeeCreateManyDomaineInputEnvelope = {
    data: ArmeeCreateManyDomaineInput | ArmeeCreateManyDomaineInput[]
    skipDuplicates?: boolean
  }

  export type RelationDiplomatiqueCreateWithoutDomaineSourceInput = {
    typeRelation?: string | null
    conditions?: string | null
    dateSignature?: Date | string | null
    echeance?: string | null
    domaineCible: DomaineCreateNestedOneWithoutRelationsCibleInput
  }

  export type RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput = {
    id?: number
    typeRelation?: string | null
    conditions?: string | null
    dateSignature?: Date | string | null
    echeance?: string | null
    domaineCibleId: number
  }

  export type RelationDiplomatiqueCreateOrConnectWithoutDomaineSourceInput = {
    where: RelationDiplomatiqueWhereUniqueInput
    create: XOR<RelationDiplomatiqueCreateWithoutDomaineSourceInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput>
  }

  export type RelationDiplomatiqueCreateManyDomaineSourceInputEnvelope = {
    data: RelationDiplomatiqueCreateManyDomaineSourceInput | RelationDiplomatiqueCreateManyDomaineSourceInput[]
    skipDuplicates?: boolean
  }

  export type RelationDiplomatiqueCreateWithoutDomaineCibleInput = {
    typeRelation?: string | null
    conditions?: string | null
    dateSignature?: Date | string | null
    echeance?: string | null
    domaineSource: DomaineCreateNestedOneWithoutRelationsSourceInput
  }

  export type RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput = {
    id?: number
    typeRelation?: string | null
    conditions?: string | null
    dateSignature?: Date | string | null
    echeance?: string | null
    domaineSourceId: number
  }

  export type RelationDiplomatiqueCreateOrConnectWithoutDomaineCibleInput = {
    where: RelationDiplomatiqueWhereUniqueInput
    create: XOR<RelationDiplomatiqueCreateWithoutDomaineCibleInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput>
  }

  export type RelationDiplomatiqueCreateManyDomaineCibleInputEnvelope = {
    data: RelationDiplomatiqueCreateManyDomaineCibleInput | RelationDiplomatiqueCreateManyDomaineCibleInput[]
    skipDuplicates?: boolean
  }

  export type LoiTerritoireCreateWithoutDomaineInput = {
    loi: LoiCreateNestedOneWithoutDomainesInput
  }

  export type LoiTerritoireUncheckedCreateWithoutDomaineInput = {
    loiId: number
  }

  export type LoiTerritoireCreateOrConnectWithoutDomaineInput = {
    where: LoiTerritoireWhereUniqueInput
    create: XOR<LoiTerritoireCreateWithoutDomaineInput, LoiTerritoireUncheckedCreateWithoutDomaineInput>
  }

  export type LoiTerritoireCreateManyDomaineInputEnvelope = {
    data: LoiTerritoireCreateManyDomaineInput | LoiTerritoireCreateManyDomaineInput[]
    skipDuplicates?: boolean
  }

  export type VillageUpsertWithWhereUniqueWithoutDomaineInput = {
    where: VillageWhereUniqueInput
    update: XOR<VillageUpdateWithoutDomaineInput, VillageUncheckedUpdateWithoutDomaineInput>
    create: XOR<VillageCreateWithoutDomaineInput, VillageUncheckedCreateWithoutDomaineInput>
  }

  export type VillageUpdateWithWhereUniqueWithoutDomaineInput = {
    where: VillageWhereUniqueInput
    data: XOR<VillageUpdateWithoutDomaineInput, VillageUncheckedUpdateWithoutDomaineInput>
  }

  export type VillageUpdateManyWithWhereWithoutDomaineInput = {
    where: VillageScalarWhereInput
    data: XOR<VillageUpdateManyMutationInput, VillageUncheckedUpdateManyWithoutDomaineInput>
  }

  export type VillageScalarWhereInput = {
    AND?: VillageScalarWhereInput | VillageScalarWhereInput[]
    OR?: VillageScalarWhereInput[]
    NOT?: VillageScalarWhereInput | VillageScalarWhereInput[]
    id?: IntFilter<"Village"> | number
    nom?: StringFilter<"Village"> | string
    localisation?: StringNullableFilter<"Village"> | string | null
    population?: IntNullableFilter<"Village"> | number | null
    ressourcePrincipale?: StringNullableFilter<"Village"> | string | null
    domaineId?: IntNullableFilter<"Village"> | number | null
  }

  export type PersonnageTitreUpsertWithWhereUniqueWithoutDomaineInput = {
    where: PersonnageTitreWhereUniqueInput
    update: XOR<PersonnageTitreUpdateWithoutDomaineInput, PersonnageTitreUncheckedUpdateWithoutDomaineInput>
    create: XOR<PersonnageTitreCreateWithoutDomaineInput, PersonnageTitreUncheckedCreateWithoutDomaineInput>
  }

  export type PersonnageTitreUpdateWithWhereUniqueWithoutDomaineInput = {
    where: PersonnageTitreWhereUniqueInput
    data: XOR<PersonnageTitreUpdateWithoutDomaineInput, PersonnageTitreUncheckedUpdateWithoutDomaineInput>
  }

  export type PersonnageTitreUpdateManyWithWhereWithoutDomaineInput = {
    where: PersonnageTitreScalarWhereInput
    data: XOR<PersonnageTitreUpdateManyMutationInput, PersonnageTitreUncheckedUpdateManyWithoutDomaineInput>
  }

  export type ArmeeUpsertWithWhereUniqueWithoutDomaineInput = {
    where: ArmeeWhereUniqueInput
    update: XOR<ArmeeUpdateWithoutDomaineInput, ArmeeUncheckedUpdateWithoutDomaineInput>
    create: XOR<ArmeeCreateWithoutDomaineInput, ArmeeUncheckedCreateWithoutDomaineInput>
  }

  export type ArmeeUpdateWithWhereUniqueWithoutDomaineInput = {
    where: ArmeeWhereUniqueInput
    data: XOR<ArmeeUpdateWithoutDomaineInput, ArmeeUncheckedUpdateWithoutDomaineInput>
  }

  export type ArmeeUpdateManyWithWhereWithoutDomaineInput = {
    where: ArmeeScalarWhereInput
    data: XOR<ArmeeUpdateManyMutationInput, ArmeeUncheckedUpdateManyWithoutDomaineInput>
  }

  export type RelationDiplomatiqueUpsertWithWhereUniqueWithoutDomaineSourceInput = {
    where: RelationDiplomatiqueWhereUniqueInput
    update: XOR<RelationDiplomatiqueUpdateWithoutDomaineSourceInput, RelationDiplomatiqueUncheckedUpdateWithoutDomaineSourceInput>
    create: XOR<RelationDiplomatiqueCreateWithoutDomaineSourceInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineSourceInput>
  }

  export type RelationDiplomatiqueUpdateWithWhereUniqueWithoutDomaineSourceInput = {
    where: RelationDiplomatiqueWhereUniqueInput
    data: XOR<RelationDiplomatiqueUpdateWithoutDomaineSourceInput, RelationDiplomatiqueUncheckedUpdateWithoutDomaineSourceInput>
  }

  export type RelationDiplomatiqueUpdateManyWithWhereWithoutDomaineSourceInput = {
    where: RelationDiplomatiqueScalarWhereInput
    data: XOR<RelationDiplomatiqueUpdateManyMutationInput, RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineSourceInput>
  }

  export type RelationDiplomatiqueScalarWhereInput = {
    AND?: RelationDiplomatiqueScalarWhereInput | RelationDiplomatiqueScalarWhereInput[]
    OR?: RelationDiplomatiqueScalarWhereInput[]
    NOT?: RelationDiplomatiqueScalarWhereInput | RelationDiplomatiqueScalarWhereInput[]
    id?: IntFilter<"RelationDiplomatique"> | number
    typeRelation?: StringNullableFilter<"RelationDiplomatique"> | string | null
    conditions?: StringNullableFilter<"RelationDiplomatique"> | string | null
    dateSignature?: DateTimeNullableFilter<"RelationDiplomatique"> | Date | string | null
    echeance?: StringNullableFilter<"RelationDiplomatique"> | string | null
    domaineSourceId?: IntFilter<"RelationDiplomatique"> | number
    domaineCibleId?: IntFilter<"RelationDiplomatique"> | number
  }

  export type RelationDiplomatiqueUpsertWithWhereUniqueWithoutDomaineCibleInput = {
    where: RelationDiplomatiqueWhereUniqueInput
    update: XOR<RelationDiplomatiqueUpdateWithoutDomaineCibleInput, RelationDiplomatiqueUncheckedUpdateWithoutDomaineCibleInput>
    create: XOR<RelationDiplomatiqueCreateWithoutDomaineCibleInput, RelationDiplomatiqueUncheckedCreateWithoutDomaineCibleInput>
  }

  export type RelationDiplomatiqueUpdateWithWhereUniqueWithoutDomaineCibleInput = {
    where: RelationDiplomatiqueWhereUniqueInput
    data: XOR<RelationDiplomatiqueUpdateWithoutDomaineCibleInput, RelationDiplomatiqueUncheckedUpdateWithoutDomaineCibleInput>
  }

  export type RelationDiplomatiqueUpdateManyWithWhereWithoutDomaineCibleInput = {
    where: RelationDiplomatiqueScalarWhereInput
    data: XOR<RelationDiplomatiqueUpdateManyMutationInput, RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineCibleInput>
  }

  export type LoiTerritoireUpsertWithWhereUniqueWithoutDomaineInput = {
    where: LoiTerritoireWhereUniqueInput
    update: XOR<LoiTerritoireUpdateWithoutDomaineInput, LoiTerritoireUncheckedUpdateWithoutDomaineInput>
    create: XOR<LoiTerritoireCreateWithoutDomaineInput, LoiTerritoireUncheckedCreateWithoutDomaineInput>
  }

  export type LoiTerritoireUpdateWithWhereUniqueWithoutDomaineInput = {
    where: LoiTerritoireWhereUniqueInput
    data: XOR<LoiTerritoireUpdateWithoutDomaineInput, LoiTerritoireUncheckedUpdateWithoutDomaineInput>
  }

  export type LoiTerritoireUpdateManyWithWhereWithoutDomaineInput = {
    where: LoiTerritoireScalarWhereInput
    data: XOR<LoiTerritoireUpdateManyMutationInput, LoiTerritoireUncheckedUpdateManyWithoutDomaineInput>
  }

  export type LoiTerritoireScalarWhereInput = {
    AND?: LoiTerritoireScalarWhereInput | LoiTerritoireScalarWhereInput[]
    OR?: LoiTerritoireScalarWhereInput[]
    NOT?: LoiTerritoireScalarWhereInput | LoiTerritoireScalarWhereInput[]
    loiId?: IntFilter<"LoiTerritoire"> | number
    domaineId?: IntFilter<"LoiTerritoire"> | number
  }

  export type PersonnageTitreCreateWithoutTitreInput = {
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnage: PersonnageCreateNestedOneWithoutTitresInput
    domaine?: DomaineCreateNestedOneWithoutTitresInput
    lignee?: LigneeCreateNestedOneWithoutTitresInput
  }

  export type PersonnageTitreUncheckedCreateWithoutTitreInput = {
    id?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnageId: number
    domaineId?: number | null
    ligneeId?: number | null
  }

  export type PersonnageTitreCreateOrConnectWithoutTitreInput = {
    where: PersonnageTitreWhereUniqueInput
    create: XOR<PersonnageTitreCreateWithoutTitreInput, PersonnageTitreUncheckedCreateWithoutTitreInput>
  }

  export type PersonnageTitreCreateManyTitreInputEnvelope = {
    data: PersonnageTitreCreateManyTitreInput | PersonnageTitreCreateManyTitreInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageTitreUpsertWithWhereUniqueWithoutTitreInput = {
    where: PersonnageTitreWhereUniqueInput
    update: XOR<PersonnageTitreUpdateWithoutTitreInput, PersonnageTitreUncheckedUpdateWithoutTitreInput>
    create: XOR<PersonnageTitreCreateWithoutTitreInput, PersonnageTitreUncheckedCreateWithoutTitreInput>
  }

  export type PersonnageTitreUpdateWithWhereUniqueWithoutTitreInput = {
    where: PersonnageTitreWhereUniqueInput
    data: XOR<PersonnageTitreUpdateWithoutTitreInput, PersonnageTitreUncheckedUpdateWithoutTitreInput>
  }

  export type PersonnageTitreUpdateManyWithWhereWithoutTitreInput = {
    where: PersonnageTitreScalarWhereInput
    data: XOR<PersonnageTitreUpdateManyMutationInput, PersonnageTitreUncheckedUpdateManyWithoutTitreInput>
  }

  export type PersonnageCreateWithoutTitresInput = {
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    race?: RaceCreateNestedOneWithoutPersonnagesInput
    lignee?: LigneeCreateNestedOneWithoutPersonnagesInput
    roles?: PersonnageRoleCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUncheckedCreateWithoutTitresInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
    ligneeId?: number | null
    roles?: PersonnageRoleUncheckedCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceUncheckedCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieUncheckedCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeUncheckedCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementUncheckedCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreUncheckedCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageCreateOrConnectWithoutTitresInput = {
    where: PersonnageWhereUniqueInput
    create: XOR<PersonnageCreateWithoutTitresInput, PersonnageUncheckedCreateWithoutTitresInput>
  }

  export type TitreCreateWithoutAttributionsInput = {
    libelle: string
  }

  export type TitreUncheckedCreateWithoutAttributionsInput = {
    id?: number
    libelle: string
  }

  export type TitreCreateOrConnectWithoutAttributionsInput = {
    where: TitreWhereUniqueInput
    create: XOR<TitreCreateWithoutAttributionsInput, TitreUncheckedCreateWithoutAttributionsInput>
  }

  export type DomaineCreateWithoutTitresInput = {
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageCreateNestedManyWithoutDomaineInput
    armees?: ArmeeCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueCreateNestedManyWithoutDomaineSourceInput
    relationsCible?: RelationDiplomatiqueCreateNestedManyWithoutDomaineCibleInput
    lois?: LoiTerritoireCreateNestedManyWithoutDomaineInput
  }

  export type DomaineUncheckedCreateWithoutTitresInput = {
    id?: number
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageUncheckedCreateNestedManyWithoutDomaineInput
    armees?: ArmeeUncheckedCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineSourceInput
    relationsCible?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineCibleInput
    lois?: LoiTerritoireUncheckedCreateNestedManyWithoutDomaineInput
  }

  export type DomaineCreateOrConnectWithoutTitresInput = {
    where: DomaineWhereUniqueInput
    create: XOR<DomaineCreateWithoutTitresInput, DomaineUncheckedCreateWithoutTitresInput>
  }

  export type LigneeCreateWithoutTitresInput = {
    nom: string
    personnages?: PersonnageCreateNestedManyWithoutLigneeInput
  }

  export type LigneeUncheckedCreateWithoutTitresInput = {
    id?: number
    nom: string
    personnages?: PersonnageUncheckedCreateNestedManyWithoutLigneeInput
  }

  export type LigneeCreateOrConnectWithoutTitresInput = {
    where: LigneeWhereUniqueInput
    create: XOR<LigneeCreateWithoutTitresInput, LigneeUncheckedCreateWithoutTitresInput>
  }

  export type PersonnageUpsertWithoutTitresInput = {
    update: XOR<PersonnageUpdateWithoutTitresInput, PersonnageUncheckedUpdateWithoutTitresInput>
    create: XOR<PersonnageCreateWithoutTitresInput, PersonnageUncheckedCreateWithoutTitresInput>
    where?: PersonnageWhereInput
  }

  export type PersonnageUpdateToOneWithWhereWithoutTitresInput = {
    where?: PersonnageWhereInput
    data: XOR<PersonnageUpdateWithoutTitresInput, PersonnageUncheckedUpdateWithoutTitresInput>
  }

  export type PersonnageUpdateWithoutTitresInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneWithoutPersonnagesNestedInput
    lignee?: LigneeUpdateOneWithoutPersonnagesNestedInput
    roles?: PersonnageRoleUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateWithoutTitresInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
    roles?: PersonnageRoleUncheckedUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUncheckedUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUncheckedUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUncheckedUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUncheckedUpdateManyWithoutPersonnageNestedInput
  }

  export type TitreUpsertWithoutAttributionsInput = {
    update: XOR<TitreUpdateWithoutAttributionsInput, TitreUncheckedUpdateWithoutAttributionsInput>
    create: XOR<TitreCreateWithoutAttributionsInput, TitreUncheckedCreateWithoutAttributionsInput>
    where?: TitreWhereInput
  }

  export type TitreUpdateToOneWithWhereWithoutAttributionsInput = {
    where?: TitreWhereInput
    data: XOR<TitreUpdateWithoutAttributionsInput, TitreUncheckedUpdateWithoutAttributionsInput>
  }

  export type TitreUpdateWithoutAttributionsInput = {
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type TitreUncheckedUpdateWithoutAttributionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type DomaineUpsertWithoutTitresInput = {
    update: XOR<DomaineUpdateWithoutTitresInput, DomaineUncheckedUpdateWithoutTitresInput>
    create: XOR<DomaineCreateWithoutTitresInput, DomaineUncheckedCreateWithoutTitresInput>
    where?: DomaineWhereInput
  }

  export type DomaineUpdateToOneWithWhereWithoutTitresInput = {
    where?: DomaineWhereInput
    data: XOR<DomaineUpdateWithoutTitresInput, DomaineUncheckedUpdateWithoutTitresInput>
  }

  export type DomaineUpdateWithoutTitresInput = {
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUpdateManyWithoutDomaineSourceNestedInput
    relationsCible?: RelationDiplomatiqueUpdateManyWithoutDomaineCibleNestedInput
    lois?: LoiTerritoireUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineUncheckedUpdateWithoutTitresInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUncheckedUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUncheckedUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineSourceNestedInput
    relationsCible?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineCibleNestedInput
    lois?: LoiTerritoireUncheckedUpdateManyWithoutDomaineNestedInput
  }

  export type LigneeUpsertWithoutTitresInput = {
    update: XOR<LigneeUpdateWithoutTitresInput, LigneeUncheckedUpdateWithoutTitresInput>
    create: XOR<LigneeCreateWithoutTitresInput, LigneeUncheckedCreateWithoutTitresInput>
    where?: LigneeWhereInput
  }

  export type LigneeUpdateToOneWithWhereWithoutTitresInput = {
    where?: LigneeWhereInput
    data: XOR<LigneeUpdateWithoutTitresInput, LigneeUncheckedUpdateWithoutTitresInput>
  }

  export type LigneeUpdateWithoutTitresInput = {
    nom?: StringFieldUpdateOperationsInput | string
    personnages?: PersonnageUpdateManyWithoutLigneeNestedInput
  }

  export type LigneeUncheckedUpdateWithoutTitresInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    personnages?: PersonnageUncheckedUpdateManyWithoutLigneeNestedInput
  }

  export type DomaineCreateWithoutVillagesInput = {
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    titres?: PersonnageTitreCreateNestedManyWithoutDomaineInput
    armees?: ArmeeCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueCreateNestedManyWithoutDomaineSourceInput
    relationsCible?: RelationDiplomatiqueCreateNestedManyWithoutDomaineCibleInput
    lois?: LoiTerritoireCreateNestedManyWithoutDomaineInput
  }

  export type DomaineUncheckedCreateWithoutVillagesInput = {
    id?: number
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutDomaineInput
    armees?: ArmeeUncheckedCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineSourceInput
    relationsCible?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineCibleInput
    lois?: LoiTerritoireUncheckedCreateNestedManyWithoutDomaineInput
  }

  export type DomaineCreateOrConnectWithoutVillagesInput = {
    where: DomaineWhereUniqueInput
    create: XOR<DomaineCreateWithoutVillagesInput, DomaineUncheckedCreateWithoutVillagesInput>
  }

  export type InventaireCreateWithoutVillageInput = {
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    lieu?: LieuCreateNestedOneWithoutInventairesInput
    armee?: ArmeeCreateNestedOneWithoutInventairesInput
  }

  export type InventaireUncheckedCreateWithoutVillageInput = {
    id?: number
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    lieuId?: number | null
    armeeId?: number | null
  }

  export type InventaireCreateOrConnectWithoutVillageInput = {
    where: InventaireWhereUniqueInput
    create: XOR<InventaireCreateWithoutVillageInput, InventaireUncheckedCreateWithoutVillageInput>
  }

  export type InventaireCreateManyVillageInputEnvelope = {
    data: InventaireCreateManyVillageInput | InventaireCreateManyVillageInput[]
    skipDuplicates?: boolean
  }

  export type DomaineUpsertWithoutVillagesInput = {
    update: XOR<DomaineUpdateWithoutVillagesInput, DomaineUncheckedUpdateWithoutVillagesInput>
    create: XOR<DomaineCreateWithoutVillagesInput, DomaineUncheckedCreateWithoutVillagesInput>
    where?: DomaineWhereInput
  }

  export type DomaineUpdateToOneWithWhereWithoutVillagesInput = {
    where?: DomaineWhereInput
    data: XOR<DomaineUpdateWithoutVillagesInput, DomaineUncheckedUpdateWithoutVillagesInput>
  }

  export type DomaineUpdateWithoutVillagesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    titres?: PersonnageTitreUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUpdateManyWithoutDomaineSourceNestedInput
    relationsCible?: RelationDiplomatiqueUpdateManyWithoutDomaineCibleNestedInput
    lois?: LoiTerritoireUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineUncheckedUpdateWithoutVillagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    titres?: PersonnageTitreUncheckedUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUncheckedUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineSourceNestedInput
    relationsCible?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineCibleNestedInput
    lois?: LoiTerritoireUncheckedUpdateManyWithoutDomaineNestedInput
  }

  export type InventaireUpsertWithWhereUniqueWithoutVillageInput = {
    where: InventaireWhereUniqueInput
    update: XOR<InventaireUpdateWithoutVillageInput, InventaireUncheckedUpdateWithoutVillageInput>
    create: XOR<InventaireCreateWithoutVillageInput, InventaireUncheckedCreateWithoutVillageInput>
  }

  export type InventaireUpdateWithWhereUniqueWithoutVillageInput = {
    where: InventaireWhereUniqueInput
    data: XOR<InventaireUpdateWithoutVillageInput, InventaireUncheckedUpdateWithoutVillageInput>
  }

  export type InventaireUpdateManyWithWhereWithoutVillageInput = {
    where: InventaireScalarWhereInput
    data: XOR<InventaireUpdateManyMutationInput, InventaireUncheckedUpdateManyWithoutVillageInput>
  }

  export type InventaireScalarWhereInput = {
    AND?: InventaireScalarWhereInput | InventaireScalarWhereInput[]
    OR?: InventaireScalarWhereInput[]
    NOT?: InventaireScalarWhereInput | InventaireScalarWhereInput[]
    id?: IntFilter<"Inventaire"> | number
    typeRessource?: StringNullableFilter<"Inventaire"> | string | null
    stock?: IntNullableFilter<"Inventaire"> | number | null
    seuilAlerte?: IntNullableFilter<"Inventaire"> | number | null
    dateMesure?: DateTimeNullableFilter<"Inventaire"> | Date | string | null
    lieuId?: IntNullableFilter<"Inventaire"> | number | null
    armeeId?: IntNullableFilter<"Inventaire"> | number | null
    villageId?: IntNullableFilter<"Inventaire"> | number | null
  }

  export type GuildeMembreCreateWithoutGuildeInput = {
    dateEntree?: Date | string | null
    dateSortie?: Date | string | null
    personnage: PersonnageCreateNestedOneWithoutGuildesInput
  }

  export type GuildeMembreUncheckedCreateWithoutGuildeInput = {
    personnageId: number
    dateEntree?: Date | string | null
    dateSortie?: Date | string | null
  }

  export type GuildeMembreCreateOrConnectWithoutGuildeInput = {
    where: GuildeMembreWhereUniqueInput
    create: XOR<GuildeMembreCreateWithoutGuildeInput, GuildeMembreUncheckedCreateWithoutGuildeInput>
  }

  export type GuildeMembreCreateManyGuildeInputEnvelope = {
    data: GuildeMembreCreateManyGuildeInput | GuildeMembreCreateManyGuildeInput[]
    skipDuplicates?: boolean
  }

  export type GuildeBatailleCreateWithoutGuildeInput = {
    role?: string | null
    bataille: BatailleCreateNestedOneWithoutGuildesInput
  }

  export type GuildeBatailleUncheckedCreateWithoutGuildeInput = {
    batailleId: number
    role?: string | null
  }

  export type GuildeBatailleCreateOrConnectWithoutGuildeInput = {
    where: GuildeBatailleWhereUniqueInput
    create: XOR<GuildeBatailleCreateWithoutGuildeInput, GuildeBatailleUncheckedCreateWithoutGuildeInput>
  }

  export type GuildeBatailleCreateManyGuildeInputEnvelope = {
    data: GuildeBatailleCreateManyGuildeInput | GuildeBatailleCreateManyGuildeInput[]
    skipDuplicates?: boolean
  }

  export type GuildeMembreUpsertWithWhereUniqueWithoutGuildeInput = {
    where: GuildeMembreWhereUniqueInput
    update: XOR<GuildeMembreUpdateWithoutGuildeInput, GuildeMembreUncheckedUpdateWithoutGuildeInput>
    create: XOR<GuildeMembreCreateWithoutGuildeInput, GuildeMembreUncheckedCreateWithoutGuildeInput>
  }

  export type GuildeMembreUpdateWithWhereUniqueWithoutGuildeInput = {
    where: GuildeMembreWhereUniqueInput
    data: XOR<GuildeMembreUpdateWithoutGuildeInput, GuildeMembreUncheckedUpdateWithoutGuildeInput>
  }

  export type GuildeMembreUpdateManyWithWhereWithoutGuildeInput = {
    where: GuildeMembreScalarWhereInput
    data: XOR<GuildeMembreUpdateManyMutationInput, GuildeMembreUncheckedUpdateManyWithoutGuildeInput>
  }

  export type GuildeBatailleUpsertWithWhereUniqueWithoutGuildeInput = {
    where: GuildeBatailleWhereUniqueInput
    update: XOR<GuildeBatailleUpdateWithoutGuildeInput, GuildeBatailleUncheckedUpdateWithoutGuildeInput>
    create: XOR<GuildeBatailleCreateWithoutGuildeInput, GuildeBatailleUncheckedCreateWithoutGuildeInput>
  }

  export type GuildeBatailleUpdateWithWhereUniqueWithoutGuildeInput = {
    where: GuildeBatailleWhereUniqueInput
    data: XOR<GuildeBatailleUpdateWithoutGuildeInput, GuildeBatailleUncheckedUpdateWithoutGuildeInput>
  }

  export type GuildeBatailleUpdateManyWithWhereWithoutGuildeInput = {
    where: GuildeBatailleScalarWhereInput
    data: XOR<GuildeBatailleUpdateManyMutationInput, GuildeBatailleUncheckedUpdateManyWithoutGuildeInput>
  }

  export type GuildeBatailleScalarWhereInput = {
    AND?: GuildeBatailleScalarWhereInput | GuildeBatailleScalarWhereInput[]
    OR?: GuildeBatailleScalarWhereInput[]
    NOT?: GuildeBatailleScalarWhereInput | GuildeBatailleScalarWhereInput[]
    guildeId?: IntFilter<"GuildeBataille"> | number
    batailleId?: IntFilter<"GuildeBataille"> | number
    role?: StringNullableFilter<"GuildeBataille"> | string | null
  }

  export type PersonnageCreateWithoutGuildesInput = {
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    race?: RaceCreateNestedOneWithoutPersonnagesInput
    lignee?: LigneeCreateNestedOneWithoutPersonnagesInput
    roles?: PersonnageRoleCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUncheckedCreateWithoutGuildesInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
    ligneeId?: number | null
    roles?: PersonnageRoleUncheckedCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceUncheckedCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieUncheckedCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeUncheckedCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementUncheckedCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageCreateOrConnectWithoutGuildesInput = {
    where: PersonnageWhereUniqueInput
    create: XOR<PersonnageCreateWithoutGuildesInput, PersonnageUncheckedCreateWithoutGuildesInput>
  }

  export type GuildeCreateWithoutMembresInput = {
    nom: string
    specialite?: string | null
    reputation?: string | null
    batailles?: GuildeBatailleCreateNestedManyWithoutGuildeInput
  }

  export type GuildeUncheckedCreateWithoutMembresInput = {
    id?: number
    nom: string
    specialite?: string | null
    reputation?: string | null
    batailles?: GuildeBatailleUncheckedCreateNestedManyWithoutGuildeInput
  }

  export type GuildeCreateOrConnectWithoutMembresInput = {
    where: GuildeWhereUniqueInput
    create: XOR<GuildeCreateWithoutMembresInput, GuildeUncheckedCreateWithoutMembresInput>
  }

  export type PersonnageUpsertWithoutGuildesInput = {
    update: XOR<PersonnageUpdateWithoutGuildesInput, PersonnageUncheckedUpdateWithoutGuildesInput>
    create: XOR<PersonnageCreateWithoutGuildesInput, PersonnageUncheckedCreateWithoutGuildesInput>
    where?: PersonnageWhereInput
  }

  export type PersonnageUpdateToOneWithWhereWithoutGuildesInput = {
    where?: PersonnageWhereInput
    data: XOR<PersonnageUpdateWithoutGuildesInput, PersonnageUncheckedUpdateWithoutGuildesInput>
  }

  export type PersonnageUpdateWithoutGuildesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneWithoutPersonnagesNestedInput
    lignee?: LigneeUpdateOneWithoutPersonnagesNestedInput
    roles?: PersonnageRoleUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateWithoutGuildesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
    roles?: PersonnageRoleUncheckedUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUncheckedUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUncheckedUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUncheckedUpdateManyWithoutPersonnageNestedInput
  }

  export type GuildeUpsertWithoutMembresInput = {
    update: XOR<GuildeUpdateWithoutMembresInput, GuildeUncheckedUpdateWithoutMembresInput>
    create: XOR<GuildeCreateWithoutMembresInput, GuildeUncheckedCreateWithoutMembresInput>
    where?: GuildeWhereInput
  }

  export type GuildeUpdateToOneWithWhereWithoutMembresInput = {
    where?: GuildeWhereInput
    data: XOR<GuildeUpdateWithoutMembresInput, GuildeUncheckedUpdateWithoutMembresInput>
  }

  export type GuildeUpdateWithoutMembresInput = {
    nom?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableStringFieldUpdateOperationsInput | string | null
    batailles?: GuildeBatailleUpdateManyWithoutGuildeNestedInput
  }

  export type GuildeUncheckedUpdateWithoutMembresInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableStringFieldUpdateOperationsInput | string | null
    batailles?: GuildeBatailleUncheckedUpdateManyWithoutGuildeNestedInput
  }

  export type CreatureBatailleCreateWithoutCreatureInput = {
    nombre?: number | null
    role?: string | null
    bataille: BatailleCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureBatailleUncheckedCreateWithoutCreatureInput = {
    batailleId: number
    nombre?: number | null
    role?: string | null
  }

  export type CreatureBatailleCreateOrConnectWithoutCreatureInput = {
    where: CreatureBatailleWhereUniqueInput
    create: XOR<CreatureBatailleCreateWithoutCreatureInput, CreatureBatailleUncheckedCreateWithoutCreatureInput>
  }

  export type CreatureBatailleCreateManyCreatureInputEnvelope = {
    data: CreatureBatailleCreateManyCreatureInput | CreatureBatailleCreateManyCreatureInput[]
    skipDuplicates?: boolean
  }

  export type CreatureBatailleUpsertWithWhereUniqueWithoutCreatureInput = {
    where: CreatureBatailleWhereUniqueInput
    update: XOR<CreatureBatailleUpdateWithoutCreatureInput, CreatureBatailleUncheckedUpdateWithoutCreatureInput>
    create: XOR<CreatureBatailleCreateWithoutCreatureInput, CreatureBatailleUncheckedCreateWithoutCreatureInput>
  }

  export type CreatureBatailleUpdateWithWhereUniqueWithoutCreatureInput = {
    where: CreatureBatailleWhereUniqueInput
    data: XOR<CreatureBatailleUpdateWithoutCreatureInput, CreatureBatailleUncheckedUpdateWithoutCreatureInput>
  }

  export type CreatureBatailleUpdateManyWithWhereWithoutCreatureInput = {
    where: CreatureBatailleScalarWhereInput
    data: XOR<CreatureBatailleUpdateManyMutationInput, CreatureBatailleUncheckedUpdateManyWithoutCreatureInput>
  }

  export type CreatureBatailleScalarWhereInput = {
    AND?: CreatureBatailleScalarWhereInput | CreatureBatailleScalarWhereInput[]
    OR?: CreatureBatailleScalarWhereInput[]
    NOT?: CreatureBatailleScalarWhereInput | CreatureBatailleScalarWhereInput[]
    creatureId?: IntFilter<"CreatureBataille"> | number
    batailleId?: IntFilter<"CreatureBataille"> | number
    nombre?: IntNullableFilter<"CreatureBataille"> | number | null
    role?: StringNullableFilter<"CreatureBataille"> | string | null
  }

  export type SortCreateWithoutEcoleInput = {
    nom: string
    element?: string | null
    coutMana?: number | null
    niveauRequis?: string | null
    estInterdit?: boolean
    estRituel?: boolean
  }

  export type SortUncheckedCreateWithoutEcoleInput = {
    id?: number
    nom: string
    element?: string | null
    coutMana?: number | null
    niveauRequis?: string | null
    estInterdit?: boolean
    estRituel?: boolean
  }

  export type SortCreateOrConnectWithoutEcoleInput = {
    where: SortWhereUniqueInput
    create: XOR<SortCreateWithoutEcoleInput, SortUncheckedCreateWithoutEcoleInput>
  }

  export type SortCreateManyEcoleInputEnvelope = {
    data: SortCreateManyEcoleInput | SortCreateManyEcoleInput[]
    skipDuplicates?: boolean
  }

  export type SortUpsertWithWhereUniqueWithoutEcoleInput = {
    where: SortWhereUniqueInput
    update: XOR<SortUpdateWithoutEcoleInput, SortUncheckedUpdateWithoutEcoleInput>
    create: XOR<SortCreateWithoutEcoleInput, SortUncheckedCreateWithoutEcoleInput>
  }

  export type SortUpdateWithWhereUniqueWithoutEcoleInput = {
    where: SortWhereUniqueInput
    data: XOR<SortUpdateWithoutEcoleInput, SortUncheckedUpdateWithoutEcoleInput>
  }

  export type SortUpdateManyWithWhereWithoutEcoleInput = {
    where: SortScalarWhereInput
    data: XOR<SortUpdateManyMutationInput, SortUncheckedUpdateManyWithoutEcoleInput>
  }

  export type SortScalarWhereInput = {
    AND?: SortScalarWhereInput | SortScalarWhereInput[]
    OR?: SortScalarWhereInput[]
    NOT?: SortScalarWhereInput | SortScalarWhereInput[]
    id?: IntFilter<"Sort"> | number
    nom?: StringFilter<"Sort"> | string
    element?: StringNullableFilter<"Sort"> | string | null
    coutMana?: IntNullableFilter<"Sort"> | number | null
    niveauRequis?: StringNullableFilter<"Sort"> | string | null
    estInterdit?: BoolFilter<"Sort"> | boolean
    estRituel?: BoolFilter<"Sort"> | boolean
    ecoleId?: IntNullableFilter<"Sort"> | number | null
  }

  export type EcoleMagieCreateWithoutSortsInput = {
    nom: string
  }

  export type EcoleMagieUncheckedCreateWithoutSortsInput = {
    id?: number
    nom: string
  }

  export type EcoleMagieCreateOrConnectWithoutSortsInput = {
    where: EcoleMagieWhereUniqueInput
    create: XOR<EcoleMagieCreateWithoutSortsInput, EcoleMagieUncheckedCreateWithoutSortsInput>
  }

  export type EcoleMagieUpsertWithoutSortsInput = {
    update: XOR<EcoleMagieUpdateWithoutSortsInput, EcoleMagieUncheckedUpdateWithoutSortsInput>
    create: XOR<EcoleMagieCreateWithoutSortsInput, EcoleMagieUncheckedCreateWithoutSortsInput>
    where?: EcoleMagieWhereInput
  }

  export type EcoleMagieUpdateToOneWithWhereWithoutSortsInput = {
    where?: EcoleMagieWhereInput
    data: XOR<EcoleMagieUpdateWithoutSortsInput, EcoleMagieUncheckedUpdateWithoutSortsInput>
  }

  export type EcoleMagieUpdateWithoutSortsInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type EcoleMagieUncheckedUpdateWithoutSortsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type PersonnageMaladieCreateWithoutMaladieInput = {
    dateDebut: Date | string
    dateFin?: Date | string | null
    issue?: string | null
    personnage: PersonnageCreateNestedOneWithoutMaladiesInput
  }

  export type PersonnageMaladieUncheckedCreateWithoutMaladieInput = {
    personnageId: number
    dateDebut: Date | string
    dateFin?: Date | string | null
    issue?: string | null
  }

  export type PersonnageMaladieCreateOrConnectWithoutMaladieInput = {
    where: PersonnageMaladieWhereUniqueInput
    create: XOR<PersonnageMaladieCreateWithoutMaladieInput, PersonnageMaladieUncheckedCreateWithoutMaladieInput>
  }

  export type PersonnageMaladieCreateManyMaladieInputEnvelope = {
    data: PersonnageMaladieCreateManyMaladieInput | PersonnageMaladieCreateManyMaladieInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageMaladieUpsertWithWhereUniqueWithoutMaladieInput = {
    where: PersonnageMaladieWhereUniqueInput
    update: XOR<PersonnageMaladieUpdateWithoutMaladieInput, PersonnageMaladieUncheckedUpdateWithoutMaladieInput>
    create: XOR<PersonnageMaladieCreateWithoutMaladieInput, PersonnageMaladieUncheckedCreateWithoutMaladieInput>
  }

  export type PersonnageMaladieUpdateWithWhereUniqueWithoutMaladieInput = {
    where: PersonnageMaladieWhereUniqueInput
    data: XOR<PersonnageMaladieUpdateWithoutMaladieInput, PersonnageMaladieUncheckedUpdateWithoutMaladieInput>
  }

  export type PersonnageMaladieUpdateManyWithWhereWithoutMaladieInput = {
    where: PersonnageMaladieScalarWhereInput
    data: XOR<PersonnageMaladieUpdateManyMutationInput, PersonnageMaladieUncheckedUpdateManyWithoutMaladieInput>
  }

  export type PersonnageCreateWithoutMaladiesInput = {
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    race?: RaceCreateNestedOneWithoutPersonnagesInput
    lignee?: LigneeCreateNestedOneWithoutPersonnagesInput
    roles?: PersonnageRoleCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUncheckedCreateWithoutMaladiesInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
    ligneeId?: number | null
    roles?: PersonnageRoleUncheckedCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceUncheckedCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeUncheckedCreateNestedManyWithoutCommandantInput
    equipements?: PersonnageEquipementUncheckedCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreUncheckedCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageCreateOrConnectWithoutMaladiesInput = {
    where: PersonnageWhereUniqueInput
    create: XOR<PersonnageCreateWithoutMaladiesInput, PersonnageUncheckedCreateWithoutMaladiesInput>
  }

  export type MaladieCreateWithoutCasInput = {
    nom: string
    effets?: string | null
    contagion?: string | null
    remede?: string | null
    tauxMortalite?: number | null
  }

  export type MaladieUncheckedCreateWithoutCasInput = {
    id?: number
    nom: string
    effets?: string | null
    contagion?: string | null
    remede?: string | null
    tauxMortalite?: number | null
  }

  export type MaladieCreateOrConnectWithoutCasInput = {
    where: MaladieWhereUniqueInput
    create: XOR<MaladieCreateWithoutCasInput, MaladieUncheckedCreateWithoutCasInput>
  }

  export type PersonnageUpsertWithoutMaladiesInput = {
    update: XOR<PersonnageUpdateWithoutMaladiesInput, PersonnageUncheckedUpdateWithoutMaladiesInput>
    create: XOR<PersonnageCreateWithoutMaladiesInput, PersonnageUncheckedCreateWithoutMaladiesInput>
    where?: PersonnageWhereInput
  }

  export type PersonnageUpdateToOneWithWhereWithoutMaladiesInput = {
    where?: PersonnageWhereInput
    data: XOR<PersonnageUpdateWithoutMaladiesInput, PersonnageUncheckedUpdateWithoutMaladiesInput>
  }

  export type PersonnageUpdateWithoutMaladiesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneWithoutPersonnagesNestedInput
    lignee?: LigneeUpdateOneWithoutPersonnagesNestedInput
    roles?: PersonnageRoleUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateWithoutMaladiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
    roles?: PersonnageRoleUncheckedUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUncheckedUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUncheckedUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUncheckedUpdateManyWithoutPersonnageNestedInput
  }

  export type MaladieUpsertWithoutCasInput = {
    update: XOR<MaladieUpdateWithoutCasInput, MaladieUncheckedUpdateWithoutCasInput>
    create: XOR<MaladieCreateWithoutCasInput, MaladieUncheckedCreateWithoutCasInput>
    where?: MaladieWhereInput
  }

  export type MaladieUpdateToOneWithWhereWithoutCasInput = {
    where?: MaladieWhereInput
    data: XOR<MaladieUpdateWithoutCasInput, MaladieUncheckedUpdateWithoutCasInput>
  }

  export type MaladieUpdateWithoutCasInput = {
    nom?: StringFieldUpdateOperationsInput | string
    effets?: NullableStringFieldUpdateOperationsInput | string | null
    contagion?: NullableStringFieldUpdateOperationsInput | string | null
    remede?: NullableStringFieldUpdateOperationsInput | string | null
    tauxMortalite?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MaladieUncheckedUpdateWithoutCasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    effets?: NullableStringFieldUpdateOperationsInput | string | null
    contagion?: NullableStringFieldUpdateOperationsInput | string | null
    remede?: NullableStringFieldUpdateOperationsInput | string | null
    tauxMortalite?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DomaineCreateWithoutArmeesInput = {
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageCreateNestedManyWithoutDomaineInput
    titres?: PersonnageTitreCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueCreateNestedManyWithoutDomaineSourceInput
    relationsCible?: RelationDiplomatiqueCreateNestedManyWithoutDomaineCibleInput
    lois?: LoiTerritoireCreateNestedManyWithoutDomaineInput
  }

  export type DomaineUncheckedCreateWithoutArmeesInput = {
    id?: number
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageUncheckedCreateNestedManyWithoutDomaineInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineSourceInput
    relationsCible?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineCibleInput
    lois?: LoiTerritoireUncheckedCreateNestedManyWithoutDomaineInput
  }

  export type DomaineCreateOrConnectWithoutArmeesInput = {
    where: DomaineWhereUniqueInput
    create: XOR<DomaineCreateWithoutArmeesInput, DomaineUncheckedCreateWithoutArmeesInput>
  }

  export type PersonnageCreateWithoutCommandementsInput = {
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    race?: RaceCreateNestedOneWithoutPersonnagesInput
    lignee?: LigneeCreateNestedOneWithoutPersonnagesInput
    roles?: PersonnageRoleCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieCreateNestedManyWithoutPersonnageInput
    equipements?: PersonnageEquipementCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUncheckedCreateWithoutCommandementsInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
    ligneeId?: number | null
    roles?: PersonnageRoleUncheckedCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceUncheckedCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieUncheckedCreateNestedManyWithoutPersonnageInput
    equipements?: PersonnageEquipementUncheckedCreateNestedManyWithoutPersonnageInput
    guildes?: GuildeMembreUncheckedCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageCreateOrConnectWithoutCommandementsInput = {
    where: PersonnageWhereUniqueInput
    create: XOR<PersonnageCreateWithoutCommandementsInput, PersonnageUncheckedCreateWithoutCommandementsInput>
  }

  export type ArmeeBatailleCreateWithoutArmeeInput = {
    cote?: string | null
    pertes?: number | null
    bataille: BatailleCreateNestedOneWithoutArmeesInput
  }

  export type ArmeeBatailleUncheckedCreateWithoutArmeeInput = {
    batailleId: number
    cote?: string | null
    pertes?: number | null
  }

  export type ArmeeBatailleCreateOrConnectWithoutArmeeInput = {
    where: ArmeeBatailleWhereUniqueInput
    create: XOR<ArmeeBatailleCreateWithoutArmeeInput, ArmeeBatailleUncheckedCreateWithoutArmeeInput>
  }

  export type ArmeeBatailleCreateManyArmeeInputEnvelope = {
    data: ArmeeBatailleCreateManyArmeeInput | ArmeeBatailleCreateManyArmeeInput[]
    skipDuplicates?: boolean
  }

  export type InventaireCreateWithoutArmeeInput = {
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    lieu?: LieuCreateNestedOneWithoutInventairesInput
    Village?: VillageCreateNestedOneWithoutInventairesInput
  }

  export type InventaireUncheckedCreateWithoutArmeeInput = {
    id?: number
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    lieuId?: number | null
    villageId?: number | null
  }

  export type InventaireCreateOrConnectWithoutArmeeInput = {
    where: InventaireWhereUniqueInput
    create: XOR<InventaireCreateWithoutArmeeInput, InventaireUncheckedCreateWithoutArmeeInput>
  }

  export type InventaireCreateManyArmeeInputEnvelope = {
    data: InventaireCreateManyArmeeInput | InventaireCreateManyArmeeInput[]
    skipDuplicates?: boolean
  }

  export type DomaineUpsertWithoutArmeesInput = {
    update: XOR<DomaineUpdateWithoutArmeesInput, DomaineUncheckedUpdateWithoutArmeesInput>
    create: XOR<DomaineCreateWithoutArmeesInput, DomaineUncheckedCreateWithoutArmeesInput>
    where?: DomaineWhereInput
  }

  export type DomaineUpdateToOneWithWhereWithoutArmeesInput = {
    where?: DomaineWhereInput
    data: XOR<DomaineUpdateWithoutArmeesInput, DomaineUncheckedUpdateWithoutArmeesInput>
  }

  export type DomaineUpdateWithoutArmeesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUpdateManyWithoutDomaineNestedInput
    titres?: PersonnageTitreUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUpdateManyWithoutDomaineSourceNestedInput
    relationsCible?: RelationDiplomatiqueUpdateManyWithoutDomaineCibleNestedInput
    lois?: LoiTerritoireUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineUncheckedUpdateWithoutArmeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUncheckedUpdateManyWithoutDomaineNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineSourceNestedInput
    relationsCible?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineCibleNestedInput
    lois?: LoiTerritoireUncheckedUpdateManyWithoutDomaineNestedInput
  }

  export type PersonnageUpsertWithoutCommandementsInput = {
    update: XOR<PersonnageUpdateWithoutCommandementsInput, PersonnageUncheckedUpdateWithoutCommandementsInput>
    create: XOR<PersonnageCreateWithoutCommandementsInput, PersonnageUncheckedCreateWithoutCommandementsInput>
    where?: PersonnageWhereInput
  }

  export type PersonnageUpdateToOneWithWhereWithoutCommandementsInput = {
    where?: PersonnageWhereInput
    data: XOR<PersonnageUpdateWithoutCommandementsInput, PersonnageUncheckedUpdateWithoutCommandementsInput>
  }

  export type PersonnageUpdateWithoutCommandementsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneWithoutPersonnagesNestedInput
    lignee?: LigneeUpdateOneWithoutPersonnagesNestedInput
    roles?: PersonnageRoleUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUpdateManyWithoutPersonnageNestedInput
    equipements?: PersonnageEquipementUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateWithoutCommandementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
    roles?: PersonnageRoleUncheckedUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUncheckedUpdateManyWithoutPersonnageNestedInput
    equipements?: PersonnageEquipementUncheckedUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUncheckedUpdateManyWithoutPersonnageNestedInput
  }

  export type ArmeeBatailleUpsertWithWhereUniqueWithoutArmeeInput = {
    where: ArmeeBatailleWhereUniqueInput
    update: XOR<ArmeeBatailleUpdateWithoutArmeeInput, ArmeeBatailleUncheckedUpdateWithoutArmeeInput>
    create: XOR<ArmeeBatailleCreateWithoutArmeeInput, ArmeeBatailleUncheckedCreateWithoutArmeeInput>
  }

  export type ArmeeBatailleUpdateWithWhereUniqueWithoutArmeeInput = {
    where: ArmeeBatailleWhereUniqueInput
    data: XOR<ArmeeBatailleUpdateWithoutArmeeInput, ArmeeBatailleUncheckedUpdateWithoutArmeeInput>
  }

  export type ArmeeBatailleUpdateManyWithWhereWithoutArmeeInput = {
    where: ArmeeBatailleScalarWhereInput
    data: XOR<ArmeeBatailleUpdateManyMutationInput, ArmeeBatailleUncheckedUpdateManyWithoutArmeeInput>
  }

  export type ArmeeBatailleScalarWhereInput = {
    AND?: ArmeeBatailleScalarWhereInput | ArmeeBatailleScalarWhereInput[]
    OR?: ArmeeBatailleScalarWhereInput[]
    NOT?: ArmeeBatailleScalarWhereInput | ArmeeBatailleScalarWhereInput[]
    armeeId?: IntFilter<"ArmeeBataille"> | number
    batailleId?: IntFilter<"ArmeeBataille"> | number
    cote?: StringNullableFilter<"ArmeeBataille"> | string | null
    pertes?: IntNullableFilter<"ArmeeBataille"> | number | null
  }

  export type InventaireUpsertWithWhereUniqueWithoutArmeeInput = {
    where: InventaireWhereUniqueInput
    update: XOR<InventaireUpdateWithoutArmeeInput, InventaireUncheckedUpdateWithoutArmeeInput>
    create: XOR<InventaireCreateWithoutArmeeInput, InventaireUncheckedCreateWithoutArmeeInput>
  }

  export type InventaireUpdateWithWhereUniqueWithoutArmeeInput = {
    where: InventaireWhereUniqueInput
    data: XOR<InventaireUpdateWithoutArmeeInput, InventaireUncheckedUpdateWithoutArmeeInput>
  }

  export type InventaireUpdateManyWithWhereWithoutArmeeInput = {
    where: InventaireScalarWhereInput
    data: XOR<InventaireUpdateManyMutationInput, InventaireUncheckedUpdateManyWithoutArmeeInput>
  }

  export type ArmeeBatailleCreateWithoutBatailleInput = {
    cote?: string | null
    pertes?: number | null
    armee: ArmeeCreateNestedOneWithoutBataillesInput
  }

  export type ArmeeBatailleUncheckedCreateWithoutBatailleInput = {
    armeeId: number
    cote?: string | null
    pertes?: number | null
  }

  export type ArmeeBatailleCreateOrConnectWithoutBatailleInput = {
    where: ArmeeBatailleWhereUniqueInput
    create: XOR<ArmeeBatailleCreateWithoutBatailleInput, ArmeeBatailleUncheckedCreateWithoutBatailleInput>
  }

  export type ArmeeBatailleCreateManyBatailleInputEnvelope = {
    data: ArmeeBatailleCreateManyBatailleInput | ArmeeBatailleCreateManyBatailleInput[]
    skipDuplicates?: boolean
  }

  export type GuildeBatailleCreateWithoutBatailleInput = {
    role?: string | null
    guilde: GuildeCreateNestedOneWithoutBataillesInput
  }

  export type GuildeBatailleUncheckedCreateWithoutBatailleInput = {
    guildeId: number
    role?: string | null
  }

  export type GuildeBatailleCreateOrConnectWithoutBatailleInput = {
    where: GuildeBatailleWhereUniqueInput
    create: XOR<GuildeBatailleCreateWithoutBatailleInput, GuildeBatailleUncheckedCreateWithoutBatailleInput>
  }

  export type GuildeBatailleCreateManyBatailleInputEnvelope = {
    data: GuildeBatailleCreateManyBatailleInput | GuildeBatailleCreateManyBatailleInput[]
    skipDuplicates?: boolean
  }

  export type CreatureBatailleCreateWithoutBatailleInput = {
    nombre?: number | null
    role?: string | null
    creature: CreatureCreateNestedOneWithoutBataillesInput
  }

  export type CreatureBatailleUncheckedCreateWithoutBatailleInput = {
    creatureId: number
    nombre?: number | null
    role?: string | null
  }

  export type CreatureBatailleCreateOrConnectWithoutBatailleInput = {
    where: CreatureBatailleWhereUniqueInput
    create: XOR<CreatureBatailleCreateWithoutBatailleInput, CreatureBatailleUncheckedCreateWithoutBatailleInput>
  }

  export type CreatureBatailleCreateManyBatailleInputEnvelope = {
    data: CreatureBatailleCreateManyBatailleInput | CreatureBatailleCreateManyBatailleInput[]
    skipDuplicates?: boolean
  }

  export type ArmeeBatailleUpsertWithWhereUniqueWithoutBatailleInput = {
    where: ArmeeBatailleWhereUniqueInput
    update: XOR<ArmeeBatailleUpdateWithoutBatailleInput, ArmeeBatailleUncheckedUpdateWithoutBatailleInput>
    create: XOR<ArmeeBatailleCreateWithoutBatailleInput, ArmeeBatailleUncheckedCreateWithoutBatailleInput>
  }

  export type ArmeeBatailleUpdateWithWhereUniqueWithoutBatailleInput = {
    where: ArmeeBatailleWhereUniqueInput
    data: XOR<ArmeeBatailleUpdateWithoutBatailleInput, ArmeeBatailleUncheckedUpdateWithoutBatailleInput>
  }

  export type ArmeeBatailleUpdateManyWithWhereWithoutBatailleInput = {
    where: ArmeeBatailleScalarWhereInput
    data: XOR<ArmeeBatailleUpdateManyMutationInput, ArmeeBatailleUncheckedUpdateManyWithoutBatailleInput>
  }

  export type GuildeBatailleUpsertWithWhereUniqueWithoutBatailleInput = {
    where: GuildeBatailleWhereUniqueInput
    update: XOR<GuildeBatailleUpdateWithoutBatailleInput, GuildeBatailleUncheckedUpdateWithoutBatailleInput>
    create: XOR<GuildeBatailleCreateWithoutBatailleInput, GuildeBatailleUncheckedCreateWithoutBatailleInput>
  }

  export type GuildeBatailleUpdateWithWhereUniqueWithoutBatailleInput = {
    where: GuildeBatailleWhereUniqueInput
    data: XOR<GuildeBatailleUpdateWithoutBatailleInput, GuildeBatailleUncheckedUpdateWithoutBatailleInput>
  }

  export type GuildeBatailleUpdateManyWithWhereWithoutBatailleInput = {
    where: GuildeBatailleScalarWhereInput
    data: XOR<GuildeBatailleUpdateManyMutationInput, GuildeBatailleUncheckedUpdateManyWithoutBatailleInput>
  }

  export type CreatureBatailleUpsertWithWhereUniqueWithoutBatailleInput = {
    where: CreatureBatailleWhereUniqueInput
    update: XOR<CreatureBatailleUpdateWithoutBatailleInput, CreatureBatailleUncheckedUpdateWithoutBatailleInput>
    create: XOR<CreatureBatailleCreateWithoutBatailleInput, CreatureBatailleUncheckedCreateWithoutBatailleInput>
  }

  export type CreatureBatailleUpdateWithWhereUniqueWithoutBatailleInput = {
    where: CreatureBatailleWhereUniqueInput
    data: XOR<CreatureBatailleUpdateWithoutBatailleInput, CreatureBatailleUncheckedUpdateWithoutBatailleInput>
  }

  export type CreatureBatailleUpdateManyWithWhereWithoutBatailleInput = {
    where: CreatureBatailleScalarWhereInput
    data: XOR<CreatureBatailleUpdateManyMutationInput, CreatureBatailleUncheckedUpdateManyWithoutBatailleInput>
  }

  export type ArmeeCreateWithoutBataillesInput = {
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    domaine?: DomaineCreateNestedOneWithoutArmeesInput
    commandant?: PersonnageCreateNestedOneWithoutCommandementsInput
    inventaires?: InventaireCreateNestedManyWithoutArmeeInput
  }

  export type ArmeeUncheckedCreateWithoutBataillesInput = {
    id?: number
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    domaineId?: number | null
    commandantId?: number | null
    inventaires?: InventaireUncheckedCreateNestedManyWithoutArmeeInput
  }

  export type ArmeeCreateOrConnectWithoutBataillesInput = {
    where: ArmeeWhereUniqueInput
    create: XOR<ArmeeCreateWithoutBataillesInput, ArmeeUncheckedCreateWithoutBataillesInput>
  }

  export type BatailleCreateWithoutArmeesInput = {
    nom?: string | null
    dateBataille?: Date | string | null
    lieu?: string | null
    pertesA?: number | null
    pertesB?: number | null
    vainqueurTexte?: string | null
    guildes?: GuildeBatailleCreateNestedManyWithoutBatailleInput
    creatures?: CreatureBatailleCreateNestedManyWithoutBatailleInput
  }

  export type BatailleUncheckedCreateWithoutArmeesInput = {
    id?: number
    nom?: string | null
    dateBataille?: Date | string | null
    lieu?: string | null
    pertesA?: number | null
    pertesB?: number | null
    vainqueurTexte?: string | null
    guildes?: GuildeBatailleUncheckedCreateNestedManyWithoutBatailleInput
    creatures?: CreatureBatailleUncheckedCreateNestedManyWithoutBatailleInput
  }

  export type BatailleCreateOrConnectWithoutArmeesInput = {
    where: BatailleWhereUniqueInput
    create: XOR<BatailleCreateWithoutArmeesInput, BatailleUncheckedCreateWithoutArmeesInput>
  }

  export type ArmeeUpsertWithoutBataillesInput = {
    update: XOR<ArmeeUpdateWithoutBataillesInput, ArmeeUncheckedUpdateWithoutBataillesInput>
    create: XOR<ArmeeCreateWithoutBataillesInput, ArmeeUncheckedCreateWithoutBataillesInput>
    where?: ArmeeWhereInput
  }

  export type ArmeeUpdateToOneWithWhereWithoutBataillesInput = {
    where?: ArmeeWhereInput
    data: XOR<ArmeeUpdateWithoutBataillesInput, ArmeeUncheckedUpdateWithoutBataillesInput>
  }

  export type ArmeeUpdateWithoutBataillesInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    domaine?: DomaineUpdateOneWithoutArmeesNestedInput
    commandant?: PersonnageUpdateOneWithoutCommandementsNestedInput
    inventaires?: InventaireUpdateManyWithoutArmeeNestedInput
  }

  export type ArmeeUncheckedUpdateWithoutBataillesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    commandantId?: NullableIntFieldUpdateOperationsInput | number | null
    inventaires?: InventaireUncheckedUpdateManyWithoutArmeeNestedInput
  }

  export type BatailleUpsertWithoutArmeesInput = {
    update: XOR<BatailleUpdateWithoutArmeesInput, BatailleUncheckedUpdateWithoutArmeesInput>
    create: XOR<BatailleCreateWithoutArmeesInput, BatailleUncheckedCreateWithoutArmeesInput>
    where?: BatailleWhereInput
  }

  export type BatailleUpdateToOneWithWhereWithoutArmeesInput = {
    where?: BatailleWhereInput
    data: XOR<BatailleUpdateWithoutArmeesInput, BatailleUncheckedUpdateWithoutArmeesInput>
  }

  export type BatailleUpdateWithoutArmeesInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dateBataille?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    pertesA?: NullableIntFieldUpdateOperationsInput | number | null
    pertesB?: NullableIntFieldUpdateOperationsInput | number | null
    vainqueurTexte?: NullableStringFieldUpdateOperationsInput | string | null
    guildes?: GuildeBatailleUpdateManyWithoutBatailleNestedInput
    creatures?: CreatureBatailleUpdateManyWithoutBatailleNestedInput
  }

  export type BatailleUncheckedUpdateWithoutArmeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dateBataille?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    pertesA?: NullableIntFieldUpdateOperationsInput | number | null
    pertesB?: NullableIntFieldUpdateOperationsInput | number | null
    vainqueurTexte?: NullableStringFieldUpdateOperationsInput | string | null
    guildes?: GuildeBatailleUncheckedUpdateManyWithoutBatailleNestedInput
    creatures?: CreatureBatailleUncheckedUpdateManyWithoutBatailleNestedInput
  }

  export type GuildeCreateWithoutBataillesInput = {
    nom: string
    specialite?: string | null
    reputation?: string | null
    membres?: GuildeMembreCreateNestedManyWithoutGuildeInput
  }

  export type GuildeUncheckedCreateWithoutBataillesInput = {
    id?: number
    nom: string
    specialite?: string | null
    reputation?: string | null
    membres?: GuildeMembreUncheckedCreateNestedManyWithoutGuildeInput
  }

  export type GuildeCreateOrConnectWithoutBataillesInput = {
    where: GuildeWhereUniqueInput
    create: XOR<GuildeCreateWithoutBataillesInput, GuildeUncheckedCreateWithoutBataillesInput>
  }

  export type BatailleCreateWithoutGuildesInput = {
    nom?: string | null
    dateBataille?: Date | string | null
    lieu?: string | null
    pertesA?: number | null
    pertesB?: number | null
    vainqueurTexte?: string | null
    armees?: ArmeeBatailleCreateNestedManyWithoutBatailleInput
    creatures?: CreatureBatailleCreateNestedManyWithoutBatailleInput
  }

  export type BatailleUncheckedCreateWithoutGuildesInput = {
    id?: number
    nom?: string | null
    dateBataille?: Date | string | null
    lieu?: string | null
    pertesA?: number | null
    pertesB?: number | null
    vainqueurTexte?: string | null
    armees?: ArmeeBatailleUncheckedCreateNestedManyWithoutBatailleInput
    creatures?: CreatureBatailleUncheckedCreateNestedManyWithoutBatailleInput
  }

  export type BatailleCreateOrConnectWithoutGuildesInput = {
    where: BatailleWhereUniqueInput
    create: XOR<BatailleCreateWithoutGuildesInput, BatailleUncheckedCreateWithoutGuildesInput>
  }

  export type GuildeUpsertWithoutBataillesInput = {
    update: XOR<GuildeUpdateWithoutBataillesInput, GuildeUncheckedUpdateWithoutBataillesInput>
    create: XOR<GuildeCreateWithoutBataillesInput, GuildeUncheckedCreateWithoutBataillesInput>
    where?: GuildeWhereInput
  }

  export type GuildeUpdateToOneWithWhereWithoutBataillesInput = {
    where?: GuildeWhereInput
    data: XOR<GuildeUpdateWithoutBataillesInput, GuildeUncheckedUpdateWithoutBataillesInput>
  }

  export type GuildeUpdateWithoutBataillesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableStringFieldUpdateOperationsInput | string | null
    membres?: GuildeMembreUpdateManyWithoutGuildeNestedInput
  }

  export type GuildeUncheckedUpdateWithoutBataillesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    reputation?: NullableStringFieldUpdateOperationsInput | string | null
    membres?: GuildeMembreUncheckedUpdateManyWithoutGuildeNestedInput
  }

  export type BatailleUpsertWithoutGuildesInput = {
    update: XOR<BatailleUpdateWithoutGuildesInput, BatailleUncheckedUpdateWithoutGuildesInput>
    create: XOR<BatailleCreateWithoutGuildesInput, BatailleUncheckedCreateWithoutGuildesInput>
    where?: BatailleWhereInput
  }

  export type BatailleUpdateToOneWithWhereWithoutGuildesInput = {
    where?: BatailleWhereInput
    data: XOR<BatailleUpdateWithoutGuildesInput, BatailleUncheckedUpdateWithoutGuildesInput>
  }

  export type BatailleUpdateWithoutGuildesInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dateBataille?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    pertesA?: NullableIntFieldUpdateOperationsInput | number | null
    pertesB?: NullableIntFieldUpdateOperationsInput | number | null
    vainqueurTexte?: NullableStringFieldUpdateOperationsInput | string | null
    armees?: ArmeeBatailleUpdateManyWithoutBatailleNestedInput
    creatures?: CreatureBatailleUpdateManyWithoutBatailleNestedInput
  }

  export type BatailleUncheckedUpdateWithoutGuildesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dateBataille?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    pertesA?: NullableIntFieldUpdateOperationsInput | number | null
    pertesB?: NullableIntFieldUpdateOperationsInput | number | null
    vainqueurTexte?: NullableStringFieldUpdateOperationsInput | string | null
    armees?: ArmeeBatailleUncheckedUpdateManyWithoutBatailleNestedInput
    creatures?: CreatureBatailleUncheckedUpdateManyWithoutBatailleNestedInput
  }

  export type CreatureCreateWithoutBataillesInput = {
    espece: string
    forces?: string | null
    faiblesses?: string | null
    dangerosite?: string | null
  }

  export type CreatureUncheckedCreateWithoutBataillesInput = {
    id?: number
    espece: string
    forces?: string | null
    faiblesses?: string | null
    dangerosite?: string | null
  }

  export type CreatureCreateOrConnectWithoutBataillesInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutBataillesInput, CreatureUncheckedCreateWithoutBataillesInput>
  }

  export type BatailleCreateWithoutCreaturesInput = {
    nom?: string | null
    dateBataille?: Date | string | null
    lieu?: string | null
    pertesA?: number | null
    pertesB?: number | null
    vainqueurTexte?: string | null
    armees?: ArmeeBatailleCreateNestedManyWithoutBatailleInput
    guildes?: GuildeBatailleCreateNestedManyWithoutBatailleInput
  }

  export type BatailleUncheckedCreateWithoutCreaturesInput = {
    id?: number
    nom?: string | null
    dateBataille?: Date | string | null
    lieu?: string | null
    pertesA?: number | null
    pertesB?: number | null
    vainqueurTexte?: string | null
    armees?: ArmeeBatailleUncheckedCreateNestedManyWithoutBatailleInput
    guildes?: GuildeBatailleUncheckedCreateNestedManyWithoutBatailleInput
  }

  export type BatailleCreateOrConnectWithoutCreaturesInput = {
    where: BatailleWhereUniqueInput
    create: XOR<BatailleCreateWithoutCreaturesInput, BatailleUncheckedCreateWithoutCreaturesInput>
  }

  export type CreatureUpsertWithoutBataillesInput = {
    update: XOR<CreatureUpdateWithoutBataillesInput, CreatureUncheckedUpdateWithoutBataillesInput>
    create: XOR<CreatureCreateWithoutBataillesInput, CreatureUncheckedCreateWithoutBataillesInput>
    where?: CreatureWhereInput
  }

  export type CreatureUpdateToOneWithWhereWithoutBataillesInput = {
    where?: CreatureWhereInput
    data: XOR<CreatureUpdateWithoutBataillesInput, CreatureUncheckedUpdateWithoutBataillesInput>
  }

  export type CreatureUpdateWithoutBataillesInput = {
    espece?: StringFieldUpdateOperationsInput | string
    forces?: NullableStringFieldUpdateOperationsInput | string | null
    faiblesses?: NullableStringFieldUpdateOperationsInput | string | null
    dangerosite?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureUncheckedUpdateWithoutBataillesInput = {
    id?: IntFieldUpdateOperationsInput | number
    espece?: StringFieldUpdateOperationsInput | string
    forces?: NullableStringFieldUpdateOperationsInput | string | null
    faiblesses?: NullableStringFieldUpdateOperationsInput | string | null
    dangerosite?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatailleUpsertWithoutCreaturesInput = {
    update: XOR<BatailleUpdateWithoutCreaturesInput, BatailleUncheckedUpdateWithoutCreaturesInput>
    create: XOR<BatailleCreateWithoutCreaturesInput, BatailleUncheckedCreateWithoutCreaturesInput>
    where?: BatailleWhereInput
  }

  export type BatailleUpdateToOneWithWhereWithoutCreaturesInput = {
    where?: BatailleWhereInput
    data: XOR<BatailleUpdateWithoutCreaturesInput, BatailleUncheckedUpdateWithoutCreaturesInput>
  }

  export type BatailleUpdateWithoutCreaturesInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dateBataille?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    pertesA?: NullableIntFieldUpdateOperationsInput | number | null
    pertesB?: NullableIntFieldUpdateOperationsInput | number | null
    vainqueurTexte?: NullableStringFieldUpdateOperationsInput | string | null
    armees?: ArmeeBatailleUpdateManyWithoutBatailleNestedInput
    guildes?: GuildeBatailleUpdateManyWithoutBatailleNestedInput
  }

  export type BatailleUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    dateBataille?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    pertesA?: NullableIntFieldUpdateOperationsInput | number | null
    pertesB?: NullableIntFieldUpdateOperationsInput | number | null
    vainqueurTexte?: NullableStringFieldUpdateOperationsInput | string | null
    armees?: ArmeeBatailleUncheckedUpdateManyWithoutBatailleNestedInput
    guildes?: GuildeBatailleUncheckedUpdateManyWithoutBatailleNestedInput
  }

  export type PersonnageEquipementCreateWithoutEquipementInput = {
    dateAcquisition?: Date | string | null
    source?: string | null
    personnage: PersonnageCreateNestedOneWithoutEquipementsInput
  }

  export type PersonnageEquipementUncheckedCreateWithoutEquipementInput = {
    personnageId: number
    dateAcquisition?: Date | string | null
    source?: string | null
  }

  export type PersonnageEquipementCreateOrConnectWithoutEquipementInput = {
    where: PersonnageEquipementWhereUniqueInput
    create: XOR<PersonnageEquipementCreateWithoutEquipementInput, PersonnageEquipementUncheckedCreateWithoutEquipementInput>
  }

  export type PersonnageEquipementCreateManyEquipementInputEnvelope = {
    data: PersonnageEquipementCreateManyEquipementInput | PersonnageEquipementCreateManyEquipementInput[]
    skipDuplicates?: boolean
  }

  export type PersonnageEquipementUpsertWithWhereUniqueWithoutEquipementInput = {
    where: PersonnageEquipementWhereUniqueInput
    update: XOR<PersonnageEquipementUpdateWithoutEquipementInput, PersonnageEquipementUncheckedUpdateWithoutEquipementInput>
    create: XOR<PersonnageEquipementCreateWithoutEquipementInput, PersonnageEquipementUncheckedCreateWithoutEquipementInput>
  }

  export type PersonnageEquipementUpdateWithWhereUniqueWithoutEquipementInput = {
    where: PersonnageEquipementWhereUniqueInput
    data: XOR<PersonnageEquipementUpdateWithoutEquipementInput, PersonnageEquipementUncheckedUpdateWithoutEquipementInput>
  }

  export type PersonnageEquipementUpdateManyWithWhereWithoutEquipementInput = {
    where: PersonnageEquipementScalarWhereInput
    data: XOR<PersonnageEquipementUpdateManyMutationInput, PersonnageEquipementUncheckedUpdateManyWithoutEquipementInput>
  }

  export type PersonnageCreateWithoutEquipementsInput = {
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    race?: RaceCreateNestedOneWithoutPersonnagesInput
    lignee?: LigneeCreateNestedOneWithoutPersonnagesInput
    roles?: PersonnageRoleCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeCreateNestedManyWithoutCommandantInput
    guildes?: GuildeMembreCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageUncheckedCreateWithoutEquipementsInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
    ligneeId?: number | null
    roles?: PersonnageRoleUncheckedCreateNestedManyWithoutPersonnageInput
    competences?: PersonnageCompetenceUncheckedCreateNestedManyWithoutPersonnageInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutPersonnageInput
    maladies?: PersonnageMaladieUncheckedCreateNestedManyWithoutPersonnageInput
    commandements?: ArmeeUncheckedCreateNestedManyWithoutCommandantInput
    guildes?: GuildeMembreUncheckedCreateNestedManyWithoutPersonnageInput
  }

  export type PersonnageCreateOrConnectWithoutEquipementsInput = {
    where: PersonnageWhereUniqueInput
    create: XOR<PersonnageCreateWithoutEquipementsInput, PersonnageUncheckedCreateWithoutEquipementsInput>
  }

  export type EquipementCreateWithoutPossesseursInput = {
    nom: string
    typeEquipement?: string | null
    materiaux?: string | null
    rarete?: string | null
    enchantements?: string | null
    affiniteRequise?: string | null
  }

  export type EquipementUncheckedCreateWithoutPossesseursInput = {
    id?: number
    nom: string
    typeEquipement?: string | null
    materiaux?: string | null
    rarete?: string | null
    enchantements?: string | null
    affiniteRequise?: string | null
  }

  export type EquipementCreateOrConnectWithoutPossesseursInput = {
    where: EquipementWhereUniqueInput
    create: XOR<EquipementCreateWithoutPossesseursInput, EquipementUncheckedCreateWithoutPossesseursInput>
  }

  export type PersonnageUpsertWithoutEquipementsInput = {
    update: XOR<PersonnageUpdateWithoutEquipementsInput, PersonnageUncheckedUpdateWithoutEquipementsInput>
    create: XOR<PersonnageCreateWithoutEquipementsInput, PersonnageUncheckedCreateWithoutEquipementsInput>
    where?: PersonnageWhereInput
  }

  export type PersonnageUpdateToOneWithWhereWithoutEquipementsInput = {
    where?: PersonnageWhereInput
    data: XOR<PersonnageUpdateWithoutEquipementsInput, PersonnageUncheckedUpdateWithoutEquipementsInput>
  }

  export type PersonnageUpdateWithoutEquipementsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneWithoutPersonnagesNestedInput
    lignee?: LigneeUpdateOneWithoutPersonnagesNestedInput
    roles?: PersonnageRoleUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUpdateManyWithoutCommandantNestedInput
    guildes?: GuildeMembreUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateWithoutEquipementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
    roles?: PersonnageRoleUncheckedUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUncheckedUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUncheckedUpdateManyWithoutCommandantNestedInput
    guildes?: GuildeMembreUncheckedUpdateManyWithoutPersonnageNestedInput
  }

  export type EquipementUpsertWithoutPossesseursInput = {
    update: XOR<EquipementUpdateWithoutPossesseursInput, EquipementUncheckedUpdateWithoutPossesseursInput>
    create: XOR<EquipementCreateWithoutPossesseursInput, EquipementUncheckedCreateWithoutPossesseursInput>
    where?: EquipementWhereInput
  }

  export type EquipementUpdateToOneWithWhereWithoutPossesseursInput = {
    where?: EquipementWhereInput
    data: XOR<EquipementUpdateWithoutPossesseursInput, EquipementUncheckedUpdateWithoutPossesseursInput>
  }

  export type EquipementUpdateWithoutPossesseursInput = {
    nom?: StringFieldUpdateOperationsInput | string
    typeEquipement?: NullableStringFieldUpdateOperationsInput | string | null
    materiaux?: NullableStringFieldUpdateOperationsInput | string | null
    rarete?: NullableStringFieldUpdateOperationsInput | string | null
    enchantements?: NullableStringFieldUpdateOperationsInput | string | null
    affiniteRequise?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipementUncheckedUpdateWithoutPossesseursInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    typeEquipement?: NullableStringFieldUpdateOperationsInput | string | null
    materiaux?: NullableStringFieldUpdateOperationsInput | string | null
    rarete?: NullableStringFieldUpdateOperationsInput | string | null
    enchantements?: NullableStringFieldUpdateOperationsInput | string | null
    affiniteRequise?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarchandRouteCreateWithoutMarchandInput = {
    biens?: string | null
    taxes?: number | null
    route: RouteCommercialeCreateNestedOneWithoutMarchandsInput
  }

  export type MarchandRouteUncheckedCreateWithoutMarchandInput = {
    routeId: number
    biens?: string | null
    taxes?: number | null
  }

  export type MarchandRouteCreateOrConnectWithoutMarchandInput = {
    where: MarchandRouteWhereUniqueInput
    create: XOR<MarchandRouteCreateWithoutMarchandInput, MarchandRouteUncheckedCreateWithoutMarchandInput>
  }

  export type MarchandRouteCreateManyMarchandInputEnvelope = {
    data: MarchandRouteCreateManyMarchandInput | MarchandRouteCreateManyMarchandInput[]
    skipDuplicates?: boolean
  }

  export type MarchandRouteUpsertWithWhereUniqueWithoutMarchandInput = {
    where: MarchandRouteWhereUniqueInput
    update: XOR<MarchandRouteUpdateWithoutMarchandInput, MarchandRouteUncheckedUpdateWithoutMarchandInput>
    create: XOR<MarchandRouteCreateWithoutMarchandInput, MarchandRouteUncheckedCreateWithoutMarchandInput>
  }

  export type MarchandRouteUpdateWithWhereUniqueWithoutMarchandInput = {
    where: MarchandRouteWhereUniqueInput
    data: XOR<MarchandRouteUpdateWithoutMarchandInput, MarchandRouteUncheckedUpdateWithoutMarchandInput>
  }

  export type MarchandRouteUpdateManyWithWhereWithoutMarchandInput = {
    where: MarchandRouteScalarWhereInput
    data: XOR<MarchandRouteUpdateManyMutationInput, MarchandRouteUncheckedUpdateManyWithoutMarchandInput>
  }

  export type MarchandRouteScalarWhereInput = {
    AND?: MarchandRouteScalarWhereInput | MarchandRouteScalarWhereInput[]
    OR?: MarchandRouteScalarWhereInput[]
    NOT?: MarchandRouteScalarWhereInput | MarchandRouteScalarWhereInput[]
    marchandId?: IntFilter<"MarchandRoute"> | number
    routeId?: IntFilter<"MarchandRoute"> | number
    biens?: StringNullableFilter<"MarchandRoute"> | string | null
    taxes?: FloatNullableFilter<"MarchandRoute"> | number | null
  }

  export type RouteSegmentCreateWithoutRouteInput = {
    ordre: number
    lieu: LieuCreateNestedOneWithoutSegmentsInput
  }

  export type RouteSegmentUncheckedCreateWithoutRouteInput = {
    lieuId: number
    ordre: number
  }

  export type RouteSegmentCreateOrConnectWithoutRouteInput = {
    where: RouteSegmentWhereUniqueInput
    create: XOR<RouteSegmentCreateWithoutRouteInput, RouteSegmentUncheckedCreateWithoutRouteInput>
  }

  export type RouteSegmentCreateManyRouteInputEnvelope = {
    data: RouteSegmentCreateManyRouteInput | RouteSegmentCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type MarchandRouteCreateWithoutRouteInput = {
    biens?: string | null
    taxes?: number | null
    marchand: MarchandCreateNestedOneWithoutRoutesInput
  }

  export type MarchandRouteUncheckedCreateWithoutRouteInput = {
    marchandId: number
    biens?: string | null
    taxes?: number | null
  }

  export type MarchandRouteCreateOrConnectWithoutRouteInput = {
    where: MarchandRouteWhereUniqueInput
    create: XOR<MarchandRouteCreateWithoutRouteInput, MarchandRouteUncheckedCreateWithoutRouteInput>
  }

  export type MarchandRouteCreateManyRouteInputEnvelope = {
    data: MarchandRouteCreateManyRouteInput | MarchandRouteCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type RouteSegmentUpsertWithWhereUniqueWithoutRouteInput = {
    where: RouteSegmentWhereUniqueInput
    update: XOR<RouteSegmentUpdateWithoutRouteInput, RouteSegmentUncheckedUpdateWithoutRouteInput>
    create: XOR<RouteSegmentCreateWithoutRouteInput, RouteSegmentUncheckedCreateWithoutRouteInput>
  }

  export type RouteSegmentUpdateWithWhereUniqueWithoutRouteInput = {
    where: RouteSegmentWhereUniqueInput
    data: XOR<RouteSegmentUpdateWithoutRouteInput, RouteSegmentUncheckedUpdateWithoutRouteInput>
  }

  export type RouteSegmentUpdateManyWithWhereWithoutRouteInput = {
    where: RouteSegmentScalarWhereInput
    data: XOR<RouteSegmentUpdateManyMutationInput, RouteSegmentUncheckedUpdateManyWithoutRouteInput>
  }

  export type RouteSegmentScalarWhereInput = {
    AND?: RouteSegmentScalarWhereInput | RouteSegmentScalarWhereInput[]
    OR?: RouteSegmentScalarWhereInput[]
    NOT?: RouteSegmentScalarWhereInput | RouteSegmentScalarWhereInput[]
    routeId?: IntFilter<"RouteSegment"> | number
    lieuId?: IntFilter<"RouteSegment"> | number
    ordre?: IntFilter<"RouteSegment"> | number
  }

  export type MarchandRouteUpsertWithWhereUniqueWithoutRouteInput = {
    where: MarchandRouteWhereUniqueInput
    update: XOR<MarchandRouteUpdateWithoutRouteInput, MarchandRouteUncheckedUpdateWithoutRouteInput>
    create: XOR<MarchandRouteCreateWithoutRouteInput, MarchandRouteUncheckedCreateWithoutRouteInput>
  }

  export type MarchandRouteUpdateWithWhereUniqueWithoutRouteInput = {
    where: MarchandRouteWhereUniqueInput
    data: XOR<MarchandRouteUpdateWithoutRouteInput, MarchandRouteUncheckedUpdateWithoutRouteInput>
  }

  export type MarchandRouteUpdateManyWithWhereWithoutRouteInput = {
    where: MarchandRouteScalarWhereInput
    data: XOR<MarchandRouteUpdateManyMutationInput, MarchandRouteUncheckedUpdateManyWithoutRouteInput>
  }

  export type RouteSegmentCreateWithoutLieuInput = {
    ordre: number
    route: RouteCommercialeCreateNestedOneWithoutSegmentsInput
  }

  export type RouteSegmentUncheckedCreateWithoutLieuInput = {
    routeId: number
    ordre: number
  }

  export type RouteSegmentCreateOrConnectWithoutLieuInput = {
    where: RouteSegmentWhereUniqueInput
    create: XOR<RouteSegmentCreateWithoutLieuInput, RouteSegmentUncheckedCreateWithoutLieuInput>
  }

  export type RouteSegmentCreateManyLieuInputEnvelope = {
    data: RouteSegmentCreateManyLieuInput | RouteSegmentCreateManyLieuInput[]
    skipDuplicates?: boolean
  }

  export type InventaireCreateWithoutLieuInput = {
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    armee?: ArmeeCreateNestedOneWithoutInventairesInput
    Village?: VillageCreateNestedOneWithoutInventairesInput
  }

  export type InventaireUncheckedCreateWithoutLieuInput = {
    id?: number
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    armeeId?: number | null
    villageId?: number | null
  }

  export type InventaireCreateOrConnectWithoutLieuInput = {
    where: InventaireWhereUniqueInput
    create: XOR<InventaireCreateWithoutLieuInput, InventaireUncheckedCreateWithoutLieuInput>
  }

  export type InventaireCreateManyLieuInputEnvelope = {
    data: InventaireCreateManyLieuInput | InventaireCreateManyLieuInput[]
    skipDuplicates?: boolean
  }

  export type RouteSegmentUpsertWithWhereUniqueWithoutLieuInput = {
    where: RouteSegmentWhereUniqueInput
    update: XOR<RouteSegmentUpdateWithoutLieuInput, RouteSegmentUncheckedUpdateWithoutLieuInput>
    create: XOR<RouteSegmentCreateWithoutLieuInput, RouteSegmentUncheckedCreateWithoutLieuInput>
  }

  export type RouteSegmentUpdateWithWhereUniqueWithoutLieuInput = {
    where: RouteSegmentWhereUniqueInput
    data: XOR<RouteSegmentUpdateWithoutLieuInput, RouteSegmentUncheckedUpdateWithoutLieuInput>
  }

  export type RouteSegmentUpdateManyWithWhereWithoutLieuInput = {
    where: RouteSegmentScalarWhereInput
    data: XOR<RouteSegmentUpdateManyMutationInput, RouteSegmentUncheckedUpdateManyWithoutLieuInput>
  }

  export type InventaireUpsertWithWhereUniqueWithoutLieuInput = {
    where: InventaireWhereUniqueInput
    update: XOR<InventaireUpdateWithoutLieuInput, InventaireUncheckedUpdateWithoutLieuInput>
    create: XOR<InventaireCreateWithoutLieuInput, InventaireUncheckedCreateWithoutLieuInput>
  }

  export type InventaireUpdateWithWhereUniqueWithoutLieuInput = {
    where: InventaireWhereUniqueInput
    data: XOR<InventaireUpdateWithoutLieuInput, InventaireUncheckedUpdateWithoutLieuInput>
  }

  export type InventaireUpdateManyWithWhereWithoutLieuInput = {
    where: InventaireScalarWhereInput
    data: XOR<InventaireUpdateManyMutationInput, InventaireUncheckedUpdateManyWithoutLieuInput>
  }

  export type RouteCommercialeCreateWithoutSegmentsInput = {
    nom: string
    securite?: string | null
    saison?: string | null
    marchands?: MarchandRouteCreateNestedManyWithoutRouteInput
  }

  export type RouteCommercialeUncheckedCreateWithoutSegmentsInput = {
    id?: number
    nom: string
    securite?: string | null
    saison?: string | null
    marchands?: MarchandRouteUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCommercialeCreateOrConnectWithoutSegmentsInput = {
    where: RouteCommercialeWhereUniqueInput
    create: XOR<RouteCommercialeCreateWithoutSegmentsInput, RouteCommercialeUncheckedCreateWithoutSegmentsInput>
  }

  export type LieuCreateWithoutSegmentsInput = {
    nom: string
    typeLieu?: string | null
    localisation?: string | null
    inventaires?: InventaireCreateNestedManyWithoutLieuInput
  }

  export type LieuUncheckedCreateWithoutSegmentsInput = {
    id?: number
    nom: string
    typeLieu?: string | null
    localisation?: string | null
    inventaires?: InventaireUncheckedCreateNestedManyWithoutLieuInput
  }

  export type LieuCreateOrConnectWithoutSegmentsInput = {
    where: LieuWhereUniqueInput
    create: XOR<LieuCreateWithoutSegmentsInput, LieuUncheckedCreateWithoutSegmentsInput>
  }

  export type RouteCommercialeUpsertWithoutSegmentsInput = {
    update: XOR<RouteCommercialeUpdateWithoutSegmentsInput, RouteCommercialeUncheckedUpdateWithoutSegmentsInput>
    create: XOR<RouteCommercialeCreateWithoutSegmentsInput, RouteCommercialeUncheckedCreateWithoutSegmentsInput>
    where?: RouteCommercialeWhereInput
  }

  export type RouteCommercialeUpdateToOneWithWhereWithoutSegmentsInput = {
    where?: RouteCommercialeWhereInput
    data: XOR<RouteCommercialeUpdateWithoutSegmentsInput, RouteCommercialeUncheckedUpdateWithoutSegmentsInput>
  }

  export type RouteCommercialeUpdateWithoutSegmentsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    securite?: NullableStringFieldUpdateOperationsInput | string | null
    saison?: NullableStringFieldUpdateOperationsInput | string | null
    marchands?: MarchandRouteUpdateManyWithoutRouteNestedInput
  }

  export type RouteCommercialeUncheckedUpdateWithoutSegmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    securite?: NullableStringFieldUpdateOperationsInput | string | null
    saison?: NullableStringFieldUpdateOperationsInput | string | null
    marchands?: MarchandRouteUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type LieuUpsertWithoutSegmentsInput = {
    update: XOR<LieuUpdateWithoutSegmentsInput, LieuUncheckedUpdateWithoutSegmentsInput>
    create: XOR<LieuCreateWithoutSegmentsInput, LieuUncheckedCreateWithoutSegmentsInput>
    where?: LieuWhereInput
  }

  export type LieuUpdateToOneWithWhereWithoutSegmentsInput = {
    where?: LieuWhereInput
    data: XOR<LieuUpdateWithoutSegmentsInput, LieuUncheckedUpdateWithoutSegmentsInput>
  }

  export type LieuUpdateWithoutSegmentsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    typeLieu?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    inventaires?: InventaireUpdateManyWithoutLieuNestedInput
  }

  export type LieuUncheckedUpdateWithoutSegmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    typeLieu?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    inventaires?: InventaireUncheckedUpdateManyWithoutLieuNestedInput
  }

  export type MarchandCreateWithoutRoutesInput = {
    nom: string
  }

  export type MarchandUncheckedCreateWithoutRoutesInput = {
    id?: number
    nom: string
  }

  export type MarchandCreateOrConnectWithoutRoutesInput = {
    where: MarchandWhereUniqueInput
    create: XOR<MarchandCreateWithoutRoutesInput, MarchandUncheckedCreateWithoutRoutesInput>
  }

  export type RouteCommercialeCreateWithoutMarchandsInput = {
    nom: string
    securite?: string | null
    saison?: string | null
    segments?: RouteSegmentCreateNestedManyWithoutRouteInput
  }

  export type RouteCommercialeUncheckedCreateWithoutMarchandsInput = {
    id?: number
    nom: string
    securite?: string | null
    saison?: string | null
    segments?: RouteSegmentUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCommercialeCreateOrConnectWithoutMarchandsInput = {
    where: RouteCommercialeWhereUniqueInput
    create: XOR<RouteCommercialeCreateWithoutMarchandsInput, RouteCommercialeUncheckedCreateWithoutMarchandsInput>
  }

  export type MarchandUpsertWithoutRoutesInput = {
    update: XOR<MarchandUpdateWithoutRoutesInput, MarchandUncheckedUpdateWithoutRoutesInput>
    create: XOR<MarchandCreateWithoutRoutesInput, MarchandUncheckedCreateWithoutRoutesInput>
    where?: MarchandWhereInput
  }

  export type MarchandUpdateToOneWithWhereWithoutRoutesInput = {
    where?: MarchandWhereInput
    data: XOR<MarchandUpdateWithoutRoutesInput, MarchandUncheckedUpdateWithoutRoutesInput>
  }

  export type MarchandUpdateWithoutRoutesInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type MarchandUncheckedUpdateWithoutRoutesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type RouteCommercialeUpsertWithoutMarchandsInput = {
    update: XOR<RouteCommercialeUpdateWithoutMarchandsInput, RouteCommercialeUncheckedUpdateWithoutMarchandsInput>
    create: XOR<RouteCommercialeCreateWithoutMarchandsInput, RouteCommercialeUncheckedCreateWithoutMarchandsInput>
    where?: RouteCommercialeWhereInput
  }

  export type RouteCommercialeUpdateToOneWithWhereWithoutMarchandsInput = {
    where?: RouteCommercialeWhereInput
    data: XOR<RouteCommercialeUpdateWithoutMarchandsInput, RouteCommercialeUncheckedUpdateWithoutMarchandsInput>
  }

  export type RouteCommercialeUpdateWithoutMarchandsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    securite?: NullableStringFieldUpdateOperationsInput | string | null
    saison?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: RouteSegmentUpdateManyWithoutRouteNestedInput
  }

  export type RouteCommercialeUncheckedUpdateWithoutMarchandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    securite?: NullableStringFieldUpdateOperationsInput | string | null
    saison?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: RouteSegmentUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type HistoireCreateWithoutBardeInput = {
    titre?: string | null
    typeEvenement?: string | null
    description?: string | null
    dateEvenement?: Date | string | null
  }

  export type HistoireUncheckedCreateWithoutBardeInput = {
    id?: number
    titre?: string | null
    typeEvenement?: string | null
    description?: string | null
    dateEvenement?: Date | string | null
  }

  export type HistoireCreateOrConnectWithoutBardeInput = {
    where: HistoireWhereUniqueInput
    create: XOR<HistoireCreateWithoutBardeInput, HistoireUncheckedCreateWithoutBardeInput>
  }

  export type HistoireCreateManyBardeInputEnvelope = {
    data: HistoireCreateManyBardeInput | HistoireCreateManyBardeInput[]
    skipDuplicates?: boolean
  }

  export type HistoireUpsertWithWhereUniqueWithoutBardeInput = {
    where: HistoireWhereUniqueInput
    update: XOR<HistoireUpdateWithoutBardeInput, HistoireUncheckedUpdateWithoutBardeInput>
    create: XOR<HistoireCreateWithoutBardeInput, HistoireUncheckedCreateWithoutBardeInput>
  }

  export type HistoireUpdateWithWhereUniqueWithoutBardeInput = {
    where: HistoireWhereUniqueInput
    data: XOR<HistoireUpdateWithoutBardeInput, HistoireUncheckedUpdateWithoutBardeInput>
  }

  export type HistoireUpdateManyWithWhereWithoutBardeInput = {
    where: HistoireScalarWhereInput
    data: XOR<HistoireUpdateManyMutationInput, HistoireUncheckedUpdateManyWithoutBardeInput>
  }

  export type HistoireScalarWhereInput = {
    AND?: HistoireScalarWhereInput | HistoireScalarWhereInput[]
    OR?: HistoireScalarWhereInput[]
    NOT?: HistoireScalarWhereInput | HistoireScalarWhereInput[]
    id?: IntFilter<"Histoire"> | number
    titre?: StringNullableFilter<"Histoire"> | string | null
    typeEvenement?: StringNullableFilter<"Histoire"> | string | null
    description?: StringNullableFilter<"Histoire"> | string | null
    dateEvenement?: DateTimeNullableFilter<"Histoire"> | Date | string | null
    bardeId?: IntNullableFilter<"Histoire"> | number | null
  }

  export type BardeCreateWithoutHistoiresInput = {
    nom: string
  }

  export type BardeUncheckedCreateWithoutHistoiresInput = {
    id?: number
    nom: string
  }

  export type BardeCreateOrConnectWithoutHistoiresInput = {
    where: BardeWhereUniqueInput
    create: XOR<BardeCreateWithoutHistoiresInput, BardeUncheckedCreateWithoutHistoiresInput>
  }

  export type BardeUpsertWithoutHistoiresInput = {
    update: XOR<BardeUpdateWithoutHistoiresInput, BardeUncheckedUpdateWithoutHistoiresInput>
    create: XOR<BardeCreateWithoutHistoiresInput, BardeUncheckedCreateWithoutHistoiresInput>
    where?: BardeWhereInput
  }

  export type BardeUpdateToOneWithWhereWithoutHistoiresInput = {
    where?: BardeWhereInput
    data: XOR<BardeUpdateWithoutHistoiresInput, BardeUncheckedUpdateWithoutHistoiresInput>
  }

  export type BardeUpdateWithoutHistoiresInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type BardeUncheckedUpdateWithoutHistoiresInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type LieuCreateWithoutInventairesInput = {
    nom: string
    typeLieu?: string | null
    localisation?: string | null
    segments?: RouteSegmentCreateNestedManyWithoutLieuInput
  }

  export type LieuUncheckedCreateWithoutInventairesInput = {
    id?: number
    nom: string
    typeLieu?: string | null
    localisation?: string | null
    segments?: RouteSegmentUncheckedCreateNestedManyWithoutLieuInput
  }

  export type LieuCreateOrConnectWithoutInventairesInput = {
    where: LieuWhereUniqueInput
    create: XOR<LieuCreateWithoutInventairesInput, LieuUncheckedCreateWithoutInventairesInput>
  }

  export type ArmeeCreateWithoutInventairesInput = {
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    domaine?: DomaineCreateNestedOneWithoutArmeesInput
    commandant?: PersonnageCreateNestedOneWithoutCommandementsInput
    batailles?: ArmeeBatailleCreateNestedManyWithoutArmeeInput
  }

  export type ArmeeUncheckedCreateWithoutInventairesInput = {
    id?: number
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    domaineId?: number | null
    commandantId?: number | null
    batailles?: ArmeeBatailleUncheckedCreateNestedManyWithoutArmeeInput
  }

  export type ArmeeCreateOrConnectWithoutInventairesInput = {
    where: ArmeeWhereUniqueInput
    create: XOR<ArmeeCreateWithoutInventairesInput, ArmeeUncheckedCreateWithoutInventairesInput>
  }

  export type VillageCreateWithoutInventairesInput = {
    nom: string
    localisation?: string | null
    population?: number | null
    ressourcePrincipale?: string | null
    domaine?: DomaineCreateNestedOneWithoutVillagesInput
  }

  export type VillageUncheckedCreateWithoutInventairesInput = {
    id?: number
    nom: string
    localisation?: string | null
    population?: number | null
    ressourcePrincipale?: string | null
    domaineId?: number | null
  }

  export type VillageCreateOrConnectWithoutInventairesInput = {
    where: VillageWhereUniqueInput
    create: XOR<VillageCreateWithoutInventairesInput, VillageUncheckedCreateWithoutInventairesInput>
  }

  export type LieuUpsertWithoutInventairesInput = {
    update: XOR<LieuUpdateWithoutInventairesInput, LieuUncheckedUpdateWithoutInventairesInput>
    create: XOR<LieuCreateWithoutInventairesInput, LieuUncheckedCreateWithoutInventairesInput>
    where?: LieuWhereInput
  }

  export type LieuUpdateToOneWithWhereWithoutInventairesInput = {
    where?: LieuWhereInput
    data: XOR<LieuUpdateWithoutInventairesInput, LieuUncheckedUpdateWithoutInventairesInput>
  }

  export type LieuUpdateWithoutInventairesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    typeLieu?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: RouteSegmentUpdateManyWithoutLieuNestedInput
  }

  export type LieuUncheckedUpdateWithoutInventairesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    typeLieu?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: RouteSegmentUncheckedUpdateManyWithoutLieuNestedInput
  }

  export type ArmeeUpsertWithoutInventairesInput = {
    update: XOR<ArmeeUpdateWithoutInventairesInput, ArmeeUncheckedUpdateWithoutInventairesInput>
    create: XOR<ArmeeCreateWithoutInventairesInput, ArmeeUncheckedCreateWithoutInventairesInput>
    where?: ArmeeWhereInput
  }

  export type ArmeeUpdateToOneWithWhereWithoutInventairesInput = {
    where?: ArmeeWhereInput
    data: XOR<ArmeeUpdateWithoutInventairesInput, ArmeeUncheckedUpdateWithoutInventairesInput>
  }

  export type ArmeeUpdateWithoutInventairesInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    domaine?: DomaineUpdateOneWithoutArmeesNestedInput
    commandant?: PersonnageUpdateOneWithoutCommandementsNestedInput
    batailles?: ArmeeBatailleUpdateManyWithoutArmeeNestedInput
  }

  export type ArmeeUncheckedUpdateWithoutInventairesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    commandantId?: NullableIntFieldUpdateOperationsInput | number | null
    batailles?: ArmeeBatailleUncheckedUpdateManyWithoutArmeeNestedInput
  }

  export type VillageUpsertWithoutInventairesInput = {
    update: XOR<VillageUpdateWithoutInventairesInput, VillageUncheckedUpdateWithoutInventairesInput>
    create: XOR<VillageCreateWithoutInventairesInput, VillageUncheckedCreateWithoutInventairesInput>
    where?: VillageWhereInput
  }

  export type VillageUpdateToOneWithWhereWithoutInventairesInput = {
    where?: VillageWhereInput
    data: XOR<VillageUpdateWithoutInventairesInput, VillageUncheckedUpdateWithoutInventairesInput>
  }

  export type VillageUpdateWithoutInventairesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    ressourcePrincipale?: NullableStringFieldUpdateOperationsInput | string | null
    domaine?: DomaineUpdateOneWithoutVillagesNestedInput
  }

  export type VillageUncheckedUpdateWithoutInventairesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    ressourcePrincipale?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DomaineCreateWithoutRelationsSourceInput = {
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageCreateNestedManyWithoutDomaineInput
    titres?: PersonnageTitreCreateNestedManyWithoutDomaineInput
    armees?: ArmeeCreateNestedManyWithoutDomaineInput
    relationsCible?: RelationDiplomatiqueCreateNestedManyWithoutDomaineCibleInput
    lois?: LoiTerritoireCreateNestedManyWithoutDomaineInput
  }

  export type DomaineUncheckedCreateWithoutRelationsSourceInput = {
    id?: number
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageUncheckedCreateNestedManyWithoutDomaineInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutDomaineInput
    armees?: ArmeeUncheckedCreateNestedManyWithoutDomaineInput
    relationsCible?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineCibleInput
    lois?: LoiTerritoireUncheckedCreateNestedManyWithoutDomaineInput
  }

  export type DomaineCreateOrConnectWithoutRelationsSourceInput = {
    where: DomaineWhereUniqueInput
    create: XOR<DomaineCreateWithoutRelationsSourceInput, DomaineUncheckedCreateWithoutRelationsSourceInput>
  }

  export type DomaineCreateWithoutRelationsCibleInput = {
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageCreateNestedManyWithoutDomaineInput
    titres?: PersonnageTitreCreateNestedManyWithoutDomaineInput
    armees?: ArmeeCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueCreateNestedManyWithoutDomaineSourceInput
    lois?: LoiTerritoireCreateNestedManyWithoutDomaineInput
  }

  export type DomaineUncheckedCreateWithoutRelationsCibleInput = {
    id?: number
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageUncheckedCreateNestedManyWithoutDomaineInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutDomaineInput
    armees?: ArmeeUncheckedCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineSourceInput
    lois?: LoiTerritoireUncheckedCreateNestedManyWithoutDomaineInput
  }

  export type DomaineCreateOrConnectWithoutRelationsCibleInput = {
    where: DomaineWhereUniqueInput
    create: XOR<DomaineCreateWithoutRelationsCibleInput, DomaineUncheckedCreateWithoutRelationsCibleInput>
  }

  export type DomaineUpsertWithoutRelationsSourceInput = {
    update: XOR<DomaineUpdateWithoutRelationsSourceInput, DomaineUncheckedUpdateWithoutRelationsSourceInput>
    create: XOR<DomaineCreateWithoutRelationsSourceInput, DomaineUncheckedCreateWithoutRelationsSourceInput>
    where?: DomaineWhereInput
  }

  export type DomaineUpdateToOneWithWhereWithoutRelationsSourceInput = {
    where?: DomaineWhereInput
    data: XOR<DomaineUpdateWithoutRelationsSourceInput, DomaineUncheckedUpdateWithoutRelationsSourceInput>
  }

  export type DomaineUpdateWithoutRelationsSourceInput = {
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUpdateManyWithoutDomaineNestedInput
    titres?: PersonnageTitreUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUpdateManyWithoutDomaineNestedInput
    relationsCible?: RelationDiplomatiqueUpdateManyWithoutDomaineCibleNestedInput
    lois?: LoiTerritoireUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineUncheckedUpdateWithoutRelationsSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUncheckedUpdateManyWithoutDomaineNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUncheckedUpdateManyWithoutDomaineNestedInput
    relationsCible?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineCibleNestedInput
    lois?: LoiTerritoireUncheckedUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineUpsertWithoutRelationsCibleInput = {
    update: XOR<DomaineUpdateWithoutRelationsCibleInput, DomaineUncheckedUpdateWithoutRelationsCibleInput>
    create: XOR<DomaineCreateWithoutRelationsCibleInput, DomaineUncheckedCreateWithoutRelationsCibleInput>
    where?: DomaineWhereInput
  }

  export type DomaineUpdateToOneWithWhereWithoutRelationsCibleInput = {
    where?: DomaineWhereInput
    data: XOR<DomaineUpdateWithoutRelationsCibleInput, DomaineUncheckedUpdateWithoutRelationsCibleInput>
  }

  export type DomaineUpdateWithoutRelationsCibleInput = {
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUpdateManyWithoutDomaineNestedInput
    titres?: PersonnageTitreUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUpdateManyWithoutDomaineSourceNestedInput
    lois?: LoiTerritoireUpdateManyWithoutDomaineNestedInput
  }

  export type DomaineUncheckedUpdateWithoutRelationsCibleInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUncheckedUpdateManyWithoutDomaineNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUncheckedUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineSourceNestedInput
    lois?: LoiTerritoireUncheckedUpdateManyWithoutDomaineNestedInput
  }

  export type LoiTerritoireCreateWithoutLoiInput = {
    domaine: DomaineCreateNestedOneWithoutLoisInput
  }

  export type LoiTerritoireUncheckedCreateWithoutLoiInput = {
    domaineId: number
  }

  export type LoiTerritoireCreateOrConnectWithoutLoiInput = {
    where: LoiTerritoireWhereUniqueInput
    create: XOR<LoiTerritoireCreateWithoutLoiInput, LoiTerritoireUncheckedCreateWithoutLoiInput>
  }

  export type LoiTerritoireCreateManyLoiInputEnvelope = {
    data: LoiTerritoireCreateManyLoiInput | LoiTerritoireCreateManyLoiInput[]
    skipDuplicates?: boolean
  }

  export type LoiTerritoireUpsertWithWhereUniqueWithoutLoiInput = {
    where: LoiTerritoireWhereUniqueInput
    update: XOR<LoiTerritoireUpdateWithoutLoiInput, LoiTerritoireUncheckedUpdateWithoutLoiInput>
    create: XOR<LoiTerritoireCreateWithoutLoiInput, LoiTerritoireUncheckedCreateWithoutLoiInput>
  }

  export type LoiTerritoireUpdateWithWhereUniqueWithoutLoiInput = {
    where: LoiTerritoireWhereUniqueInput
    data: XOR<LoiTerritoireUpdateWithoutLoiInput, LoiTerritoireUncheckedUpdateWithoutLoiInput>
  }

  export type LoiTerritoireUpdateManyWithWhereWithoutLoiInput = {
    where: LoiTerritoireScalarWhereInput
    data: XOR<LoiTerritoireUpdateManyMutationInput, LoiTerritoireUncheckedUpdateManyWithoutLoiInput>
  }

  export type LoiCreateWithoutDomainesInput = {
    libelle: string
    effet?: string | null
  }

  export type LoiUncheckedCreateWithoutDomainesInput = {
    id?: number
    libelle: string
    effet?: string | null
  }

  export type LoiCreateOrConnectWithoutDomainesInput = {
    where: LoiWhereUniqueInput
    create: XOR<LoiCreateWithoutDomainesInput, LoiUncheckedCreateWithoutDomainesInput>
  }

  export type DomaineCreateWithoutLoisInput = {
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageCreateNestedManyWithoutDomaineInput
    titres?: PersonnageTitreCreateNestedManyWithoutDomaineInput
    armees?: ArmeeCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueCreateNestedManyWithoutDomaineSourceInput
    relationsCible?: RelationDiplomatiqueCreateNestedManyWithoutDomaineCibleInput
  }

  export type DomaineUncheckedCreateWithoutLoisInput = {
    id?: number
    nom: string
    frontieres?: string | null
    richessesOr?: Decimal | DecimalJsLike | number | string | null
    ressources?: string | null
    villages?: VillageUncheckedCreateNestedManyWithoutDomaineInput
    titres?: PersonnageTitreUncheckedCreateNestedManyWithoutDomaineInput
    armees?: ArmeeUncheckedCreateNestedManyWithoutDomaineInput
    relationsSource?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineSourceInput
    relationsCible?: RelationDiplomatiqueUncheckedCreateNestedManyWithoutDomaineCibleInput
  }

  export type DomaineCreateOrConnectWithoutLoisInput = {
    where: DomaineWhereUniqueInput
    create: XOR<DomaineCreateWithoutLoisInput, DomaineUncheckedCreateWithoutLoisInput>
  }

  export type LoiUpsertWithoutDomainesInput = {
    update: XOR<LoiUpdateWithoutDomainesInput, LoiUncheckedUpdateWithoutDomainesInput>
    create: XOR<LoiCreateWithoutDomainesInput, LoiUncheckedCreateWithoutDomainesInput>
    where?: LoiWhereInput
  }

  export type LoiUpdateToOneWithWhereWithoutDomainesInput = {
    where?: LoiWhereInput
    data: XOR<LoiUpdateWithoutDomainesInput, LoiUncheckedUpdateWithoutDomainesInput>
  }

  export type LoiUpdateWithoutDomainesInput = {
    libelle?: StringFieldUpdateOperationsInput | string
    effet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoiUncheckedUpdateWithoutDomainesInput = {
    id?: IntFieldUpdateOperationsInput | number
    libelle?: StringFieldUpdateOperationsInput | string
    effet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DomaineUpsertWithoutLoisInput = {
    update: XOR<DomaineUpdateWithoutLoisInput, DomaineUncheckedUpdateWithoutLoisInput>
    create: XOR<DomaineCreateWithoutLoisInput, DomaineUncheckedCreateWithoutLoisInput>
    where?: DomaineWhereInput
  }

  export type DomaineUpdateToOneWithWhereWithoutLoisInput = {
    where?: DomaineWhereInput
    data: XOR<DomaineUpdateWithoutLoisInput, DomaineUncheckedUpdateWithoutLoisInput>
  }

  export type DomaineUpdateWithoutLoisInput = {
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUpdateManyWithoutDomaineNestedInput
    titres?: PersonnageTitreUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUpdateManyWithoutDomaineSourceNestedInput
    relationsCible?: RelationDiplomatiqueUpdateManyWithoutDomaineCibleNestedInput
  }

  export type DomaineUncheckedUpdateWithoutLoisInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    frontieres?: NullableStringFieldUpdateOperationsInput | string | null
    richessesOr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ressources?: NullableStringFieldUpdateOperationsInput | string | null
    villages?: VillageUncheckedUpdateManyWithoutDomaineNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutDomaineNestedInput
    armees?: ArmeeUncheckedUpdateManyWithoutDomaineNestedInput
    relationsSource?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineSourceNestedInput
    relationsCible?: RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineCibleNestedInput
  }

  export type PersonnageCreateManyRaceInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    ligneeId?: number | null
  }

  export type CompetenceCreateManyExigenceRaceInput = {
    id?: number
    nom: string
    exigenceFormation?: string | null
  }

  export type PersonnageUpdateWithoutRaceInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    lignee?: LigneeUpdateOneWithoutPersonnagesNestedInput
    roles?: PersonnageRoleUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateWithoutRaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
    roles?: PersonnageRoleUncheckedUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUncheckedUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUncheckedUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUncheckedUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUncheckedUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateManyWithoutRaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompetenceUpdateWithoutExigenceRaceInput = {
    nom?: StringFieldUpdateOperationsInput | string
    exigenceFormation?: NullableStringFieldUpdateOperationsInput | string | null
    personnages?: PersonnageCompetenceUpdateManyWithoutCompetenceNestedInput
  }

  export type CompetenceUncheckedUpdateWithoutExigenceRaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    exigenceFormation?: NullableStringFieldUpdateOperationsInput | string | null
    personnages?: PersonnageCompetenceUncheckedUpdateManyWithoutCompetenceNestedInput
  }

  export type CompetenceUncheckedUpdateManyWithoutExigenceRaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    exigenceFormation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageRoleCreateManyRoleInput = {
    personnageId: number
  }

  export type PersonnageRoleUpdateWithoutRoleInput = {
    personnage?: PersonnageUpdateOneRequiredWithoutRolesNestedInput
  }

  export type PersonnageRoleUncheckedUpdateWithoutRoleInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageRoleUncheckedUpdateManyWithoutRoleInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageCreateManyLigneeInput = {
    id?: number
    nom: string
    dateNaissance?: Date | string | null
    statutVie?: string | null
    dateDeces?: Date | string | null
    causeDeces?: string | null
    raceId?: number | null
  }

  export type PersonnageTitreCreateManyLigneeInput = {
    id?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnageId: number
    titreId: number
    domaineId?: number | null
  }

  export type PersonnageUpdateWithoutLigneeInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    race?: RaceUpdateOneWithoutPersonnagesNestedInput
    roles?: PersonnageRoleUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateWithoutLigneeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
    roles?: PersonnageRoleUncheckedUpdateManyWithoutPersonnageNestedInput
    competences?: PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageNestedInput
    titres?: PersonnageTitreUncheckedUpdateManyWithoutPersonnageNestedInput
    maladies?: PersonnageMaladieUncheckedUpdateManyWithoutPersonnageNestedInput
    commandements?: ArmeeUncheckedUpdateManyWithoutCommandantNestedInput
    equipements?: PersonnageEquipementUncheckedUpdateManyWithoutPersonnageNestedInput
    guildes?: GuildeMembreUncheckedUpdateManyWithoutPersonnageNestedInput
  }

  export type PersonnageUncheckedUpdateManyWithoutLigneeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statutVie?: NullableStringFieldUpdateOperationsInput | string | null
    dateDeces?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    causeDeces?: NullableStringFieldUpdateOperationsInput | string | null
    raceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageTitreUpdateWithoutLigneeInput = {
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnage?: PersonnageUpdateOneRequiredWithoutTitresNestedInput
    titre?: TitreUpdateOneRequiredWithoutAttributionsNestedInput
    domaine?: DomaineUpdateOneWithoutTitresNestedInput
  }

  export type PersonnageTitreUncheckedUpdateWithoutLigneeInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnageId?: IntFieldUpdateOperationsInput | number
    titreId?: IntFieldUpdateOperationsInput | number
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageTitreUncheckedUpdateManyWithoutLigneeInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnageId?: IntFieldUpdateOperationsInput | number
    titreId?: IntFieldUpdateOperationsInput | number
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageRoleCreateManyPersonnageInput = {
    roleId: number
  }

  export type PersonnageCompetenceCreateManyPersonnageInput = {
    competenceId: number
    niveau: number
  }

  export type PersonnageTitreCreateManyPersonnageInput = {
    id?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    titreId: number
    domaineId?: number | null
    ligneeId?: number | null
  }

  export type PersonnageMaladieCreateManyPersonnageInput = {
    maladieId: number
    dateDebut: Date | string
    dateFin?: Date | string | null
    issue?: string | null
  }

  export type ArmeeCreateManyCommandantInput = {
    id?: number
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    domaineId?: number | null
  }

  export type PersonnageEquipementCreateManyPersonnageInput = {
    equipementId: number
    dateAcquisition?: Date | string | null
    source?: string | null
  }

  export type GuildeMembreCreateManyPersonnageInput = {
    guildeId: number
    dateEntree?: Date | string | null
    dateSortie?: Date | string | null
  }

  export type PersonnageRoleUpdateWithoutPersonnageInput = {
    role?: RoleUpdateOneRequiredWithoutPersonnagesNestedInput
  }

  export type PersonnageRoleUncheckedUpdateWithoutPersonnageInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageRoleUncheckedUpdateManyWithoutPersonnageInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageCompetenceUpdateWithoutPersonnageInput = {
    niveau?: IntFieldUpdateOperationsInput | number
    competence?: CompetenceUpdateOneRequiredWithoutPersonnagesNestedInput
  }

  export type PersonnageCompetenceUncheckedUpdateWithoutPersonnageInput = {
    competenceId?: IntFieldUpdateOperationsInput | number
    niveau?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageCompetenceUncheckedUpdateManyWithoutPersonnageInput = {
    competenceId?: IntFieldUpdateOperationsInput | number
    niveau?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageTitreUpdateWithoutPersonnageInput = {
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    titre?: TitreUpdateOneRequiredWithoutAttributionsNestedInput
    domaine?: DomaineUpdateOneWithoutTitresNestedInput
    lignee?: LigneeUpdateOneWithoutTitresNestedInput
  }

  export type PersonnageTitreUncheckedUpdateWithoutPersonnageInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    titreId?: IntFieldUpdateOperationsInput | number
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageTitreUncheckedUpdateManyWithoutPersonnageInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    titreId?: IntFieldUpdateOperationsInput | number
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageMaladieUpdateWithoutPersonnageInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    maladie?: MaladieUpdateOneRequiredWithoutCasNestedInput
  }

  export type PersonnageMaladieUncheckedUpdateWithoutPersonnageInput = {
    maladieId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageMaladieUncheckedUpdateManyWithoutPersonnageInput = {
    maladieId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArmeeUpdateWithoutCommandantInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    domaine?: DomaineUpdateOneWithoutArmeesNestedInput
    batailles?: ArmeeBatailleUpdateManyWithoutArmeeNestedInput
    inventaires?: InventaireUpdateManyWithoutArmeeNestedInput
  }

  export type ArmeeUncheckedUpdateWithoutCommandantInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    batailles?: ArmeeBatailleUncheckedUpdateManyWithoutArmeeNestedInput
    inventaires?: InventaireUncheckedUpdateManyWithoutArmeeNestedInput
  }

  export type ArmeeUncheckedUpdateManyWithoutCommandantInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageEquipementUpdateWithoutPersonnageInput = {
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    equipement?: EquipementUpdateOneRequiredWithoutPossesseursNestedInput
  }

  export type PersonnageEquipementUncheckedUpdateWithoutPersonnageInput = {
    equipementId?: IntFieldUpdateOperationsInput | number
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageEquipementUncheckedUpdateManyWithoutPersonnageInput = {
    equipementId?: IntFieldUpdateOperationsInput | number
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildeMembreUpdateWithoutPersonnageInput = {
    dateEntree?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    guilde?: GuildeUpdateOneRequiredWithoutMembresNestedInput
  }

  export type GuildeMembreUncheckedUpdateWithoutPersonnageInput = {
    guildeId?: IntFieldUpdateOperationsInput | number
    dateEntree?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuildeMembreUncheckedUpdateManyWithoutPersonnageInput = {
    guildeId?: IntFieldUpdateOperationsInput | number
    dateEntree?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonnageCompetenceCreateManyCompetenceInput = {
    personnageId: number
    niveau: number
  }

  export type PersonnageCompetenceUpdateWithoutCompetenceInput = {
    niveau?: IntFieldUpdateOperationsInput | number
    personnage?: PersonnageUpdateOneRequiredWithoutCompetencesNestedInput
  }

  export type PersonnageCompetenceUncheckedUpdateWithoutCompetenceInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    niveau?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageCompetenceUncheckedUpdateManyWithoutCompetenceInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    niveau?: IntFieldUpdateOperationsInput | number
  }

  export type VillageCreateManyDomaineInput = {
    id?: number
    nom: string
    localisation?: string | null
    population?: number | null
    ressourcePrincipale?: string | null
  }

  export type PersonnageTitreCreateManyDomaineInput = {
    id?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnageId: number
    titreId: number
    ligneeId?: number | null
  }

  export type ArmeeCreateManyDomaineInput = {
    id?: number
    nom?: string | null
    effectif?: number | null
    composition?: string | null
    moral?: string | null
    etatApprovisionnement?: string | null
    commandantId?: number | null
  }

  export type RelationDiplomatiqueCreateManyDomaineSourceInput = {
    id?: number
    typeRelation?: string | null
    conditions?: string | null
    dateSignature?: Date | string | null
    echeance?: string | null
    domaineCibleId: number
  }

  export type RelationDiplomatiqueCreateManyDomaineCibleInput = {
    id?: number
    typeRelation?: string | null
    conditions?: string | null
    dateSignature?: Date | string | null
    echeance?: string | null
    domaineSourceId: number
  }

  export type LoiTerritoireCreateManyDomaineInput = {
    loiId: number
  }

  export type VillageUpdateWithoutDomaineInput = {
    nom?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    ressourcePrincipale?: NullableStringFieldUpdateOperationsInput | string | null
    inventaires?: InventaireUpdateManyWithoutVillageNestedInput
  }

  export type VillageUncheckedUpdateWithoutDomaineInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    ressourcePrincipale?: NullableStringFieldUpdateOperationsInput | string | null
    inventaires?: InventaireUncheckedUpdateManyWithoutVillageNestedInput
  }

  export type VillageUncheckedUpdateManyWithoutDomaineInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    population?: NullableIntFieldUpdateOperationsInput | number | null
    ressourcePrincipale?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageTitreUpdateWithoutDomaineInput = {
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnage?: PersonnageUpdateOneRequiredWithoutTitresNestedInput
    titre?: TitreUpdateOneRequiredWithoutAttributionsNestedInput
    lignee?: LigneeUpdateOneWithoutTitresNestedInput
  }

  export type PersonnageTitreUncheckedUpdateWithoutDomaineInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnageId?: IntFieldUpdateOperationsInput | number
    titreId?: IntFieldUpdateOperationsInput | number
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageTitreUncheckedUpdateManyWithoutDomaineInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnageId?: IntFieldUpdateOperationsInput | number
    titreId?: IntFieldUpdateOperationsInput | number
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmeeUpdateWithoutDomaineInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    commandant?: PersonnageUpdateOneWithoutCommandementsNestedInput
    batailles?: ArmeeBatailleUpdateManyWithoutArmeeNestedInput
    inventaires?: InventaireUpdateManyWithoutArmeeNestedInput
  }

  export type ArmeeUncheckedUpdateWithoutDomaineInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    commandantId?: NullableIntFieldUpdateOperationsInput | number | null
    batailles?: ArmeeBatailleUncheckedUpdateManyWithoutArmeeNestedInput
    inventaires?: InventaireUncheckedUpdateManyWithoutArmeeNestedInput
  }

  export type ArmeeUncheckedUpdateManyWithoutDomaineInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    effectif?: NullableIntFieldUpdateOperationsInput | number | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    moral?: NullableStringFieldUpdateOperationsInput | string | null
    etatApprovisionnement?: NullableStringFieldUpdateOperationsInput | string | null
    commandantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RelationDiplomatiqueUpdateWithoutDomaineSourceInput = {
    typeRelation?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    echeance?: NullableStringFieldUpdateOperationsInput | string | null
    domaineCible?: DomaineUpdateOneRequiredWithoutRelationsCibleNestedInput
  }

  export type RelationDiplomatiqueUncheckedUpdateWithoutDomaineSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRelation?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    echeance?: NullableStringFieldUpdateOperationsInput | string | null
    domaineCibleId?: IntFieldUpdateOperationsInput | number
  }

  export type RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRelation?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    echeance?: NullableStringFieldUpdateOperationsInput | string | null
    domaineCibleId?: IntFieldUpdateOperationsInput | number
  }

  export type RelationDiplomatiqueUpdateWithoutDomaineCibleInput = {
    typeRelation?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    echeance?: NullableStringFieldUpdateOperationsInput | string | null
    domaineSource?: DomaineUpdateOneRequiredWithoutRelationsSourceNestedInput
  }

  export type RelationDiplomatiqueUncheckedUpdateWithoutDomaineCibleInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRelation?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    echeance?: NullableStringFieldUpdateOperationsInput | string | null
    domaineSourceId?: IntFieldUpdateOperationsInput | number
  }

  export type RelationDiplomatiqueUncheckedUpdateManyWithoutDomaineCibleInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRelation?: NullableStringFieldUpdateOperationsInput | string | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    echeance?: NullableStringFieldUpdateOperationsInput | string | null
    domaineSourceId?: IntFieldUpdateOperationsInput | number
  }

  export type LoiTerritoireUpdateWithoutDomaineInput = {
    loi?: LoiUpdateOneRequiredWithoutDomainesNestedInput
  }

  export type LoiTerritoireUncheckedUpdateWithoutDomaineInput = {
    loiId?: IntFieldUpdateOperationsInput | number
  }

  export type LoiTerritoireUncheckedUpdateManyWithoutDomaineInput = {
    loiId?: IntFieldUpdateOperationsInput | number
  }

  export type PersonnageTitreCreateManyTitreInput = {
    id?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    estActif?: boolean
    personnageId: number
    domaineId?: number | null
    ligneeId?: number | null
  }

  export type PersonnageTitreUpdateWithoutTitreInput = {
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnage?: PersonnageUpdateOneRequiredWithoutTitresNestedInput
    domaine?: DomaineUpdateOneWithoutTitresNestedInput
    lignee?: LigneeUpdateOneWithoutTitresNestedInput
  }

  export type PersonnageTitreUncheckedUpdateWithoutTitreInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnageId?: IntFieldUpdateOperationsInput | number
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnageTitreUncheckedUpdateManyWithoutTitreInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estActif?: BoolFieldUpdateOperationsInput | boolean
    personnageId?: IntFieldUpdateOperationsInput | number
    domaineId?: NullableIntFieldUpdateOperationsInput | number | null
    ligneeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventaireCreateManyVillageInput = {
    id?: number
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    lieuId?: number | null
    armeeId?: number | null
  }

  export type InventaireUpdateWithoutVillageInput = {
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: LieuUpdateOneWithoutInventairesNestedInput
    armee?: ArmeeUpdateOneWithoutInventairesNestedInput
  }

  export type InventaireUncheckedUpdateWithoutVillageInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuId?: NullableIntFieldUpdateOperationsInput | number | null
    armeeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventaireUncheckedUpdateManyWithoutVillageInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuId?: NullableIntFieldUpdateOperationsInput | number | null
    armeeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GuildeMembreCreateManyGuildeInput = {
    personnageId: number
    dateEntree?: Date | string | null
    dateSortie?: Date | string | null
  }

  export type GuildeBatailleCreateManyGuildeInput = {
    batailleId: number
    role?: string | null
  }

  export type GuildeMembreUpdateWithoutGuildeInput = {
    dateEntree?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnage?: PersonnageUpdateOneRequiredWithoutGuildesNestedInput
  }

  export type GuildeMembreUncheckedUpdateWithoutGuildeInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    dateEntree?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuildeMembreUncheckedUpdateManyWithoutGuildeInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    dateEntree?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GuildeBatailleUpdateWithoutGuildeInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    bataille?: BatailleUpdateOneRequiredWithoutGuildesNestedInput
  }

  export type GuildeBatailleUncheckedUpdateWithoutGuildeInput = {
    batailleId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildeBatailleUncheckedUpdateManyWithoutGuildeInput = {
    batailleId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureBatailleCreateManyCreatureInput = {
    batailleId: number
    nombre?: number | null
    role?: string | null
  }

  export type CreatureBatailleUpdateWithoutCreatureInput = {
    nombre?: NullableIntFieldUpdateOperationsInput | number | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    bataille?: BatailleUpdateOneRequiredWithoutCreaturesNestedInput
  }

  export type CreatureBatailleUncheckedUpdateWithoutCreatureInput = {
    batailleId?: IntFieldUpdateOperationsInput | number
    nombre?: NullableIntFieldUpdateOperationsInput | number | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureBatailleUncheckedUpdateManyWithoutCreatureInput = {
    batailleId?: IntFieldUpdateOperationsInput | number
    nombre?: NullableIntFieldUpdateOperationsInput | number | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SortCreateManyEcoleInput = {
    id?: number
    nom: string
    element?: string | null
    coutMana?: number | null
    niveauRequis?: string | null
    estInterdit?: boolean
    estRituel?: boolean
  }

  export type SortUpdateWithoutEcoleInput = {
    nom?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    coutMana?: NullableIntFieldUpdateOperationsInput | number | null
    niveauRequis?: NullableStringFieldUpdateOperationsInput | string | null
    estInterdit?: BoolFieldUpdateOperationsInput | boolean
    estRituel?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SortUncheckedUpdateWithoutEcoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    coutMana?: NullableIntFieldUpdateOperationsInput | number | null
    niveauRequis?: NullableStringFieldUpdateOperationsInput | string | null
    estInterdit?: BoolFieldUpdateOperationsInput | boolean
    estRituel?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SortUncheckedUpdateManyWithoutEcoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    element?: NullableStringFieldUpdateOperationsInput | string | null
    coutMana?: NullableIntFieldUpdateOperationsInput | number | null
    niveauRequis?: NullableStringFieldUpdateOperationsInput | string | null
    estInterdit?: BoolFieldUpdateOperationsInput | boolean
    estRituel?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersonnageMaladieCreateManyMaladieInput = {
    personnageId: number
    dateDebut: Date | string
    dateFin?: Date | string | null
    issue?: string | null
  }

  export type PersonnageMaladieUpdateWithoutMaladieInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
    personnage?: PersonnageUpdateOneRequiredWithoutMaladiesNestedInput
  }

  export type PersonnageMaladieUncheckedUpdateWithoutMaladieInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageMaladieUncheckedUpdateManyWithoutMaladieInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArmeeBatailleCreateManyArmeeInput = {
    batailleId: number
    cote?: string | null
    pertes?: number | null
  }

  export type InventaireCreateManyArmeeInput = {
    id?: number
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    lieuId?: number | null
    villageId?: number | null
  }

  export type ArmeeBatailleUpdateWithoutArmeeInput = {
    cote?: NullableStringFieldUpdateOperationsInput | string | null
    pertes?: NullableIntFieldUpdateOperationsInput | number | null
    bataille?: BatailleUpdateOneRequiredWithoutArmeesNestedInput
  }

  export type ArmeeBatailleUncheckedUpdateWithoutArmeeInput = {
    batailleId?: IntFieldUpdateOperationsInput | number
    cote?: NullableStringFieldUpdateOperationsInput | string | null
    pertes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmeeBatailleUncheckedUpdateManyWithoutArmeeInput = {
    batailleId?: IntFieldUpdateOperationsInput | number
    cote?: NullableStringFieldUpdateOperationsInput | string | null
    pertes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventaireUpdateWithoutArmeeInput = {
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieu?: LieuUpdateOneWithoutInventairesNestedInput
    Village?: VillageUpdateOneWithoutInventairesNestedInput
  }

  export type InventaireUncheckedUpdateWithoutArmeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuId?: NullableIntFieldUpdateOperationsInput | number | null
    villageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventaireUncheckedUpdateManyWithoutArmeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lieuId?: NullableIntFieldUpdateOperationsInput | number | null
    villageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmeeBatailleCreateManyBatailleInput = {
    armeeId: number
    cote?: string | null
    pertes?: number | null
  }

  export type GuildeBatailleCreateManyBatailleInput = {
    guildeId: number
    role?: string | null
  }

  export type CreatureBatailleCreateManyBatailleInput = {
    creatureId: number
    nombre?: number | null
    role?: string | null
  }

  export type ArmeeBatailleUpdateWithoutBatailleInput = {
    cote?: NullableStringFieldUpdateOperationsInput | string | null
    pertes?: NullableIntFieldUpdateOperationsInput | number | null
    armee?: ArmeeUpdateOneRequiredWithoutBataillesNestedInput
  }

  export type ArmeeBatailleUncheckedUpdateWithoutBatailleInput = {
    armeeId?: IntFieldUpdateOperationsInput | number
    cote?: NullableStringFieldUpdateOperationsInput | string | null
    pertes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArmeeBatailleUncheckedUpdateManyWithoutBatailleInput = {
    armeeId?: IntFieldUpdateOperationsInput | number
    cote?: NullableStringFieldUpdateOperationsInput | string | null
    pertes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GuildeBatailleUpdateWithoutBatailleInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    guilde?: GuildeUpdateOneRequiredWithoutBataillesNestedInput
  }

  export type GuildeBatailleUncheckedUpdateWithoutBatailleInput = {
    guildeId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildeBatailleUncheckedUpdateManyWithoutBatailleInput = {
    guildeId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureBatailleUpdateWithoutBatailleInput = {
    nombre?: NullableIntFieldUpdateOperationsInput | number | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    creature?: CreatureUpdateOneRequiredWithoutBataillesNestedInput
  }

  export type CreatureBatailleUncheckedUpdateWithoutBatailleInput = {
    creatureId?: IntFieldUpdateOperationsInput | number
    nombre?: NullableIntFieldUpdateOperationsInput | number | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreatureBatailleUncheckedUpdateManyWithoutBatailleInput = {
    creatureId?: IntFieldUpdateOperationsInput | number
    nombre?: NullableIntFieldUpdateOperationsInput | number | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageEquipementCreateManyEquipementInput = {
    personnageId: number
    dateAcquisition?: Date | string | null
    source?: string | null
  }

  export type PersonnageEquipementUpdateWithoutEquipementInput = {
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    personnage?: PersonnageUpdateOneRequiredWithoutEquipementsNestedInput
  }

  export type PersonnageEquipementUncheckedUpdateWithoutEquipementInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonnageEquipementUncheckedUpdateManyWithoutEquipementInput = {
    personnageId?: IntFieldUpdateOperationsInput | number
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarchandRouteCreateManyMarchandInput = {
    routeId: number
    biens?: string | null
    taxes?: number | null
  }

  export type MarchandRouteUpdateWithoutMarchandInput = {
    biens?: NullableStringFieldUpdateOperationsInput | string | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    route?: RouteCommercialeUpdateOneRequiredWithoutMarchandsNestedInput
  }

  export type MarchandRouteUncheckedUpdateWithoutMarchandInput = {
    routeId?: IntFieldUpdateOperationsInput | number
    biens?: NullableStringFieldUpdateOperationsInput | string | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MarchandRouteUncheckedUpdateManyWithoutMarchandInput = {
    routeId?: IntFieldUpdateOperationsInput | number
    biens?: NullableStringFieldUpdateOperationsInput | string | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RouteSegmentCreateManyRouteInput = {
    lieuId: number
    ordre: number
  }

  export type MarchandRouteCreateManyRouteInput = {
    marchandId: number
    biens?: string | null
    taxes?: number | null
  }

  export type RouteSegmentUpdateWithoutRouteInput = {
    ordre?: IntFieldUpdateOperationsInput | number
    lieu?: LieuUpdateOneRequiredWithoutSegmentsNestedInput
  }

  export type RouteSegmentUncheckedUpdateWithoutRouteInput = {
    lieuId?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type RouteSegmentUncheckedUpdateManyWithoutRouteInput = {
    lieuId?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type MarchandRouteUpdateWithoutRouteInput = {
    biens?: NullableStringFieldUpdateOperationsInput | string | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    marchand?: MarchandUpdateOneRequiredWithoutRoutesNestedInput
  }

  export type MarchandRouteUncheckedUpdateWithoutRouteInput = {
    marchandId?: IntFieldUpdateOperationsInput | number
    biens?: NullableStringFieldUpdateOperationsInput | string | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MarchandRouteUncheckedUpdateManyWithoutRouteInput = {
    marchandId?: IntFieldUpdateOperationsInput | number
    biens?: NullableStringFieldUpdateOperationsInput | string | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RouteSegmentCreateManyLieuInput = {
    routeId: number
    ordre: number
  }

  export type InventaireCreateManyLieuInput = {
    id?: number
    typeRessource?: string | null
    stock?: number | null
    seuilAlerte?: number | null
    dateMesure?: Date | string | null
    armeeId?: number | null
    villageId?: number | null
  }

  export type RouteSegmentUpdateWithoutLieuInput = {
    ordre?: IntFieldUpdateOperationsInput | number
    route?: RouteCommercialeUpdateOneRequiredWithoutSegmentsNestedInput
  }

  export type RouteSegmentUncheckedUpdateWithoutLieuInput = {
    routeId?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type RouteSegmentUncheckedUpdateManyWithoutLieuInput = {
    routeId?: IntFieldUpdateOperationsInput | number
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type InventaireUpdateWithoutLieuInput = {
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    armee?: ArmeeUpdateOneWithoutInventairesNestedInput
    Village?: VillageUpdateOneWithoutInventairesNestedInput
  }

  export type InventaireUncheckedUpdateWithoutLieuInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    armeeId?: NullableIntFieldUpdateOperationsInput | number | null
    villageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventaireUncheckedUpdateManyWithoutLieuInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeRessource?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    seuilAlerte?: NullableIntFieldUpdateOperationsInput | number | null
    dateMesure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    armeeId?: NullableIntFieldUpdateOperationsInput | number | null
    villageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HistoireCreateManyBardeInput = {
    id?: number
    titre?: string | null
    typeEvenement?: string | null
    description?: string | null
    dateEvenement?: Date | string | null
  }

  export type HistoireUpdateWithoutBardeInput = {
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateEvenement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistoireUncheckedUpdateWithoutBardeInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateEvenement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistoireUncheckedUpdateManyWithoutBardeInput = {
    id?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dateEvenement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LoiTerritoireCreateManyLoiInput = {
    domaineId: number
  }

  export type LoiTerritoireUpdateWithoutLoiInput = {
    domaine?: DomaineUpdateOneRequiredWithoutLoisNestedInput
  }

  export type LoiTerritoireUncheckedUpdateWithoutLoiInput = {
    domaineId?: IntFieldUpdateOperationsInput | number
  }

  export type LoiTerritoireUncheckedUpdateManyWithoutLoiInput = {
    domaineId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use RaceCountOutputTypeDefaultArgs instead
     */
    export type RaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LigneeCountOutputTypeDefaultArgs instead
     */
    export type LigneeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LigneeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnageCountOutputTypeDefaultArgs instead
     */
    export type PersonnageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompetenceCountOutputTypeDefaultArgs instead
     */
    export type CompetenceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompetenceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DomaineCountOutputTypeDefaultArgs instead
     */
    export type DomaineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DomaineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TitreCountOutputTypeDefaultArgs instead
     */
    export type TitreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TitreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VillageCountOutputTypeDefaultArgs instead
     */
    export type VillageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VillageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuildeCountOutputTypeDefaultArgs instead
     */
    export type GuildeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuildeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreatureCountOutputTypeDefaultArgs instead
     */
    export type CreatureCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreatureCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EcoleMagieCountOutputTypeDefaultArgs instead
     */
    export type EcoleMagieCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EcoleMagieCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaladieCountOutputTypeDefaultArgs instead
     */
    export type MaladieCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaladieCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArmeeCountOutputTypeDefaultArgs instead
     */
    export type ArmeeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArmeeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BatailleCountOutputTypeDefaultArgs instead
     */
    export type BatailleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BatailleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipementCountOutputTypeDefaultArgs instead
     */
    export type EquipementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarchandCountOutputTypeDefaultArgs instead
     */
    export type MarchandCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarchandCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RouteCommercialeCountOutputTypeDefaultArgs instead
     */
    export type RouteCommercialeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RouteCommercialeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LieuCountOutputTypeDefaultArgs instead
     */
    export type LieuCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LieuCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BardeCountOutputTypeDefaultArgs instead
     */
    export type BardeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BardeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoiCountOutputTypeDefaultArgs instead
     */
    export type LoiCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoiCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RaceDefaultArgs instead
     */
    export type RaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LigneeDefaultArgs instead
     */
    export type LigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LigneeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnageDefaultArgs instead
     */
    export type PersonnageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnageRoleDefaultArgs instead
     */
    export type PersonnageRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnageRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompetenceDefaultArgs instead
     */
    export type CompetenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompetenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnageCompetenceDefaultArgs instead
     */
    export type PersonnageCompetenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnageCompetenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DomaineDefaultArgs instead
     */
    export type DomaineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DomaineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TitreDefaultArgs instead
     */
    export type TitreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TitreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnageTitreDefaultArgs instead
     */
    export type PersonnageTitreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnageTitreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VillageDefaultArgs instead
     */
    export type VillageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VillageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuildeDefaultArgs instead
     */
    export type GuildeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuildeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuildeMembreDefaultArgs instead
     */
    export type GuildeMembreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuildeMembreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreatureDefaultArgs instead
     */
    export type CreatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreatureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EcoleMagieDefaultArgs instead
     */
    export type EcoleMagieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EcoleMagieDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SortDefaultArgs instead
     */
    export type SortArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SortDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaladieDefaultArgs instead
     */
    export type MaladieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaladieDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnageMaladieDefaultArgs instead
     */
    export type PersonnageMaladieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnageMaladieDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArmeeDefaultArgs instead
     */
    export type ArmeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArmeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BatailleDefaultArgs instead
     */
    export type BatailleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BatailleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArmeeBatailleDefaultArgs instead
     */
    export type ArmeeBatailleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArmeeBatailleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuildeBatailleDefaultArgs instead
     */
    export type GuildeBatailleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuildeBatailleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreatureBatailleDefaultArgs instead
     */
    export type CreatureBatailleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreatureBatailleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipementDefaultArgs instead
     */
    export type EquipementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnageEquipementDefaultArgs instead
     */
    export type PersonnageEquipementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnageEquipementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarchandDefaultArgs instead
     */
    export type MarchandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarchandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RouteCommercialeDefaultArgs instead
     */
    export type RouteCommercialeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RouteCommercialeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LieuDefaultArgs instead
     */
    export type LieuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LieuDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RouteSegmentDefaultArgs instead
     */
    export type RouteSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RouteSegmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarchandRouteDefaultArgs instead
     */
    export type MarchandRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarchandRouteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BardeDefaultArgs instead
     */
    export type BardeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BardeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HistoireDefaultArgs instead
     */
    export type HistoireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HistoireDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventaireDefaultArgs instead
     */
    export type InventaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventaireDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationDiplomatiqueDefaultArgs instead
     */
    export type RelationDiplomatiqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationDiplomatiqueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoiDefaultArgs instead
     */
    export type LoiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoiTerritoireDefaultArgs instead
     */
    export type LoiTerritoireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoiTerritoireDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}